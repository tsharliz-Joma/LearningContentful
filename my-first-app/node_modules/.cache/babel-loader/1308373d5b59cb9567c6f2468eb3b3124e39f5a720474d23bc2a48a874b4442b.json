{"ast":null,"code":"import F, { useRef, useEffect, useState, useCallback, useMemo } from 'react';\nimport { useId, mergeRefs, useControllableState } from '@contentful/f36-core';\nimport { Popover } from '@contentful/f36-popover';\nimport { cx, css } from 'emotion';\nimport C from '@contentful/f36-tokens';\nimport { SectionHeading } from '@contentful/f36-typography';\nimport { ChevronRightIcon } from '@contentful/f36-icons';\nvar Fe = Object.defineProperty,\n  De = Object.defineProperties;\nvar Ae = Object.getOwnPropertyDescriptors;\nvar A = Object.getOwnPropertySymbols;\nvar me = Object.prototype.hasOwnProperty,\n  ae = Object.prototype.propertyIsEnumerable;\nvar ue = (e, t, o) => t in e ? Fe(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: o\n  }) : e[t] = o,\n  u = (e, t) => {\n    for (var o in t || (t = {})) me.call(t, o) && ue(e, o, t[o]);\n    if (A) for (var o of A(t)) ae.call(t, o) && ue(e, o, t[o]);\n    return e;\n  },\n  S = (e, t) => De(e, Ae(t));\nvar y = (e, t) => {\n  var o = {};\n  for (var n in e) me.call(e, n) && t.indexOf(n) < 0 && (o[n] = e[n]);\n  if (e != null && A) for (var n of A(e)) t.indexOf(n) < 0 && ae.call(e, n) && (o[n] = e[n]);\n  return o;\n};\nvar ce = {\n    vertical: {\n      prev: \"ArrowUp\",\n      next: \"ArrowDown\"\n    },\n    horizontal: {\n      prev: \"ArrowLeft\",\n      next: \"ArrowRight\"\n    }\n  },\n  pe = _ref => {\n    let {\n      itemsContainerRef: e,\n      itemsSelector: t,\n      keyType: o = \"vertical\"\n    } = _ref;\n    let [n, i] = useState(0),\n      m = useCallback(s => {\n        let d = e.current;\n        if (!d) return;\n        let x = d.querySelectorAll(t);\n        if (x.length === 0) return;\n        let l = x.length - 1,\n          b = () => i(0),\n          g = () => i(l),\n          p = () => {\n            n === l ? b() : i(n + 1);\n          },\n          T = () => {\n            n === 0 ? g() : i(n - 1);\n          },\n          h = {\n            [ce[o].next]: p,\n            [ce[o].prev]: T\n          }[s.key];\n        h && (s.preventDefault(), h());\n      }, [n, t, e, o]);\n    return {\n      focusedIndex: n,\n      handleArrowsKeyDown: m,\n      setFocusedIndex: i\n    };\n  };\nvar fe = F.createContext(void 0),\n  R = () => {\n    let e = F.useContext(fe);\n    if (e === void 0) throw new Error(\"useMenuContext must be used within a MenuContextProvider\");\n    return e;\n  },\n  de = fe.Provider;\nvar X = '[role=\"menuitem\"]:not(:disabled)';\nfunction W(e) {\n  let oe = e,\n    {\n      closeOnSelect: t = !0,\n      closeOnBlur: o = !0,\n      closeOnEsc: n = !0,\n      children: i,\n      onOpen: m\n    } = oe,\n    s = y(oe, [\"closeOnSelect\", \"closeOnBlur\", \"closeOnEsc\", \"children\", \"onOpen\"]),\n    {\n      isOpen: d,\n      handleOpen: x,\n      handleClose: l,\n      isControlled: b\n    } = useControllableState({\n      isOpen: e.isOpen,\n      defaultIsOpen: e.defaultIsOpen,\n      onOpen: m,\n      onClose: e.onClose\n    }),\n    g = useRef(null),\n    p = useRef(null),\n    T = useId(null, \"menu\"),\n    {\n      focusedIndex: P,\n      handleArrowsKeyDown: h,\n      setFocusedIndex: a\n    } = pe({\n      itemsContainerRef: p,\n      itemsSelector: X\n    });\n  useEffect(() => {\n    if (d && p.current) {\n      let r = p.current.querySelectorAll(X);\n      r.length > 0 && P < r.length && setTimeout(() => {\n        r[P].focus({\n          preventScroll: !1\n        });\n      }, 0);\n    }\n  }, [d, P]);\n  let L = useCallback(r => {\n      let M = [...p.current.querySelectorAll(X)].findIndex(c => r === c);\n      M !== -1 && a(M);\n    }, [a]),\n    f = useCallback(() => {\n      var r;\n      l(), (r = g.current) == null || r.focus({\n        preventScroll: !0\n      });\n    }, [l]),\n    E = useCallback(r => {\n      if (r.key === \"Tab\") {\n        r.preventDefault(), f();\n        return;\n      }\n      if (r.stopPropagation(), r.key === \"ArrowLeft\") {\n        r.preventDefault(), f();\n        return;\n      }\n      h(r);\n    }, [f, h]),\n    U = useRef(!1),\n    He = useMemo(() => ({\n      isOpen: d,\n      menuId: T,\n      focusMenuItem: L,\n      getTriggerProps: function () {\n        let r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let w = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        return {\n          onMouseDown: M => {\n            var c;\n            U.current = !0, (c = r.onMouseDown) == null || c.call(r, M);\n          },\n          onMouseUp: M => {\n            var c;\n            U.current = !1, (c = r.onMouseUp) == null || c.call(r, M);\n          },\n          onClick: M => {\n            var D;\n            b && !m || (d ? l() : x()), (D = r.onClick) == null || D.call(r, M);\n          },\n          ref: mergeRefs(g, w)\n        };\n      },\n      getMenuListProps: function () {\n        let r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let w = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        return {\n          ref: mergeRefs(p, w),\n          onKeyDown: M => {\n            var c;\n            E(M), (c = r.onKeyDown) == null || c.call(r, M);\n          },\n          onBlur: M => {\n            var ne, re, se, ie;\n            if ((ne = r.onBlur) == null || ne.call(r, M), !o) return;\n            let c = M.relatedTarget,\n              D = p.current === c || ((re = p.current) == null ? void 0 : re.contains(c)),\n              Ne = g.current === c || ((se = g.current) == null ? void 0 : se.contains(c)) || U.current,\n              ke = ((ie = c == null ? void 0 : c.parentElement) == null ? void 0 : ie.dataset.parentMenu) === T;\n            if (D || Ne || ke) {\n              M.stopPropagation();\n              return;\n            }\n            l();\n          }\n        };\n      },\n      getMenuItemProps: function () {\n        let r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return {\n          onClick: w => {\n            var c;\n            (c = r.onClick) == null || c.call(r, w);\n            let M = Boolean(w.target.getAttribute(\"aria-haspopup\"));\n            t && !M && f();\n          }\n        };\n      },\n      propsToPropagateToSubmenus: {\n        closeOnSelect: t,\n        closeOnBlur: o,\n        closeOnEsc: n\n      }\n    }), [T, d, E, t, l, x, L, o, n, f, b, m]);\n  return F.createElement(de, {\n    value: He\n  }, F.createElement(Popover, S(u({}, s), {\n    isOpen: d,\n    onClose: l,\n    id: T,\n    closeOnEsc: n,\n    autoFocus: !1,\n    closeOnBlur: !1\n  }), i));\n}\nvar ye = F.createContext(void 0),\n  B = () => F.useContext(ye),\n  xe = ye.Provider;\nvar Te = () => css({\n    position: \"sticky\",\n    top: 0,\n    left: 0,\n    backgroundColor: C.colorWhite,\n    borderBottom: `1px solid ${C.gray300}`,\n    padding: `${C.spacingXs} 0`,\n    zIndex: 1001\n  }),\n  be = () => css({\n    position: \"sticky\",\n    bottom: 0,\n    left: 0,\n    backgroundColor: C.colorWhite,\n    borderTop: `1px solid ${C.gray300}`,\n    padding: `${C.spacingXs} 0`,\n    zIndex: 1001\n  }),\n  he = e => ({\n    container: css({\n      overflowY: \"auto\",\n      position: \"relative\",\n      padding: 0,\n      paddingTop: e.hasStickyHeader ? 0 : C.spacingXs,\n      paddingBottom: e.hasStickyFooter ? 0 : C.spacingXs\n    })\n  });\nvar O = e => {\n  let s = e,\n    {\n      children: t,\n      testId: o = \"cf-ui-menu-list-header\",\n      className: n\n    } = s,\n    i = y(s, [\"children\", \"testId\", \"className\"]),\n    m = Te();\n  return F.createElement(\"div\", u({\n    \"data-test-id\": o,\n    className: cx(m, n)\n  }, i), t);\n};\nO.displayName = \"MenuListHeader\";\nvar H = e => {\n  let s = e,\n    {\n      children: t,\n      testId: o = \"cf-ui-menu-list-footer\",\n      className: n\n    } = s,\n    i = y(s, [\"children\", \"testId\", \"className\"]),\n    m = be();\n  return F.createElement(\"div\", u({\n    \"data-test-id\": o,\n    className: cx(m, n)\n  }, i), t);\n};\nH.displayName = \"MenuListFooter\";\nfunction Qe(e) {\n  var t;\n  return Boolean((t = e == null ? void 0 : e.type) == null ? void 0 : t.displayName);\n}\nvar Ze = (e, t) => {\n    let T = e,\n      {\n        children: o,\n        testId: n = \"cf-ui-menu-list\",\n        className: i\n      } = T,\n      m = y(T, [\"children\", \"testId\", \"className\"]),\n      {\n        getMenuListProps: s\n      } = R(),\n      d = B(),\n      x = null,\n      l = null,\n      b = [];\n    F.Children.forEach(o, P => {\n      let h = !0;\n      Qe(P) && (P.type.displayName === O.displayName ? (x = P, h = !1) : P.type.displayName === H.displayName && (l = P, h = !1)), h && b.push(P);\n    });\n    let g = he({\n        hasStickyHeader: Boolean(x),\n        hasStickyFooter: Boolean(l)\n      }),\n      p = d ? d.getSubmenuListProps(m) : m;\n    return F.createElement(Popover.Content, S(u(u({\n      role: \"menu\"\n    }, p), s(p, t)), {\n      className: cx(g.container, i),\n      testId: n\n    }), x, b, l);\n  },\n  q = F.forwardRef(Ze);\nvar Se = () => ({\n  root: css({\n    display: \"block\",\n    width: \"100%\",\n    background: \"none\",\n    border: 0,\n    margin: 0,\n    outline: \"none\",\n    fontSize: C.fontSizeM,\n    lineHeight: C.lineHeightM,\n    fontWeight: C.fontWeightNormal,\n    position: \"relative\",\n    textAlign: \"left\",\n    padding: `${C.spacingXs} ${C.spacingM}`,\n    wordBreak: \"break-word\",\n    whiteSpace: \"break-spaces\",\n    cursor: \"pointer\",\n    hyphens: \"auto\",\n    minWidth: \"150px\",\n    textDecoration: \"none\",\n    color: C.gray800,\n    \"&:hover\": {\n      backgroundColor: C.gray100\n    },\n    \"&:focus\": {\n      boxShadow: `inset ${C.glowPrimary}`,\n      borderRadius: C.borderRadiusMedium\n    },\n    \"&:focus:not(:focus-visible)\": {\n      boxShadow: \"unset\",\n      borderRadius: \"unset\"\n    },\n    \"&:focus-visible\": {\n      boxShadow: `inset ${C.glowPrimary}`,\n      borderRadius: C.borderRadiusMedium\n    },\n    \"&:active\": {\n      backgroundColor: C.gray200\n    },\n    \"&:disabled\": {\n      opacity: .5,\n      cursor: \"auto\"\n    }\n  })\n});\nvar st = \"button\";\nfunction Ee(e, t) {\n  let P = e,\n    {\n      testId: o,\n      className: n,\n      as: i,\n      isInitiallyFocused: m\n    } = P,\n    s = y(P, [\"testId\", \"className\", \"as\", \"isInitiallyFocused\"]),\n    d = useId(void 0, \"menu-item\"),\n    x = o || `cf-ui-${d}`,\n    l = Se(),\n    {\n      getMenuItemProps: b,\n      focusMenuItem: g\n    } = R(),\n    p = useRef(null);\n  useEffect(() => {\n    m && p.current && g(p.current);\n  }, [m, g]);\n  let T = i != null ? i : st;\n  return F.createElement(T, S(u(u({\n    role: \"menuitem\"\n  }, s), b(s)), {\n    className: cx(l.root, n),\n    \"data-test-id\": x,\n    ref: mergeRefs(p, t),\n    tabIndex: -1\n  }), e.children);\n}\nEe.displayName = \"MenuItem\";\nvar N = F.forwardRef(Ee);\nvar k = e => {\n  let t = F.Children.only(e.children),\n    {\n      getTriggerProps: o\n    } = R();\n  return F.createElement(Popover.Trigger, null, F.cloneElement(t, S(u({}, o(t.props, t.ref)), {\n    [\"aria-haspopup\"]: \"menu\"\n  })));\n};\nvar Le = () => css({\n  border: \"none\",\n  width: \"100%\",\n  height: \"1px\",\n  background: C.gray300,\n  margin: `${C.spacingXs} 0`\n});\nvar j = e => {\n  let s = e,\n    {\n      children: t,\n      testId: o = \"cf-ui-menu-divider\",\n      className: n\n    } = s,\n    i = y(s, [\"children\", \"testId\", \"className\"]),\n    m = Le();\n  return F.createElement(\"hr\", u({\n    \"aria-orientation\": \"horizontal\",\n    \"data-test-id\": o,\n    className: cx(m, n)\n  }, i));\n};\nvar Re = () => css({\n  textAlign: \"left\",\n  padding: `${C.spacingXs} ${C.spacingM}`,\n  lineHeight: C.lineHeightM,\n  \"hr + &\": {\n    marginTop: \"-8px\"\n  }\n});\nvar J = e => {\n  let s = e,\n    {\n      children: t,\n      testId: o = \"cf-ui-menu-section-title\",\n      className: n\n    } = s,\n    i = y(s, [\"children\", \"testId\", \"className\"]),\n    m = Re();\n  return F.createElement(SectionHeading, u({\n    \"aria-hidden\": \"true\",\n    testId: o,\n    className: cx(m, n),\n    marginBottom: \"none\"\n  }, i), t);\n};\nvar yt = [-8, 2],\n  Z = e => {\n    let h = e,\n      {\n        onClose: t,\n        onOpen: o\n      } = h,\n      n = y(h, [\"onClose\", \"onOpen\"]),\n      {\n        isOpen: i,\n        menuId: m,\n        propsToPropagateToSubmenus: s\n      } = R(),\n      d = useRef(null),\n      x = useRef(null),\n      [l, b] = useState(!1),\n      g = useCallback(() => {\n        b(!0), window.clearTimeout(x.current), o == null || o();\n      }, [o]),\n      p = useCallback(() => {\n        b(!1), window.clearTimeout(x.current), t == null || t();\n      }, [t]),\n      T = useCallback(() => {\n        var a;\n        p(), (a = d.current) == null || a.focus({\n          preventScroll: !0\n        });\n      }, [p]);\n    useEffect(() => {\n      i === !1 && b(!1);\n    }, [i]);\n    let P = useMemo(() => ({\n      isOpen: l,\n      getSubmenuListProps: a => ({\n        \"data-parent-menu\": m,\n        onMouseOver: L => {\n          var f;\n          g(), (f = a.onMouseOver) == null || f.call(a, L);\n        },\n        onMouseLeave: L => {\n          var f;\n          T(), (f = a.onMouseLeave) == null || f.call(a, L);\n        }\n      }),\n      getSubmenuTriggerProps: (a, L) => ({\n        ref: mergeRefs(d, L),\n        onKeyDown: f => {\n          var E;\n          f.key === \"ArrowRight\" && (f.preventDefault(), g()), (E = a.onKeyDown) == null || E.call(a, f);\n        },\n        onMouseOver: f => {\n          var E;\n          g(), (E = a.onMouseOver) == null || E.call(a, f);\n        },\n        onMouseLeave: f => {\n          var E;\n          x.current = window.setTimeout(T, 300), (E = a.onMouseLeave) == null || E.call(a, f);\n        }\n      })\n    }), [l, m, g, T]);\n    return F.createElement(xe, {\n      value: P\n    }, F.createElement(W, S(u(u({}, s), n), {\n      isOpen: l,\n      onClose: p,\n      onOpen: g,\n      placement: \"right-start\",\n      offset: yt,\n      isAutoalignmentEnabled: !1\n    })));\n  };\nvar Oe = () => ({\n  root: _ref2 => {\n    let {\n      isActive: e\n    } = _ref2;\n    return css(u({\n      display: \"flex\",\n      alignItems: \"center\",\n      paddingRight: C.spacingXs\n    }, e ? {\n      backgroundColor: C.gray100\n    } : {}));\n  },\n  content: css({\n    marginRight: C.spacingM\n  }),\n  icon: css({\n    marginLeft: \"auto\",\n    fill: \"currentColor\"\n  })\n});\nvar bt = (e, t) => {\n    let {\n        className: o,\n        children: n\n      } = e,\n      {\n        getSubmenuTriggerProps: i,\n        isOpen: m\n      } = B(),\n      s = Oe();\n    return F.createElement(k, null, F.createElement(N, S(u(u({}, e), i(e, t)), {\n      className: cx(s.root({\n        isActive: m\n      }), o)\n    }), F.createElement(\"span\", {\n      className: s.content\n    }, n), F.createElement(ChevronRightIcon, {\n      className: s.icon\n    })));\n  },\n  te = F.forwardRef(bt);\nvar I = W;\nI.List = q;\nI.ListHeader = O;\nI.ListFooter = H;\nI.Item = N;\nI.Trigger = k;\nI.Divider = j;\nI.SectionTitle = J;\nI.Submenu = Z;\nI.SubmenuTrigger = te;\nexport { I as Menu, j as MenuDivider, N as MenuItem, q as MenuList, J as MenuSectionTitle, k as MenuTrigger, Z as Submenu, te as SubmenuTrigger };","map":{"version":3,"names":[],"sources":["/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/Menu.tsx","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/useArrowKeyNavigation.ts","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/MenuContext.ts","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/MenuList/MenuList.tsx","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/SubmenuContext.ts","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/MenuList/MenuList.styles.ts","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/MenuList/MenuListHeader.tsx","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/MenuList/MenuListFooter.tsx","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/MenuItem/MenuItem.tsx","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/MenuItem/MenuItem.styles.ts","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/MenuTrigger/MenuTrigger.tsx","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/MenuDivider/MenuDivider.tsx","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/MenuDivider/MenuDivider.styles.ts","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/MenuSectionTitle/MenuSectionTitle.tsx","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/MenuSectionTitle/MenuSectionTitle.styles.ts","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/Submenu/Submenu.tsx","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/SubmenuTrigger/SubmenuTrigger.tsx","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/SubmenuTrigger/SubmenuTrigger.styles.ts","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-menu/src/CompoundMenu.tsx"],"sourcesContent":["import React, { useCallback, useMemo, useRef, useEffect } from 'react';\nimport { mergeRefs, useId, useControllableState } from '@contentful/f36-core';\nimport { Popover, type PopoverProps } from '@contentful/f36-popover';\n\nimport { useArrowKeyNavigation } from './useArrowKeyNavigation';\nimport { MenuContextProvider, MenuContextType } from './MenuContext';\n\nconst MENU_ITEMS_SELECTOR = '[role=\"menuitem\"]:not(:disabled)';\n\nexport interface MenuProps\n  extends Omit<PopoverProps, 'autoFocus' | 'id' | 'closeOnBlur'> {\n  /**\n   * By default, the Menu is uncontrolled (manage it's expanded state by itself)\n   * But you can make it controlled by providing boolean (true/false)\n   */\n  isOpen?: boolean;\n\n  /**\n   * If `true`, the Menu will be initially opened.\n   */\n  defaultIsOpen?: boolean;\n\n  /**\n   * Callback fired when the Menu opens\n   */\n  onOpen?: () => void;\n\n  /**\n   * Callback fired when the Menu closes\n   */\n  onClose?: () => void;\n\n  /**\n   * If `true`, the Menu will close when a menu item is\n   * clicked\n   *\n   * Note: This prop will be propagated to all submenus,\n   * unless you will override it with props on submenu itself\n   *\n   * @default true\n   */\n  closeOnSelect?: boolean;\n\n  /**\n   * If true, the menu will close when you blur out it by clicking outside\n   *\n   * Note: This prop will be propagated to all submenus,\n   * unless you will override it with props on submenu itself\n   *\n   * @default true\n   */\n  closeOnBlur?: boolean;\n\n  /**\n   * If true, the menu will close when you hit the Esc key\n   *\n   * Note: This prop will be propagated to all submenus,\n   * unless you will override it with props on submenu itself\n   *\n   * @default true\n   */\n  closeOnEsc?: boolean;\n}\n\nexport function Menu(props: MenuProps) {\n  const {\n    closeOnSelect = true,\n    closeOnBlur = true,\n    closeOnEsc = true,\n    children,\n    onOpen,\n    ...otherProps\n  } = props;\n  const { isOpen, handleOpen, handleClose, isControlled } =\n    useControllableState({\n      isOpen: props.isOpen,\n      defaultIsOpen: props.defaultIsOpen,\n      onOpen,\n      onClose: props.onClose,\n    });\n\n  const triggerRef = useRef<HTMLButtonElement>(null);\n  const menuListRef = useRef<HTMLDivElement>(null);\n\n  const menuId = useId(null, 'menu');\n\n  const { focusedIndex, handleArrowsKeyDown, setFocusedIndex } =\n    useArrowKeyNavigation({\n      itemsContainerRef: menuListRef,\n      itemsSelector: MENU_ITEMS_SELECTOR,\n    });\n\n  useEffect(() => {\n    if (isOpen && menuListRef.current) {\n      const menuItems =\n        menuListRef.current.querySelectorAll(MENU_ITEMS_SELECTOR);\n\n      if (menuItems.length > 0 && focusedIndex < menuItems.length) {\n        // timeout trick to prevent scroll from jumping\n        // when the popover is not positioned correctly yet in the opening phase\n        setTimeout(() => {\n          (menuItems[focusedIndex] as HTMLElement).focus({\n            preventScroll: false,\n          });\n        }, 0);\n      }\n    }\n  }, [isOpen, focusedIndex]);\n\n  const focusMenuItem = useCallback(\n    (item: HTMLElement) => {\n      const menuItems =\n        menuListRef.current.querySelectorAll(MENU_ITEMS_SELECTOR);\n\n      const itemIndex = [...menuItems].findIndex(\n        (menuItem) => item === menuItem,\n      );\n\n      if (itemIndex !== -1) {\n        setFocusedIndex(itemIndex);\n      }\n    },\n    [setFocusedIndex],\n  );\n\n  const closeAndFocusTrigger = useCallback(() => {\n    handleClose();\n    triggerRef.current?.focus({ preventScroll: true });\n  }, [handleClose]);\n\n  const handleMenuListKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      if (event.key === 'Tab') {\n        event.preventDefault();\n        closeAndFocusTrigger();\n        return;\n      }\n\n      // we don't want to propagate other keydown events except `Tab`\n      event.stopPropagation();\n\n      if (event.key === 'ArrowLeft') {\n        event.preventDefault();\n        closeAndFocusTrigger();\n        return;\n      }\n\n      handleArrowsKeyDown(event);\n    },\n    [closeAndFocusTrigger, handleArrowsKeyDown],\n  );\n\n  // Safari has an issue with the relatedTarget that we use on the onBlur for menuListProps,\n  // which was causing the menu to close and reopen when clicking on the trigger.\n  // We will use the isMouseDown to prevent triggering blur in the cases where the user clicks on the trigger.\n  const isMouseDown = useRef<Boolean>(false);\n\n  const contextValue: MenuContextType = useMemo(\n    () => ({\n      isOpen,\n      menuId,\n      focusMenuItem,\n      getTriggerProps: (_props = {}, _ref = null) => ({\n        onMouseDown: (event) => {\n          isMouseDown.current = true;\n          _props.onMouseDown?.(event);\n        },\n        onMouseUp: (event) => {\n          isMouseDown.current = false;\n          _props.onMouseUp?.(event);\n        },\n        onClick: (event) => {\n          // if the user made component controlled by providing isOpen prop\n          // but onOpen callback is not provided, we won't add toggle logic\n          // to the trigger component. So they can make any toggle logic on their own.\n          const isFullyControlled = isControlled && !onOpen;\n\n          if (!isFullyControlled) {\n            if (isOpen) {\n              handleClose();\n            } else {\n              handleOpen();\n            }\n          }\n\n          _props.onClick?.(event);\n        },\n        ref: mergeRefs(triggerRef, _ref),\n      }),\n      getMenuListProps: (_props = {}, _ref = null) => ({\n        ref: mergeRefs(menuListRef, _ref),\n        onKeyDown: (event) => {\n          handleMenuListKeyDown(event);\n          _props.onKeyDown?.(event);\n        },\n        onBlur: (event) => {\n          _props.onBlur?.(event);\n\n          if (!closeOnBlur) {\n            return;\n          }\n\n          const relatedTarget = event.relatedTarget as Node;\n\n          const targetIsMenu =\n            menuListRef.current === relatedTarget ||\n            menuListRef.current?.contains(relatedTarget);\n          const targetIsTrigger =\n            triggerRef.current === relatedTarget ||\n            triggerRef.current?.contains(relatedTarget) ||\n            isMouseDown.current;\n          const targetIsSubmenu =\n            relatedTarget?.parentElement?.dataset.parentMenu === menuId;\n\n          if (targetIsMenu || targetIsTrigger || targetIsSubmenu) {\n            event.stopPropagation();\n            return;\n          }\n\n          handleClose();\n        },\n      }),\n      getMenuItemProps: (_props = {}) => ({\n        onClick: (event) => {\n          _props.onClick?.(event);\n\n          const isSubmenuTrigger = Boolean(\n            (event.target as HTMLElement).getAttribute('aria-haspopup'),\n          );\n          if (closeOnSelect && !isSubmenuTrigger) {\n            closeAndFocusTrigger();\n          }\n        },\n      }),\n      propsToPropagateToSubmenus: {\n        closeOnSelect,\n        closeOnBlur,\n        closeOnEsc,\n      },\n    }),\n    [\n      menuId,\n      isOpen,\n      handleMenuListKeyDown,\n      closeOnSelect,\n      handleClose,\n      handleOpen,\n      focusMenuItem,\n      closeOnBlur,\n      closeOnEsc,\n      closeAndFocusTrigger,\n      isControlled,\n      onOpen,\n    ],\n  );\n\n  return (\n    <MenuContextProvider value={contextValue}>\n      <Popover\n        {...otherProps}\n        isOpen={isOpen}\n        onClose={handleClose}\n        id={menuId}\n        closeOnEsc={closeOnEsc}\n        // eslint-disable-next-line jsx-a11y/no-autofocus\n        autoFocus={false}\n        closeOnBlur={false}\n      >\n        {children}\n      </Popover>\n    </MenuContextProvider>\n  );\n}\n","import { useState, useCallback } from 'react';\n\ninterface UseArrowKeyNavigationProps {\n  itemsContainerRef: React.MutableRefObject<HTMLElement>;\n  itemsSelector: string;\n  keyType?: 'vertical' | 'horizontal';\n  initialFocusedIndex?: number;\n}\n\nconst ARROW_KEY_TYPES = {\n  vertical: {\n    prev: 'ArrowUp',\n    next: 'ArrowDown',\n  },\n  horizontal: {\n    prev: 'ArrowLeft',\n    next: 'ArrowRight',\n  },\n};\n\nexport const useArrowKeyNavigation = ({\n  itemsContainerRef,\n  itemsSelector,\n  keyType = 'vertical',\n}: UseArrowKeyNavigationProps) => {\n  const [focusedIndex, setFocusedIndex] = useState<number>(0);\n\n  const handleArrowsKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const container = itemsContainerRef.current;\n      if (!container) return;\n\n      const items = container.querySelectorAll(itemsSelector);\n      if (items.length === 0) return;\n\n      const lastItemIndex = items.length - 1;\n\n      const focusFirstItem = () => setFocusedIndex(0);\n      const focusLastItem = () => setFocusedIndex(lastItemIndex);\n      const focusNextItem = () => {\n        if (focusedIndex === lastItemIndex) {\n          focusFirstItem();\n        } else {\n          setFocusedIndex(focusedIndex + 1);\n        }\n      };\n      const focusPrevItem = () => {\n        if (focusedIndex === 0) {\n          focusLastItem();\n        } else {\n          setFocusedIndex(focusedIndex - 1);\n        }\n      };\n\n      const keyToFnMap = {\n        [ARROW_KEY_TYPES[keyType].next]: focusNextItem,\n        [ARROW_KEY_TYPES[keyType].prev]: focusPrevItem,\n      };\n\n      const fn = keyToFnMap[event.key];\n      if (fn) {\n        event.preventDefault();\n        fn();\n      }\n    },\n    [focusedIndex, itemsSelector, itemsContainerRef, keyType],\n  );\n\n  return { focusedIndex, handleArrowsKeyDown, setFocusedIndex };\n};\n","import React, { ComponentPropsWithRef } from 'react';\nimport { MenuProps } from '.';\n\nexport type MenuContextType = {\n  isOpen: boolean;\n  menuId: string;\n  focusMenuItem: (item: HTMLElement) => void;\n  getTriggerProps: (\n    _props: ComponentPropsWithRef<'button'>,\n    _ref: React.Ref<HTMLButtonElement>,\n  ) => ComponentPropsWithRef<'button'>;\n  getMenuListProps: (\n    _props: ComponentPropsWithRef<'div'>,\n    _ref: React.Ref<HTMLDivElement>,\n  ) => ComponentPropsWithRef<'div'>;\n  getMenuItemProps: (\n    _props: ComponentPropsWithRef<'button'>,\n  ) => ComponentPropsWithRef<'button'>;\n  propsToPropagateToSubmenus: Pick<\n    MenuProps,\n    'closeOnBlur' | 'closeOnEsc' | 'closeOnSelect'\n  >;\n};\n\nconst MenuContext = React.createContext<MenuContextType | undefined>(undefined);\n\nexport const useMenuContext = () => {\n  const context = React.useContext(MenuContext);\n\n  if (context === undefined) {\n    throw new Error('useMenuContext must be used within a MenuContextProvider');\n  }\n\n  return context;\n};\n\nexport const MenuContextProvider = MenuContext.Provider;\n","import React from 'react';\nimport type {\n  CommonProps,\n  PropsWithHTMLElement,\n  ExpandProps,\n} from '@contentful/f36-core';\nimport { useMenuContext } from '../MenuContext';\nimport { useSubmenuContext } from '../SubmenuContext';\nimport { Popover } from '@contentful/f36-popover';\nimport { cx } from 'emotion';\nimport { getMenuListStyles } from './MenuList.styles';\nimport { MenuListHeader } from './MenuListHeader';\nimport { MenuListFooter } from './MenuListFooter';\n\ninterface MenuListInternalProps extends CommonProps {\n  children?: React.ReactNode;\n}\n\nfunction assertChild(child: any): child is { type: { displayName: string } } {\n  return Boolean(child?.type?.displayName);\n}\n\nexport type MenuListProps = PropsWithHTMLElement<MenuListInternalProps, 'div'>;\n\nconst _MenuList = (\n  props: ExpandProps<MenuListProps>,\n  ref: React.Ref<HTMLDivElement>,\n) => {\n  const {\n    children,\n    testId = 'cf-ui-menu-list',\n    className,\n    ...otherProps\n  } = props;\n\n  const { getMenuListProps } = useMenuContext();\n  const submenuContext = useSubmenuContext();\n\n  let header: React.ReactElement | null = null;\n  let footer: React.ReactElement | null = null;\n  const items: React.ReactElement[] = [];\n\n  React.Children.forEach(children, (child) => {\n    let appendChild = true;\n    if (assertChild(child)) {\n      if (child.type.displayName === MenuListHeader.displayName) {\n        header = child as unknown as React.ReactElement;\n        appendChild = false;\n      } else if (child.type.displayName === MenuListFooter.displayName) {\n        footer = child as unknown as React.ReactElement;\n        appendChild = false;\n      }\n    }\n    if (appendChild) {\n      items.push(child as unknown as React.ReactElement);\n    }\n  });\n\n  const styles = getMenuListStyles({\n    hasStickyHeader: Boolean(header),\n    hasStickyFooter: Boolean(footer),\n  });\n\n  const extendedOtherProps = submenuContext\n    ? submenuContext.getSubmenuListProps(otherProps)\n    : otherProps;\n\n  return (\n    <Popover.Content\n      role=\"menu\"\n      {...extendedOtherProps}\n      {...getMenuListProps(extendedOtherProps, ref)}\n      className={cx(styles.container, className)}\n      testId={testId}\n    >\n      {header}\n      {items}\n      {footer}\n    </Popover.Content>\n  );\n};\n\nexport const MenuList = React.forwardRef(_MenuList);\n","import React, { ComponentPropsWithRef, ComponentPropsWithoutRef } from 'react';\n\nexport type SubmenuContextType = {\n  isOpen: boolean;\n  getSubmenuListProps: (\n    _props: ComponentPropsWithRef<'div'>,\n  ) => { 'data-parent-menu': string } & ComponentPropsWithoutRef<'div'>;\n  getSubmenuTriggerProps: (\n    _props: ComponentPropsWithRef<'button'>,\n    _ref: React.Ref<HTMLButtonElement>,\n  ) => ComponentPropsWithRef<'button'>;\n};\n\nconst SubmenuContext = React.createContext<SubmenuContextType | undefined>(\n  undefined,\n);\n\nexport const useSubmenuContext = () => {\n  const context = React.useContext(SubmenuContext);\n  return context;\n};\n\nexport const SubmenuContextProvider = SubmenuContext.Provider;\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\n\nexport const getMenuHeaderStyles = () => {\n  return css({\n    position: 'sticky',\n    top: 0,\n    left: 0,\n    backgroundColor: tokens.colorWhite,\n    borderBottom: `1px solid ${tokens.gray300}`,\n    padding: `${tokens.spacingXs} 0`,\n    zIndex: 1001,\n  });\n};\n\nexport const getMenuFooterStyles = () => {\n  return css({\n    position: 'sticky',\n    bottom: 0,\n    left: 0,\n    backgroundColor: tokens.colorWhite,\n    borderTop: `1px solid ${tokens.gray300}`,\n    padding: `${tokens.spacingXs} 0`,\n    zIndex: 1001,\n  });\n};\n\nexport const getMenuListStyles = (props: {\n  hasStickyFooter?: boolean;\n  hasStickyHeader?: boolean;\n}) => ({\n  container: css({\n    overflowY: 'auto',\n    position: 'relative',\n    padding: 0,\n    paddingTop: props.hasStickyHeader ? 0 : tokens.spacingXs,\n    paddingBottom: props.hasStickyFooter ? 0 : tokens.spacingXs,\n  }),\n});\n","import React from 'react';\nimport { cx } from 'emotion';\nimport type {\n  CommonProps,\n  PropsWithHTMLElement,\n  ExpandProps,\n} from '@contentful/f36-core';\n\nimport { getMenuHeaderStyles } from './MenuList.styles';\n\nexport type MenuListHeaderProps = PropsWithHTMLElement<CommonProps, 'div'>;\n\nexport const MenuListHeader: React.FC<ExpandProps<MenuListHeaderProps>> = (\n  props,\n) => {\n  const {\n    children,\n    testId = 'cf-ui-menu-list-header',\n    className,\n    ...otherProps\n  } = props;\n\n  const styles = getMenuHeaderStyles();\n\n  return (\n    <div\n      data-test-id={testId}\n      className={cx(styles, className)}\n      {...otherProps}\n    >\n      {children}\n    </div>\n  );\n};\n\nMenuListHeader.displayName = 'MenuListHeader';\n","import React from 'react';\nimport { cx } from 'emotion';\nimport type {\n  CommonProps,\n  PropsWithHTMLElement,\n  ExpandProps,\n} from '@contentful/f36-core';\n\nimport { getMenuFooterStyles } from './MenuList.styles';\n\nexport type MenuListFooterProps = PropsWithHTMLElement<CommonProps, 'div'>;\n\nexport const MenuListFooter: React.FC<ExpandProps<MenuListFooterProps>> = (\n  props,\n) => {\n  const {\n    children,\n    testId = 'cf-ui-menu-list-footer',\n    className,\n    ...otherProps\n  } = props;\n\n  const styles = getMenuFooterStyles();\n\n  return (\n    <div\n      data-test-id={testId}\n      className={cx(styles, className)}\n      {...otherProps}\n    >\n      {children}\n    </div>\n  );\n};\n\nMenuListFooter.displayName = 'MenuListFooter';\n","import React, { useEffect, useRef } from 'react';\nimport { cx } from 'emotion';\nimport {\n  mergeRefs,\n  useId,\n  type CommonProps,\n  type PolymorphicComponent,\n  type PolymorphicProps,\n  type ExpandProps,\n} from '@contentful/f36-core';\n\nimport { useMenuContext } from '../MenuContext';\nimport { getMenuItemStyles } from './MenuItem.styles';\n\nconst MENU_ITEM_DEFAULT_TAG = 'button';\n\ninterface MenuItemInternalProps extends CommonProps {\n  children?: React.ReactNode;\n  as?: 'a' | 'button';\n\n  /**\n   * Sets focus on item\n   */\n  isInitiallyFocused?: boolean;\n}\n\nexport type MenuItemProps<\n  E extends React.ElementType = typeof MENU_ITEM_DEFAULT_TAG,\n> = PolymorphicProps<MenuItemInternalProps, E>;\n\nfunction _MenuItem<E extends React.ElementType = typeof MENU_ITEM_DEFAULT_TAG>(\n  props: MenuItemProps<E>,\n  ref: React.Ref<any>,\n) {\n  const { testId, className, as, isInitiallyFocused, ...otherProps } = props;\n\n  const id = useId(undefined, 'menu-item');\n  const itemTestId = testId || `cf-ui-${id}`;\n  const styles = getMenuItemStyles();\n\n  const { getMenuItemProps, focusMenuItem } = useMenuContext();\n\n  const itemRef = useRef<HTMLElement>(null);\n  useEffect(() => {\n    if (isInitiallyFocused && itemRef.current) {\n      focusMenuItem(itemRef.current);\n    }\n  }, [isInitiallyFocused, focusMenuItem]);\n\n  const Element = (as ?? MENU_ITEM_DEFAULT_TAG) as React.ElementType;\n\n  return (\n    <Element\n      role=\"menuitem\"\n      {...otherProps}\n      {...getMenuItemProps(otherProps)}\n      className={cx(styles.root, className)}\n      data-test-id={itemTestId}\n      ref={mergeRefs(itemRef, ref)}\n      tabIndex={-1}\n    >\n      {props.children}\n    </Element>\n  );\n}\n\n_MenuItem.displayName = 'MenuItem';\n\nexport const MenuItem: PolymorphicComponent<\n  ExpandProps<MenuItemInternalProps>,\n  typeof MENU_ITEM_DEFAULT_TAG\n> = React.forwardRef(_MenuItem);\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\n\nexport const getMenuItemStyles = () => {\n  return {\n    root: css({\n      display: 'block',\n      width: '100%',\n      background: 'none',\n      border: 0,\n      margin: 0,\n      outline: 'none',\n      fontSize: tokens.fontSizeM,\n      lineHeight: tokens.lineHeightM,\n      fontWeight: tokens.fontWeightNormal,\n      position: 'relative',\n      textAlign: 'left',\n      padding: `${tokens.spacingXs} ${tokens.spacingM}`,\n      wordBreak: 'break-word',\n      whiteSpace: 'break-spaces',\n      cursor: 'pointer',\n      hyphens: 'auto',\n      minWidth: '150px',\n      textDecoration: 'none',\n      color: tokens.gray800,\n\n      '&:hover': {\n        backgroundColor: tokens.gray100,\n      },\n      '&:focus': {\n        boxShadow: `inset ${tokens.glowPrimary}`,\n        // just to make boxShadow with rounded corners\n        borderRadius: tokens.borderRadiusMedium,\n      },\n      '&:focus:not(:focus-visible)': {\n        boxShadow: 'unset',\n        borderRadius: 'unset',\n      },\n      '&:focus-visible': {\n        boxShadow: `inset ${tokens.glowPrimary}`,\n        borderRadius: tokens.borderRadiusMedium,\n      },\n      '&:active': {\n        backgroundColor: tokens.gray200,\n      },\n      '&:disabled': {\n        opacity: 0.5,\n        cursor: 'auto',\n      },\n    }),\n  };\n};\n","import React from 'react';\nimport { Popover } from '@contentful/f36-popover';\nimport { useMenuContext } from '../MenuContext';\nimport type { ExpandProps } from '@contentful/f36-core';\n\nexport interface MenuTriggerProps {\n  children: React.ReactNode;\n}\n\nexport const MenuTrigger = (props: ExpandProps<MenuTriggerProps>) => {\n  const child = React.Children.only(props.children) as any;\n  const { getTriggerProps } = useMenuContext();\n\n  return (\n    <Popover.Trigger>\n      {React.cloneElement(child, {\n        ...getTriggerProps(child.props, child.ref),\n        ['aria-haspopup']: 'menu',\n      })}\n    </Popover.Trigger>\n  );\n};\n","import React from 'react';\nimport type {\n  CommonProps,\n  PropsWithHTMLElement,\n  ExpandProps,\n} from '@contentful/f36-core';\nimport { cx } from 'emotion';\nimport { getMenuDividerStyles } from './MenuDivider.styles';\n\nexport type MenuDividerProps = PropsWithHTMLElement<CommonProps, 'hr'>;\n\nexport const MenuDivider = (props: ExpandProps<MenuDividerProps>) => {\n  const {\n    children,\n    testId = 'cf-ui-menu-divider',\n    className,\n    ...otherProps\n  } = props;\n\n  const styles = getMenuDividerStyles();\n\n  return (\n    <hr\n      aria-orientation=\"horizontal\"\n      data-test-id={testId}\n      className={cx(styles, className)}\n      {...otherProps}\n    />\n  );\n};\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\n\nexport const getMenuDividerStyles = () =>\n  css({\n    border: 'none',\n    width: '100%',\n    height: '1px',\n    background: tokens.gray300,\n    margin: `${tokens.spacingXs} 0`,\n  });\n","import React from 'react';\nimport { cx } from 'emotion';\nimport {\n  SectionHeading,\n  type SectionHeadingProps,\n} from '@contentful/f36-typography';\nimport type { ExpandProps } from '@contentful/f36-core';\n\nimport { getMenuSectionTitleStyles } from './MenuSectionTitle.styles';\n\nexport type MenuSectionTitleProps = SectionHeadingProps;\n\nexport const MenuSectionTitle = (props: ExpandProps<MenuSectionTitleProps>) => {\n  const {\n    children,\n    testId = 'cf-ui-menu-section-title',\n    className,\n    ...otherProps\n  } = props;\n\n  const styles = getMenuSectionTitleStyles();\n\n  return (\n    <SectionHeading\n      // Techincally, menus cannot contain headings according to ARIA.\n      // We hide the heading from assistive technology, and only use it\n      // as a label\n      aria-hidden=\"true\"\n      testId={testId}\n      className={cx(styles, className)}\n      marginBottom=\"none\"\n      {...otherProps}\n    >\n      {children}\n    </SectionHeading>\n  );\n};\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\n\nexport const getMenuSectionTitleStyles = () =>\n  css({\n    textAlign: 'left',\n    padding: `${tokens.spacingXs} ${tokens.spacingM}`,\n    lineHeight: tokens.lineHeightM,\n\n    'hr + &': {\n      marginTop: '-8px',\n    },\n  });\n","import React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { Menu, MenuProps } from '../Menu';\nimport { useMenuContext } from '../MenuContext';\nimport { SubmenuContextProvider, SubmenuContextType } from '../SubmenuContext';\nimport { mergeRefs } from '@contentful/f36-core';\n\nconst SUBMENU_OFFSET: [number, number] = [-8, 2];\n\nexport type SubmenuProps = Omit<\n  MenuProps,\n  | 'placement'\n  | 'offset'\n  | 'usePortal'\n  | 'isOpen'\n  | 'isAutoalignmentEnabled'\n  | 'defaultIsOpen'\n>;\n\nexport const Submenu = (props: SubmenuProps) => {\n  const { onClose, onOpen, ...otherProps } = props;\n\n  const {\n    isOpen: isParentMenuOpen,\n    menuId,\n    propsToPropagateToSubmenus,\n  } = useMenuContext();\n\n  const triggerRef = useRef<HTMLButtonElement>(null);\n  const mouseLeaveTimerRef = useRef(null);\n\n  const [isOpen, setIsOpen] = useState(false);\n  const handleOpen = useCallback(() => {\n    setIsOpen(true);\n    window.clearTimeout(mouseLeaveTimerRef.current);\n\n    onOpen?.();\n  }, [onOpen]);\n  const handleClose = useCallback(() => {\n    setIsOpen(false);\n    window.clearTimeout(mouseLeaveTimerRef.current);\n\n    onClose?.();\n  }, [onClose]);\n  const closeAndFocusTrigger = useCallback(() => {\n    handleClose();\n    triggerRef.current?.focus({ preventScroll: true });\n  }, [handleClose]);\n\n  useEffect(() => {\n    // close when parent menu closed\n    if (isParentMenuOpen === false) {\n      setIsOpen(false);\n    }\n  }, [isParentMenuOpen]);\n\n  const contextValue: SubmenuContextType = useMemo(\n    () => ({\n      isOpen,\n      getSubmenuListProps: (_props) => ({\n        'data-parent-menu': menuId,\n        onMouseOver: (event) => {\n          handleOpen();\n\n          _props.onMouseOver?.(event);\n        },\n        onMouseLeave: (event) => {\n          closeAndFocusTrigger();\n\n          _props.onMouseLeave?.(event);\n        },\n      }),\n      getSubmenuTriggerProps: (_props, _ref) => ({\n        ref: mergeRefs(triggerRef, _ref),\n        onKeyDown: (event) => {\n          if (event.key === 'ArrowRight') {\n            event.preventDefault();\n            handleOpen();\n          }\n\n          _props.onKeyDown?.(event);\n        },\n        onMouseOver: (event) => {\n          handleOpen();\n\n          _props.onMouseOver?.(event);\n        },\n        onMouseLeave: (event) => {\n          mouseLeaveTimerRef.current = window.setTimeout(\n            closeAndFocusTrigger,\n            300,\n          );\n\n          _props.onMouseLeave?.(event);\n        },\n      }),\n    }),\n    [isOpen, menuId, handleOpen, closeAndFocusTrigger],\n  );\n\n  return (\n    <SubmenuContextProvider value={contextValue}>\n      <Menu\n        {...propsToPropagateToSubmenus}\n        {...otherProps}\n        isOpen={isOpen}\n        onClose={handleClose}\n        onOpen={handleOpen}\n        placement=\"right-start\"\n        offset={SUBMENU_OFFSET}\n        isAutoalignmentEnabled={false}\n      />\n    </SubmenuContextProvider>\n  );\n};\n","import React from 'react';\nimport { MenuTrigger } from '../MenuTrigger/MenuTrigger';\nimport { MenuItem, MenuItemProps } from '../MenuItem/MenuItem';\nimport { useSubmenuContext } from '../SubmenuContext';\nimport { ChevronRightIcon } from '@contentful/f36-icons';\nimport type { ExpandProps } from '@contentful/f36-core';\nimport { cx } from 'emotion';\nimport { getSubmenuTriggerStyles } from './SubmenuTrigger.styles';\n\nexport type SubmenuTriggerProps = Omit<\n  MenuItemProps<'button'>,\n  'isInitiallyFocused' | 'as'\n>;\n\nconst _SubmenuTrigger = (\n  props: ExpandProps<SubmenuTriggerProps>,\n  ref: React.Ref<HTMLButtonElement>,\n) => {\n  const { className, children } = props;\n  const { getSubmenuTriggerProps, isOpen } = useSubmenuContext();\n\n  const styles = getSubmenuTriggerStyles();\n\n  return (\n    <MenuTrigger>\n      <MenuItem\n        {...props}\n        {...getSubmenuTriggerProps(props, ref)}\n        className={cx(styles.root({ isActive: isOpen }), className)}\n      >\n        <span className={styles.content}>{children}</span>\n        <ChevronRightIcon className={styles.icon} />\n      </MenuItem>\n    </MenuTrigger>\n  );\n};\n\nexport const SubmenuTrigger = React.forwardRef(_SubmenuTrigger);\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\n\nexport const getSubmenuTriggerStyles = () => {\n  return {\n    root: ({ isActive }) =>\n      css({\n        display: 'flex',\n        alignItems: 'center',\n        paddingRight: tokens.spacingXs,\n        ...(isActive\n          ? {\n              backgroundColor: tokens.gray100,\n            }\n          : {}),\n      }),\n    content: css({\n      marginRight: tokens.spacingM,\n    }),\n    icon: css({\n      marginLeft: 'auto',\n      fill: 'currentColor',\n    }),\n  };\n};\n","import { Menu as OriginalMenu } from './Menu';\nimport { MenuList } from './MenuList/MenuList';\nimport { MenuListHeader } from './MenuList/MenuListHeader';\nimport { MenuListFooter } from './MenuList/MenuListFooter';\nimport { MenuItem } from './MenuItem/MenuItem';\nimport { MenuTrigger } from './MenuTrigger/MenuTrigger';\nimport { MenuDivider } from './MenuDivider/MenuDivider';\nimport { MenuSectionTitle } from './MenuSectionTitle/MenuSectionTitle';\nimport { Submenu } from './Submenu/Submenu';\nimport { SubmenuTrigger } from './SubmenuTrigger/SubmenuTrigger';\n\ntype CompoundMenu = typeof OriginalMenu & {\n  List: typeof MenuList;\n  ListHeader: typeof MenuListHeader;\n  ListFooter: typeof MenuListFooter;\n  Item: typeof MenuItem;\n  Trigger: typeof MenuTrigger;\n  Divider: typeof MenuDivider;\n  SectionTitle: typeof MenuSectionTitle;\n  Submenu: typeof Submenu;\n  SubmenuTrigger: typeof SubmenuTrigger;\n};\n\nexport const Menu = OriginalMenu as CompoundMenu;\nMenu.List = MenuList;\nMenu.ListHeader = MenuListHeader;\nMenu.ListFooter = MenuListFooter;\nMenu.Item = MenuItem;\nMenu.Trigger = MenuTrigger;\nMenu.Divider = MenuDivider;\nMenu.SectionTitle = MenuSectionTitle;\nMenu.Submenu = Submenu;\nMenu.SubmenuTrigger = SubmenuTrigger;\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}