{"ast":null,"code":"import s, { useState, useRef, useEffect } from 'react';\nimport { usePopper } from 'react-popper';\nimport { cx, css } from 'emotion';\nimport i from '@contentful/f36-tokens';\nimport { Portal } from '@contentful/f36-utils';\nimport { useId, Box } from '@contentful/f36-core';\nvar se = Object.defineProperty;\nvar d = Object.getOwnPropertySymbols;\nvar L = Object.prototype.hasOwnProperty,\n  H = Object.prototype.propertyIsEnumerable;\nvar A = (t, o, e) => o in t ? se(t, o, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : t[o] = e,\n  y = (t, o) => {\n    for (var e in o || (o = {})) L.call(o, e) && A(t, e, o[e]);\n    if (d) for (var e of d(o)) H.call(o, e) && A(t, e, o[e]);\n    return t;\n  };\nvar K = (t, o) => {\n  var e = {};\n  for (var n in t) L.call(t, n) && o.indexOf(n) < 0 && (e[n] = t[n]);\n  if (t != null && d) for (var n of d(t)) o.indexOf(n) < 0 && H.call(t, n) && (e[n] = t[n]);\n  return e;\n};\nvar V = (t, o, e) => new Promise((n, u) => {\n  var b = a => {\n      try {\n        p(e.next(a));\n      } catch (l) {\n        u(l);\n      }\n    },\n    h = a => {\n      try {\n        p(e.throw(a));\n      } catch (l) {\n        u(l);\n      }\n    },\n    p = a => a.done ? n(a.value) : Promise.resolve(a.value).then(b, h);\n  p((e = e.apply(t, o)).next());\n});\nvar v = `calc(-1 * ((1rem * (10 / ${i.fontBaseDefault})) / 2))`,\n  j = `calc(1rem * (10 / ${i.fontBaseDefault}))`;\nfunction X() {\n  return {\n    tooltipTargetWrapper: css({\n      display: \"inline-block\",\n      position: \"relative\"\n    }),\n    tooltip: css({\n      background: i.gray900,\n      fontFamily: i.fontStackPrimary,\n      fontSize: i.fontSizeS,\n      fontWeight: i.fontWeightNormal,\n      fontStyle: \"normal\",\n      textDecoration: \"none\",\n      color: i.colorWhite,\n      textAlign: \"center\",\n      lineHeight: i.lineHeightM,\n      padding: `${i.spacingXs} calc(1rem * (10 / ${i.fontBaseDefault}))`,\n      borderRadius: i.borderRadiusMedium,\n      whiteSpace: \"normal\",\n      textTransform: \"initial\",\n      letterSpacing: \"initial\"\n    }),\n    tooltipHidden: css({\n      visibility: \"hidden\",\n      pointerEvents: \"none\",\n      zIndex: i.zIndexNegative\n    }),\n    tooltipContainer: css({\n      \"& > button[disabled]\": {\n        pointerEvents: \"none\"\n      }\n    }),\n    tooltipArrow: css({\n      position: \"absolute\",\n      '&[data-placement*=\"top\"]': {\n        bottom: 0,\n        left: 0,\n        marginBottom: v\n      },\n      '&[data-placement*=\"right\"]': {\n        left: 0,\n        marginLeft: v\n      },\n      '&[data-placement*=\"bottom\"]': {\n        left: 0,\n        top: 0,\n        marginTop: v\n      },\n      '&[data-placement*=\"left\"]': {\n        right: 0,\n        marginRight: v\n      },\n      \"&::before\": {\n        content: '\"\"',\n        display: \"block\",\n        height: j,\n        width: j,\n        backgroundColor: i.gray900,\n        transform: \"rotate3d(0, 0, 1, 45deg)\",\n        zIndex: i.zIndexNegative\n      }\n    })\n  };\n}\nvar me = ce => {\n  var N = ce,\n    {\n      children: t,\n      className: o,\n      as: e = \"span\",\n      content: n,\n      id: u,\n      isVisible: b = !1,\n      hideDelay: h = 0,\n      onBlur: p,\n      onFocus: a,\n      onMouseLeave: l,\n      onMouseOver: M,\n      onKeyDown: C,\n      showDelay: Q = 0,\n      targetWrapperClassName: R,\n      maxWidth: x = 360,\n      testId: U = \"cf-ui-tooltip\",\n      placement: Y = \"auto\",\n      usePortal: Z = !1,\n      isDisabled: _ = !1\n    } = N,\n    ee = K(N, [\"children\", \"className\", \"as\", \"content\", \"id\", \"isVisible\", \"hideDelay\", \"onBlur\", \"onFocus\", \"onMouseLeave\", \"onMouseOver\", \"onKeyDown\", \"showDelay\", \"targetWrapperClassName\", \"maxWidth\", \"testId\", \"placement\", \"usePortal\", \"isDisabled\"]);\n  let S = X(),\n    [te, f] = useState(b),\n    z = useId(u, \"tooltip\"),\n    B = useRef(null),\n    I = useRef(null),\n    [oe, ne] = useState(null),\n    {\n      styles: k,\n      attributes: T,\n      update: E\n    } = usePopper(B.current, I.current, {\n      placement: Y,\n      modifiers: [{\n        name: \"arrow\",\n        options: {\n          element: oe,\n          padding: parseFloat(i.borderRadiusSmall)\n        }\n      }, {\n        name: \"offset\",\n        options: {\n          offset: [0, 10]\n        }\n      }]\n    });\n  useEffect(() => {\n    (() => V(void 0, null, function* () {\n      E !== null && (yield E());\n    }))();\n  }, [n, E]);\n  let D = useRef(),\n    F = useRef(),\n    m = () => {\n      clearTimeout(D.current), clearTimeout(F.current);\n    };\n  useEffect(() => m, []);\n  let W = () => {\n      m(), D.current = setTimeout(() => f(!0), Q);\n    },\n    P = () => {\n      m(), F.current = setTimeout(() => f(!1), h);\n    },\n    re = typeof x == \"string\" ? x : `${x}px`,\n    ie = y({\n      zIndex: i.zIndexTooltip,\n      maxWidth: re\n    }, k.popper);\n  if (!n || _) return s.createElement(Box, {\n    as: e,\n    className: R\n  }, t);\n  let $ = s.createElement(Box, y({\n    as: \"span\",\n    id: z,\n    ref: I,\n    role: \"tooltip\",\n    style: ie,\n    className: cx(S.tooltip, o),\n    testId: U,\n    onMouseEnter: () => {\n      m(), f(!0);\n    },\n    onMouseLeave: () => {\n      m(), f(!1);\n    }\n  }, T.popper), s.createElement(\"span\", null, n), s.createElement(\"span\", {\n    className: S.tooltipArrow,\n    \"data-placement\": T.popper && T.popper[\"data-popper-placement\"],\n    ref: ne,\n    style: k.arrow\n  }));\n  return s.createElement(s.Fragment, null, te ? s.createElement(s.Fragment, null, Z ? s.createElement(Portal, null, $) : $) : null, s.createElement(Box, y({\n    as: e,\n    ref: B,\n    className: cx(S.tooltipContainer, R),\n    onMouseEnter: r => {\n      W(), M && M(r);\n    },\n    onMouseLeave: r => {\n      P(), l && l(r);\n    },\n    onFocus: r => {\n      W(), a && a(r);\n    },\n    onBlur: r => {\n      P(), p && p(r);\n    },\n    onKeyDown: r => {\n      r.key === \"Escape\" && P(), C && C(r);\n    }\n  }, ee), s.Children.map(t, r => {\n    if (s.isValidElement(r)) return s.cloneElement(r, {\n      \"aria-describedby\": z\n    });\n  })));\n};\nexport { me as Tooltip };","map":{"version":3,"names":[],"sources":["/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-tooltip/src/Tooltip.tsx","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-tooltip/src/Tooltip.styles.ts"],"sourcesContent":["import React, {\n  useEffect,\n  useState,\n  useRef,\n  type MouseEvent,\n  type FocusEvent,\n  type CSSProperties,\n} from 'react';\nimport { usePopper } from 'react-popper';\nimport type { Placement } from '@popperjs/core';\nimport { cx } from 'emotion';\nimport type * as CSS from 'csstype';\nimport tokens from '@contentful/f36-tokens';\nimport { Portal } from '@contentful/f36-utils';\nimport { Box, useId, type CommonProps } from '@contentful/f36-core';\n\nimport { getStyles } from './Tooltip.styles';\n\nexport type TooltipPlacement = Placement;\n\nexport interface TooltipProps extends CommonProps {\n  /**\n   * Child nodes to be rendered in the component and that will show the tooltip when they are hovered\n   */\n  children: React.ReactNode;\n  /**\n   * HTML element used to wrap the target of the tooltip\n   */\n  as?: React.ElementType;\n  /**\n   * Content of the tooltip\n   */\n  content?: string;\n  /**\n   * A unique id of the tooltip\n   */\n  id?: string;\n  /**\n   * It controls the initial visibility of the tooltip\n   */\n  isVisible?: boolean;\n  /**\n   * It sets a max-width for the tooltip\n   */\n  maxWidth?: number | CSS.Property.MaxWidth;\n  /**\n   * Set a delay period in milliseconds before hiding the tooltip\n   */\n  hideDelay?: number;\n  /**\n   * Function that will be called when target gets blurred\n   */\n  onBlur?: (evt: FocusEvent) => void;\n  /**\n   * Function that will be called when target gets focused\n   */\n  onFocus?: (evt: FocusEvent) => void;\n  /**\n   * Function that will be called when the user move the mouse out of the target\n   */\n  onMouseLeave?: (evt: MouseEvent) => void;\n  /**\n   * Function that will be called when the user move the mouse over of the target\n   */\n  onMouseOver?: (evt: MouseEvent) => void;\n  /**\n   * Function that will be called when the user uses a keyboard key on the target\n   */\n  onKeyDown?: (evt: KeyboardEvent) => void;\n\n  /**\n   * It sets the \"preferred\" position of the tooltip\n   */\n  placement?: TooltipPlacement;\n  /**\n   * Set a delay period in milliseconds before showing the tooltip\n   */\n  showDelay?: number;\n  /**\n   * Class names to be appended to the className prop of the tooltipâ€™s target\n   */\n  targetWrapperClassName?: string;\n  /**\n   * Boolean to control whether or not to render the tooltip in a React Portal.\n   * Rendering content inside a Portal allows the tooltip to escape the bounds\n   * of its parent while still being positioned correctly. Using a Portal is\n   * necessary if an ancestor of the tooltip hides overflow.\n   *\n   * Defaults to `false`\n   */\n  usePortal?: boolean;\n  /**\n   * Prevents showing the tooltip\n   * @default false\n   */\n  isDisabled?: boolean;\n}\n\nexport const Tooltip = ({\n  children,\n  className,\n  as: HtmlTag = 'span',\n  content,\n  id,\n  isVisible = false,\n  hideDelay = 0,\n  onBlur,\n  onFocus,\n  onMouseLeave,\n  onMouseOver,\n  onKeyDown,\n  showDelay = 0,\n  targetWrapperClassName,\n  maxWidth = 360,\n  testId = 'cf-ui-tooltip',\n  placement = 'auto',\n  usePortal = false,\n  isDisabled = false,\n  ...otherProps\n}: TooltipProps) => {\n  const styles = getStyles();\n  const [show, setShow] = useState(isVisible);\n  const tooltipId = useId(id, 'tooltip');\n  const elementRef = useRef(null);\n  const popperRef = useRef(null);\n  const [arrowRef, setArrowRef] = useState<HTMLSpanElement | null>(null);\n  const {\n    styles: popperStyles,\n    attributes,\n    update,\n  } = usePopper(elementRef.current, popperRef.current, {\n    placement: placement,\n    modifiers: [\n      {\n        name: 'arrow',\n        options: {\n          element: arrowRef,\n          padding: parseFloat(tokens.borderRadiusSmall),\n        },\n      },\n      {\n        name: 'offset',\n        options: {\n          offset: [0, 10],\n        },\n      },\n    ],\n  });\n\n  // necessary to update tooltip position in case the content is being updated\n  useEffect(() => {\n    const updatePosition = async () => {\n      if (update !== null) {\n        await update();\n      }\n    };\n    updatePosition();\n  }, [content, update]);\n\n  const showTimeoutRef = useRef<ReturnType<typeof setTimeout>>();\n  const hideTimeoutRef = useRef<ReturnType<typeof setTimeout>>();\n  const clearTimeouts = () => {\n    clearTimeout(showTimeoutRef.current);\n    clearTimeout(hideTimeoutRef.current);\n  };\n  useEffect(() => clearTimeouts, []);\n\n  const showPopover = () => {\n    clearTimeouts();\n    showTimeoutRef.current = setTimeout(() => setShow(true), showDelay);\n  };\n  const hidePopover = () => {\n    clearTimeouts();\n    hideTimeoutRef.current = setTimeout(() => setShow(false), hideDelay);\n  };\n\n  const contentMaxWidth =\n    typeof maxWidth === 'string' ? maxWidth : `${maxWidth}px`;\n\n  const contentStyles: CSSProperties = {\n    zIndex: tokens.zIndexTooltip,\n    maxWidth: contentMaxWidth,\n    ...popperStyles.popper,\n  };\n\n  if (!content || isDisabled) {\n    return (\n      <Box as={HtmlTag} className={targetWrapperClassName}>\n        {children}\n      </Box>\n    );\n  }\n\n  const tooltip = (\n    <Box\n      as=\"span\"\n      id={tooltipId}\n      ref={popperRef}\n      role=\"tooltip\"\n      style={contentStyles}\n      className={cx(styles.tooltip, className)}\n      testId={testId}\n      onMouseEnter={() => {\n        clearTimeouts();\n        setShow(true);\n      }}\n      onMouseLeave={() => {\n        clearTimeouts();\n        setShow(false);\n      }}\n      {...attributes.popper}\n    >\n      <span>{content}</span>\n      <span\n        className={styles.tooltipArrow}\n        data-placement={\n          attributes.popper && attributes.popper['data-popper-placement']\n        }\n        ref={setArrowRef}\n        style={popperStyles.arrow}\n      />\n    </Box>\n  );\n\n  return (\n    <>\n      {show ? <>{usePortal ? <Portal>{tooltip}</Portal> : tooltip}</> : null}\n      <Box\n        as={HtmlTag}\n        ref={elementRef}\n        className={cx(styles.tooltipContainer, targetWrapperClassName)}\n        onMouseEnter={(evt: MouseEvent) => {\n          showPopover();\n          if (onMouseOver) onMouseOver(evt);\n        }}\n        onMouseLeave={(evt: MouseEvent) => {\n          hidePopover();\n          if (onMouseLeave) onMouseLeave(evt);\n        }}\n        onFocus={(evt: FocusEvent) => {\n          showPopover();\n          if (onFocus) onFocus(evt);\n        }}\n        onBlur={(evt: FocusEvent) => {\n          hidePopover();\n          if (onBlur) onBlur(evt);\n        }}\n        onKeyDown={(evt: KeyboardEvent) => {\n          if (evt.key === 'Escape') {\n            hidePopover();\n          }\n          if (onKeyDown) onKeyDown(evt);\n        }}\n        {...otherProps}\n      >\n        {React.Children.map<React.ReactNode, React.ReactNode>(\n          children,\n          (child) => {\n            if (React.isValidElement(child)) {\n              return React.cloneElement(child, {\n                'aria-describedby': tooltipId,\n              });\n            }\n          },\n        )}\n      </Box>\n    </>\n  );\n};\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\n\nconst tooltipMargin = `calc(-1 * ((1rem * (10 / ${tokens.fontBaseDefault})) / 2))`;\nconst tooltipChevronSize = `calc(1rem * (10 / ${tokens.fontBaseDefault}))`;\n\nexport function getStyles() {\n  return {\n    tooltipTargetWrapper: css({\n      display: 'inline-block',\n      position: 'relative',\n    }),\n    tooltip: css({\n      background: tokens.gray900,\n      fontFamily: tokens.fontStackPrimary,\n      fontSize: tokens.fontSizeS,\n      fontWeight: tokens.fontWeightNormal,\n      fontStyle: 'normal',\n      textDecoration: 'none',\n      color: tokens.colorWhite,\n      textAlign: 'center',\n      lineHeight: tokens.lineHeightM,\n      padding: `${tokens.spacingXs} calc(1rem * (10 / ${tokens.fontBaseDefault}))`,\n      borderRadius: tokens.borderRadiusMedium,\n      whiteSpace: 'normal',\n      textTransform: 'initial',\n      letterSpacing: 'initial',\n    }),\n    tooltipHidden: css({\n      visibility: 'hidden',\n      pointerEvents: 'none',\n      zIndex: tokens.zIndexNegative,\n    }),\n    tooltipContainer: css({\n      '& > button[disabled]': { pointerEvents: 'none' },\n    }),\n    tooltipArrow: css({\n      position: 'absolute',\n      '&[data-placement*=\"top\"]': {\n        bottom: 0,\n        left: 0,\n        marginBottom: tooltipMargin,\n      },\n      '&[data-placement*=\"right\"]': {\n        left: 0,\n        marginLeft: tooltipMargin,\n      },\n      '&[data-placement*=\"bottom\"]': {\n        left: 0,\n        top: 0,\n        marginTop: tooltipMargin,\n      },\n      '&[data-placement*=\"left\"]': {\n        right: 0,\n        marginRight: tooltipMargin,\n      },\n      '&::before': {\n        content: '\"\"',\n        display: 'block',\n        height: tooltipChevronSize,\n        width: tooltipChevronSize,\n        backgroundColor: tokens.gray900,\n        transform: 'rotate3d(0, 0, 1, 45deg)',\n        zIndex: tokens.zIndexNegative,\n      },\n    }),\n  };\n}\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}