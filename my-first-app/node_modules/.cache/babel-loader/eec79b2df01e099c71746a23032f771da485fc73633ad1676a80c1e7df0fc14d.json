{"ast":null,"code":"import PropTypes from 'prop-types';\nimport { Component, cloneElement, useRef, useEffect, useCallback, useLayoutEffect, useReducer, useMemo } from 'react';\nimport { isForwardRef } from 'react-is';\nimport computeScrollIntoView from 'compute-scroll-into-view';\nimport { __assign } from 'tslib';\nlet idCounter = 0;\n/**\n * Accepts a parameter and returns it if it's a function\n * or a noop function if it's not. This allows us to\n * accept a callback, but not worry about it if it's not\n * passed.\n * @param {Function} cb the callback\n * @return {Function} a function\n */\n\nfunction cbToCb(cb) {\n  return typeof cb === 'function' ? cb : noop;\n}\nfunction noop() {}\n/**\n * Scroll node into view if necessary\n * @param {HTMLElement} node the element that should scroll into view\n * @param {HTMLElement} menuNode the menu element of the component\n */\n\nfunction scrollIntoView(node, menuNode) {\n  if (!node) {\n    return;\n  }\n  const actions = computeScrollIntoView(node, {\n    boundary: menuNode,\n    block: 'nearest',\n    scrollMode: 'if-needed'\n  });\n  actions.forEach(_ref => {\n    let {\n      el,\n      top,\n      left\n    } = _ref;\n    el.scrollTop = top;\n    el.scrollLeft = left;\n  });\n}\n/**\n * @param {HTMLElement} parent the parent node\n * @param {HTMLElement} child the child node\n * @param {Window} environment The window context where downshift renders.\n * @return {Boolean} whether the parent is the child or the child is in the parent\n */\n\nfunction isOrContainsNode(parent, child, environment) {\n  const result = parent === child || child instanceof environment.Node && parent.contains && parent.contains(child);\n  return result;\n}\n/**\n * Simple debounce implementation. Will call the given\n * function once after the time given has passed since\n * it was last called.\n * @param {Function} fn the function to call after the time\n * @param {Number} time the time to wait\n * @return {Function} the debounced function\n */\n\nfunction debounce(fn, time) {\n  let timeoutId;\n  function cancel() {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n  }\n  function wrapper() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    cancel();\n    timeoutId = setTimeout(() => {\n      timeoutId = null;\n      fn(...args);\n    }, time);\n  }\n  wrapper.cancel = cancel;\n  return wrapper;\n}\n/**\n * This is intended to be used to compose event handlers.\n * They are executed in order until one of them sets\n * `event.preventDownshiftDefault = true`.\n * @param {...Function} fns the event handler functions\n * @return {Function} the event handler to add to an element\n */\n\nfunction callAllEventHandlers() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n  return function (event) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    return fns.some(fn => {\n      if (fn) {\n        fn(event, ...args);\n      }\n      return event.preventDownshiftDefault || event.hasOwnProperty('nativeEvent') && event.nativeEvent.preventDownshiftDefault;\n    });\n  };\n}\nfunction handleRefs() {\n  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    refs[_key4] = arguments[_key4];\n  }\n  return node => {\n    refs.forEach(ref => {\n      if (typeof ref === 'function') {\n        ref(node);\n      } else if (ref) {\n        ref.current = node;\n      }\n    });\n  };\n}\n/**\n * This generates a unique ID for an instance of Downshift\n * @return {String} the unique ID\n */\n\nfunction generateId() {\n  return String(idCounter++);\n}\n/**\n * Resets idCounter to 0. Used for SSR.\n */\n\nfunction resetIdCounter() {\n  idCounter = 0;\n}\n/**\n * Default implementation for status message. Only added when menu is open.\n * Will specify if there are results in the list, and if so, how many,\n * and what keys are relevant.\n *\n * @param {Object} param the downshift state and other relevant properties\n * @return {String} the a11y status message\n */\n\nfunction getA11yStatusMessage$1(_ref2) {\n  let {\n    isOpen,\n    resultCount,\n    previousResultCount\n  } = _ref2;\n  if (!isOpen) {\n    return '';\n  }\n  if (!resultCount) {\n    return 'No results are available.';\n  }\n  if (resultCount !== previousResultCount) {\n    return `${resultCount} result${resultCount === 1 ? ' is' : 's are'} available, use up and down arrow keys to navigate. Press Enter key to select.`;\n  }\n  return '';\n}\n/**\n * Takes an argument and if it's an array, returns the first item in the array\n * otherwise returns the argument\n * @param {*} arg the maybe-array\n * @param {*} defaultValue the value if arg is falsey not defined\n * @return {*} the arg or it's first item\n */\n\nfunction unwrapArray(arg, defaultValue) {\n  arg = Array.isArray(arg) ? /* istanbul ignore next (preact) */\n  arg[0] : arg;\n  if (!arg && defaultValue) {\n    return defaultValue;\n  } else {\n    return arg;\n  }\n}\n/**\n * @param {Object} element (P)react element\n * @return {Boolean} whether it's a DOM element\n */\n\nfunction isDOMElement(element) {\n  return typeof element.type === 'string';\n}\n/**\n * @param {Object} element (P)react element\n * @return {Object} the props\n */\n\nfunction getElementProps(element) {\n  return element.props;\n}\n/**\n * Throws a helpful error message for required properties. Useful\n * to be used as a default in destructuring or object params.\n * @param {String} fnName the function name\n * @param {String} propName the prop name\n */\n\nfunction requiredProp(fnName, propName) {\n  // eslint-disable-next-line no-console\n  console.error(`The property \"${propName}\" is required in \"${fnName}\"`);\n}\nconst stateKeys = ['highlightedIndex', 'inputValue', 'isOpen', 'selectedItem', 'type'];\n/**\n * @param {Object} state the state object\n * @return {Object} state that is relevant to downshift\n */\n\nfunction pickState(state) {\n  if (state === void 0) {\n    state = {};\n  }\n  const result = {};\n  stateKeys.forEach(k => {\n    if (state.hasOwnProperty(k)) {\n      result[k] = state[k];\n    }\n  });\n  return result;\n}\n/**\n * This will perform a shallow merge of the given state object\n * with the state coming from props\n * (for the controlled component scenario)\n * This is used in state updater functions so they're referencing\n * the right state regardless of where it comes from.\n *\n * @param {Object} state The state of the component/hook.\n * @param {Object} props The props that may contain controlled values.\n * @returns {Object} The merged controlled state.\n */\n\nfunction getState(state, props) {\n  return Object.keys(state).reduce((prevState, key) => {\n    prevState[key] = isControlledProp(props, key) ? props[key] : state[key];\n    return prevState;\n  }, {});\n}\n/**\n * This determines whether a prop is a \"controlled prop\" meaning it is\n * state which is controlled by the outside of this component rather\n * than within this component.\n *\n * @param {Object} props The props that may contain controlled values.\n * @param {String} key the key to check\n * @return {Boolean} whether it is a controlled controlled prop\n */\n\nfunction isControlledProp(props, key) {\n  return props[key] !== undefined;\n}\n/**\n * Normalizes the 'key' property of a KeyboardEvent in IE/Edge\n * @param {Object} event a keyboardEvent object\n * @return {String} keyboard key\n */\n\nfunction normalizeArrowKey(event) {\n  const {\n    key,\n    keyCode\n  } = event;\n  /* istanbul ignore next (ie) */\n\n  if (keyCode >= 37 && keyCode <= 40 && key.indexOf('Arrow') !== 0) {\n    return `Arrow${key}`;\n  }\n  return key;\n}\n/**\n * Simple check if the value passed is object literal\n * @param {*} obj any things\n * @return {Boolean} whether it's object literal\n */\n\nfunction isPlainObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n/**\n * Returns the new index in the list, in a circular way. If next value is out of bonds from the total,\n * it will wrap to either 0 or itemCount - 1.\n *\n * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.\n * @param {number} baseIndex The initial position to move from.\n * @param {number} itemCount The total number of items.\n * @param {Function} getItemNodeFromIndex Used to check if item is disabled.\n * @param {boolean} circular Specify if navigation is circular. Default is true.\n * @returns {number} The new index after the move.\n */\n\nfunction getNextWrappingIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {\n  if (circular === void 0) {\n    circular = true;\n  }\n  if (itemCount === 0) {\n    return -1;\n  }\n  const itemsLastIndex = itemCount - 1;\n  if (typeof baseIndex !== 'number' || baseIndex < 0 || baseIndex >= itemCount) {\n    baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;\n  }\n  let newIndex = baseIndex + moveAmount;\n  if (newIndex < 0) {\n    newIndex = circular ? itemsLastIndex : 0;\n  } else if (newIndex > itemsLastIndex) {\n    newIndex = circular ? 0 : itemsLastIndex;\n  }\n  const nonDisabledNewIndex = getNextNonDisabledIndex(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular);\n  if (nonDisabledNewIndex === -1) {\n    return baseIndex >= itemCount ? -1 : baseIndex;\n  }\n  return nonDisabledNewIndex;\n}\n/**\n * Returns the next index in the list of an item that is not disabled.\n *\n * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.\n * @param {number} baseIndex The initial position to move from.\n * @param {number} itemCount The total number of items.\n * @param {Function} getItemNodeFromIndex Used to check if item is disabled.\n * @param {boolean} circular Specify if navigation is circular. Default is true.\n * @returns {number} The new index. Returns baseIndex if item is not disabled. Returns next non-disabled item otherwise. If no non-disabled found it will return -1.\n */\n\nfunction getNextNonDisabledIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {\n  const currentElementNode = getItemNodeFromIndex(baseIndex);\n  if (!currentElementNode || !currentElementNode.hasAttribute('disabled')) {\n    return baseIndex;\n  }\n  if (moveAmount > 0) {\n    for (let index = baseIndex + 1; index < itemCount; index++) {\n      if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {\n        return index;\n      }\n    }\n  } else {\n    for (let index = baseIndex - 1; index >= 0; index--) {\n      if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {\n        return index;\n      }\n    }\n  }\n  if (circular) {\n    return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);\n  }\n  return -1;\n}\n/**\n * Checks if event target is within the downshift elements.\n *\n * @param {EventTarget} target Target to check.\n * @param {HTMLElement[]} downshiftElements The elements that form downshift (list, toggle button etc).\n * @param {Window} environment The window context where downshift renders.\n * @param {boolean} checkActiveElement Whether to also check activeElement.\n *\n * @returns {boolean} Whether or not the target is within downshift elements.\n */\n\nfunction targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {\n  if (checkActiveElement === void 0) {\n    checkActiveElement = true;\n  }\n  return downshiftElements.some(contextNode => contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment)));\n} // eslint-disable-next-line import/no-mutable-exports\n\nlet validateControlledUnchanged = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validateControlledUnchanged = (state, prevProps, nextProps) => {\n    const warningDescription = `This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/downshift-js/downshift#control-props`;\n    Object.keys(state).forEach(propKey => {\n      if (prevProps[propKey] !== undefined && nextProps[propKey] === undefined) {\n        // eslint-disable-next-line no-console\n        console.error(`downshift: A component has changed the controlled prop \"${propKey}\" to be uncontrolled. ${warningDescription}`);\n      } else if (prevProps[propKey] === undefined && nextProps[propKey] !== undefined) {\n        // eslint-disable-next-line no-console\n        console.error(`downshift: A component has changed the uncontrolled prop \"${propKey}\" to be controlled. ${warningDescription}`);\n      }\n    });\n  };\n}\nconst cleanupStatus = debounce(documentProp => {\n  getStatusDiv(documentProp).textContent = '';\n}, 500);\n/**\n * @param {String} status the status message\n * @param {Object} documentProp document passed by the user.\n */\n\nfunction setStatus(status, documentProp) {\n  const div = getStatusDiv(documentProp);\n  if (!status) {\n    return;\n  }\n  div.textContent = status;\n  cleanupStatus(documentProp);\n}\n/**\n * Get the status node or create it if it does not already exist.\n * @param {Object} documentProp document passed by the user.\n * @return {HTMLElement} the status node.\n */\n\nfunction getStatusDiv(documentProp) {\n  if (documentProp === void 0) {\n    documentProp = document;\n  }\n  let statusDiv = documentProp.getElementById('a11y-status-message');\n  if (statusDiv) {\n    return statusDiv;\n  }\n  statusDiv = documentProp.createElement('div');\n  statusDiv.setAttribute('id', 'a11y-status-message');\n  statusDiv.setAttribute('role', 'status');\n  statusDiv.setAttribute('aria-live', 'polite');\n  statusDiv.setAttribute('aria-relevant', 'additions text');\n  Object.assign(statusDiv.style, {\n    border: '0',\n    clip: 'rect(0 0 0 0)',\n    height: '1px',\n    margin: '-1px',\n    overflow: 'hidden',\n    padding: '0',\n    position: 'absolute',\n    width: '1px'\n  });\n  documentProp.body.appendChild(statusDiv);\n  return statusDiv;\n}\nconst unknown = process.env.NODE_ENV !== \"production\" ? '__autocomplete_unknown__' : 0;\nconst mouseUp = process.env.NODE_ENV !== \"production\" ? '__autocomplete_mouseup__' : 1;\nconst itemMouseEnter = process.env.NODE_ENV !== \"production\" ? '__autocomplete_item_mouseenter__' : 2;\nconst keyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_arrow_up__' : 3;\nconst keyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_arrow_down__' : 4;\nconst keyDownEscape = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_escape__' : 5;\nconst keyDownEnter = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_enter__' : 6;\nconst keyDownHome = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_home__' : 7;\nconst keyDownEnd = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_end__' : 8;\nconst clickItem = process.env.NODE_ENV !== \"production\" ? '__autocomplete_click_item__' : 9;\nconst blurInput = process.env.NODE_ENV !== \"production\" ? '__autocomplete_blur_input__' : 10;\nconst changeInput = process.env.NODE_ENV !== \"production\" ? '__autocomplete_change_input__' : 11;\nconst keyDownSpaceButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_space_button__' : 12;\nconst clickButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_click_button__' : 13;\nconst blurButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_blur_button__' : 14;\nconst controlledPropUpdatedSelectedItem = process.env.NODE_ENV !== \"production\" ? '__autocomplete_controlled_prop_updated_selected_item__' : 15;\nconst touchEnd = process.env.NODE_ENV !== \"production\" ? '__autocomplete_touchend__' : 16;\nvar stateChangeTypes$3 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  unknown: unknown,\n  mouseUp: mouseUp,\n  itemMouseEnter: itemMouseEnter,\n  keyDownArrowUp: keyDownArrowUp,\n  keyDownArrowDown: keyDownArrowDown,\n  keyDownEscape: keyDownEscape,\n  keyDownEnter: keyDownEnter,\n  keyDownHome: keyDownHome,\n  keyDownEnd: keyDownEnd,\n  clickItem: clickItem,\n  blurInput: blurInput,\n  changeInput: changeInput,\n  keyDownSpaceButton: keyDownSpaceButton,\n  clickButton: clickButton,\n  blurButton: blurButton,\n  controlledPropUpdatedSelectedItem: controlledPropUpdatedSelectedItem,\n  touchEnd: touchEnd\n});\n\n/* eslint camelcase:0 */\n\nconst Downshift = /*#__PURE__*/(() => {\n  class Downshift extends Component {\n    constructor(_props) {\n      var _this;\n      super(_props);\n      _this = this;\n      this.id = this.props.id || `downshift-${generateId()}`;\n      this.menuId = this.props.menuId || `${this.id}-menu`;\n      this.labelId = this.props.labelId || `${this.id}-label`;\n      this.inputId = this.props.inputId || `${this.id}-input`;\n      this.getItemId = this.props.getItemId || (index => `${this.id}-item-${index}`);\n      this.input = null;\n      this.items = [];\n      this.itemCount = null;\n      this.previousResultCount = 0;\n      this.timeoutIds = [];\n      this.internalSetTimeout = (fn, time) => {\n        const id = setTimeout(() => {\n          this.timeoutIds = this.timeoutIds.filter(i => i !== id);\n          fn();\n        }, time);\n        this.timeoutIds.push(id);\n      };\n      this.setItemCount = count => {\n        this.itemCount = count;\n      };\n      this.unsetItemCount = () => {\n        this.itemCount = null;\n      };\n      this.setHighlightedIndex = function (highlightedIndex, otherStateToSet) {\n        if (highlightedIndex === void 0) {\n          highlightedIndex = _this.props.defaultHighlightedIndex;\n        }\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n        otherStateToSet = pickState(otherStateToSet);\n        _this.internalSetState({\n          highlightedIndex,\n          ...otherStateToSet\n        });\n      };\n      this.clearSelection = cb => {\n        this.internalSetState({\n          selectedItem: null,\n          inputValue: '',\n          highlightedIndex: this.props.defaultHighlightedIndex,\n          isOpen: this.props.defaultIsOpen\n        }, cb);\n      };\n      this.selectItem = (item, otherStateToSet, cb) => {\n        otherStateToSet = pickState(otherStateToSet);\n        this.internalSetState({\n          isOpen: this.props.defaultIsOpen,\n          highlightedIndex: this.props.defaultHighlightedIndex,\n          selectedItem: item,\n          inputValue: this.props.itemToString(item),\n          ...otherStateToSet\n        }, cb);\n      };\n      this.selectItemAtIndex = (itemIndex, otherStateToSet, cb) => {\n        const item = this.items[itemIndex];\n        if (item == null) {\n          return;\n        }\n        this.selectItem(item, otherStateToSet, cb);\n      };\n      this.selectHighlightedItem = (otherStateToSet, cb) => {\n        return this.selectItemAtIndex(this.getState().highlightedIndex, otherStateToSet, cb);\n      };\n      this.internalSetState = (stateToSet, cb) => {\n        let isItemSelected, onChangeArg;\n        const onStateChangeArg = {};\n        const isStateToSetFunction = typeof stateToSet === 'function'; // we want to call `onInputValueChange` before the `setState` call\n        // so someone controlling the `inputValue` state gets notified of\n        // the input change as soon as possible. This avoids issues with\n        // preserving the cursor position.\n        // See https://github.com/downshift-js/downshift/issues/217 for more info.\n\n        if (!isStateToSetFunction && stateToSet.hasOwnProperty('inputValue')) {\n          this.props.onInputValueChange(stateToSet.inputValue, {\n            ...this.getStateAndHelpers(),\n            ...stateToSet\n          });\n        }\n        return this.setState(state => {\n          state = this.getState(state);\n          let newStateToSet = isStateToSetFunction ? stateToSet(state) : stateToSet; // Your own function that could modify the state that will be set.\n\n          newStateToSet = this.props.stateReducer(state, newStateToSet); // checks if an item is selected, regardless of if it's different from\n          // what was selected before\n          // used to determine if onSelect and onChange callbacks should be called\n\n          isItemSelected = newStateToSet.hasOwnProperty('selectedItem'); // this keeps track of the object we want to call with setState\n\n          const nextState = {}; // this is just used to tell whether the state changed\n          // and we're trying to update that state. OR if the selection has changed and we're\n          // trying to update the selection\n\n          if (isItemSelected && newStateToSet.selectedItem !== state.selectedItem) {\n            onChangeArg = newStateToSet.selectedItem;\n          }\n          newStateToSet.type = newStateToSet.type || unknown;\n          Object.keys(newStateToSet).forEach(key => {\n            // onStateChangeArg should only have the state that is\n            // actually changing\n            if (state[key] !== newStateToSet[key]) {\n              onStateChangeArg[key] = newStateToSet[key];\n            } // the type is useful for the onStateChangeArg\n            // but we don't actually want to set it in internal state.\n            // this is an undocumented feature for now... Not all internalSetState\n            // calls support it and I'm not certain we want them to yet.\n            // But it enables users controlling the isOpen state to know when\n            // the isOpen state changes due to mouseup events which is quite handy.\n\n            if (key === 'type') {\n              return;\n            }\n            newStateToSet[key]; // if it's coming from props, then we don't care to set it internally\n\n            if (!isControlledProp(this.props, key)) {\n              nextState[key] = newStateToSet[key];\n            }\n          }); // if stateToSet is a function, then we weren't able to call onInputValueChange\n          // earlier, so we'll call it now that we know what the inputValue state will be.\n\n          if (isStateToSetFunction && newStateToSet.hasOwnProperty('inputValue')) {\n            this.props.onInputValueChange(newStateToSet.inputValue, {\n              ...this.getStateAndHelpers(),\n              ...newStateToSet\n            });\n          }\n          return nextState;\n        }, () => {\n          // call the provided callback if it's a function\n          cbToCb(cb)(); // only call the onStateChange and onChange callbacks if\n          // we have relevant information to pass them.\n\n          const hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;\n          if (hasMoreStateThanType) {\n            this.props.onStateChange(onStateChangeArg, this.getStateAndHelpers());\n          }\n          if (isItemSelected) {\n            this.props.onSelect(stateToSet.selectedItem, this.getStateAndHelpers());\n          }\n          if (onChangeArg !== undefined) {\n            this.props.onChange(onChangeArg, this.getStateAndHelpers());\n          } // this is currently undocumented and therefore subject to change\n          // We'll try to not break it, but just be warned.\n\n          this.props.onUserAction(onStateChangeArg, this.getStateAndHelpers());\n        });\n      };\n      this.rootRef = node => this._rootNode = node;\n      this.getRootProps = function (_temp, _temp2) {\n        let {\n          refKey = 'ref',\n          ref,\n          ...rest\n        } = _temp === void 0 ? {} : _temp;\n        let {\n          suppressRefError = false\n        } = _temp2 === void 0 ? {} : _temp2;\n        // this is used in the render to know whether the user has called getRootProps.\n        // It uses that to know whether to apply the props automatically\n        _this.getRootProps.called = true;\n        _this.getRootProps.refKey = refKey;\n        _this.getRootProps.suppressRefError = suppressRefError;\n        const {\n          isOpen\n        } = _this.getState();\n        return {\n          [refKey]: handleRefs(ref, _this.rootRef),\n          role: 'combobox',\n          'aria-expanded': isOpen,\n          'aria-haspopup': 'listbox',\n          'aria-owns': isOpen ? _this.menuId : null,\n          'aria-labelledby': _this.labelId,\n          ...rest\n        };\n      };\n      this.keyDownHandlers = {\n        ArrowDown(event) {\n          event.preventDefault();\n          if (this.getState().isOpen) {\n            const amount = event.shiftKey ? 5 : 1;\n            this.moveHighlightedIndex(amount, {\n              type: keyDownArrowDown\n            });\n          } else {\n            this.internalSetState({\n              isOpen: true,\n              type: keyDownArrowDown\n            }, () => {\n              const itemCount = this.getItemCount();\n              if (itemCount > 0) {\n                const {\n                  highlightedIndex\n                } = this.getState();\n                const nextHighlightedIndex = getNextWrappingIndex(1, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));\n                this.setHighlightedIndex(nextHighlightedIndex, {\n                  type: keyDownArrowDown\n                });\n              }\n            });\n          }\n        },\n        ArrowUp(event) {\n          event.preventDefault();\n          if (this.getState().isOpen) {\n            const amount = event.shiftKey ? -5 : -1;\n            this.moveHighlightedIndex(amount, {\n              type: keyDownArrowUp\n            });\n          } else {\n            this.internalSetState({\n              isOpen: true,\n              type: keyDownArrowUp\n            }, () => {\n              const itemCount = this.getItemCount();\n              if (itemCount > 0) {\n                const {\n                  highlightedIndex\n                } = this.getState();\n                const nextHighlightedIndex = getNextWrappingIndex(-1, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));\n                this.setHighlightedIndex(nextHighlightedIndex, {\n                  type: keyDownArrowUp\n                });\n              }\n            });\n          }\n        },\n        Enter(event) {\n          if (event.which === 229) {\n            return;\n          }\n          const {\n            isOpen,\n            highlightedIndex\n          } = this.getState();\n          if (isOpen && highlightedIndex != null) {\n            event.preventDefault();\n            const item = this.items[highlightedIndex];\n            const itemNode = this.getItemNodeFromIndex(highlightedIndex);\n            if (item == null || itemNode && itemNode.hasAttribute('disabled')) {\n              return;\n            }\n            this.selectHighlightedItem({\n              type: keyDownEnter\n            });\n          }\n        },\n        Escape(event) {\n          event.preventDefault();\n          this.reset({\n            type: keyDownEscape,\n            ...(!this.state.isOpen && {\n              selectedItem: null,\n              inputValue: ''\n            })\n          });\n        }\n      };\n      this.buttonKeyDownHandlers = {\n        ...this.keyDownHandlers,\n        ' '(event) {\n          event.preventDefault();\n          this.toggleMenu({\n            type: keyDownSpaceButton\n          });\n        }\n      };\n      this.inputKeyDownHandlers = {\n        ...this.keyDownHandlers,\n        Home(event) {\n          const {\n            isOpen\n          } = this.getState();\n          if (!isOpen) {\n            return;\n          }\n          event.preventDefault();\n          const itemCount = this.getItemCount();\n          if (itemCount <= 0 || !isOpen) {\n            return;\n          } // get next non-disabled starting downwards from 0 if that's disabled.\n\n          const newHighlightedIndex = getNextNonDisabledIndex(1, 0, itemCount, index => this.getItemNodeFromIndex(index), false);\n          this.setHighlightedIndex(newHighlightedIndex, {\n            type: keyDownHome\n          });\n        },\n        End(event) {\n          const {\n            isOpen\n          } = this.getState();\n          if (!isOpen) {\n            return;\n          }\n          event.preventDefault();\n          const itemCount = this.getItemCount();\n          if (itemCount <= 0 || !isOpen) {\n            return;\n          } // get next non-disabled starting upwards from last index if that's disabled.\n\n          const newHighlightedIndex = getNextNonDisabledIndex(-1, itemCount - 1, itemCount, index => this.getItemNodeFromIndex(index), false);\n          this.setHighlightedIndex(newHighlightedIndex, {\n            type: keyDownEnd\n          });\n        }\n      };\n      this.getToggleButtonProps = function (_temp3) {\n        let {\n          onClick,\n          onPress,\n          onKeyDown,\n          onKeyUp,\n          onBlur,\n          ...rest\n        } = _temp3 === void 0 ? {} : _temp3;\n        const {\n          isOpen\n        } = _this.getState();\n        const enabledEventHandlers = {\n          onClick: callAllEventHandlers(onClick, _this.buttonHandleClick),\n          onKeyDown: callAllEventHandlers(onKeyDown, _this.buttonHandleKeyDown),\n          onKeyUp: callAllEventHandlers(onKeyUp, _this.buttonHandleKeyUp),\n          onBlur: callAllEventHandlers(onBlur, _this.buttonHandleBlur)\n        };\n        const eventHandlers = rest.disabled ? {} : enabledEventHandlers;\n        return {\n          type: 'button',\n          role: 'button',\n          'aria-label': isOpen ? 'close menu' : 'open menu',\n          'aria-haspopup': true,\n          'data-toggle': true,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n      this.buttonHandleKeyUp = event => {\n        // Prevent click event from emitting in Firefox\n        event.preventDefault();\n      };\n      this.buttonHandleKeyDown = event => {\n        const key = normalizeArrowKey(event);\n        if (this.buttonKeyDownHandlers[key]) {\n          this.buttonKeyDownHandlers[key].call(this, event);\n        }\n      };\n      this.buttonHandleClick = event => {\n        event.preventDefault(); // handle odd case for Safari and Firefox which\n        // don't give the button the focus properly.\n\n        /* istanbul ignore if (can't reasonably test this) */\n\n        if (this.props.environment.document.activeElement === this.props.environment.document.body) {\n          event.target.focus();\n        } // to simplify testing components that use downshift, we'll not wrap this in a setTimeout\n        // if the NODE_ENV is test. With the proper build system, this should be dead code eliminated\n        // when building for production and should therefore have no impact on production code.\n\n        if (process.env.NODE_ENV === 'test') {\n          this.toggleMenu({\n            type: clickButton\n          });\n        } else {\n          // Ensure that toggle of menu occurs after the potential blur event in iOS\n          this.internalSetTimeout(() => this.toggleMenu({\n            type: clickButton\n          }));\n        }\n      };\n      this.buttonHandleBlur = event => {\n        const blurTarget = event.target; // Save blur target for comparison with activeElement later\n        // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not body element\n\n        this.internalSetTimeout(() => {\n          if (!this.isMouseDown && (this.props.environment.document.activeElement == null || this.props.environment.document.activeElement.id !== this.inputId) && this.props.environment.document.activeElement !== blurTarget // Do nothing if we refocus the same element again (to solve issue in Safari on iOS)\n          ) {\n            this.reset({\n              type: blurButton\n            });\n          }\n        });\n      };\n      this.getLabelProps = props => {\n        return {\n          htmlFor: this.inputId,\n          id: this.labelId,\n          ...props\n        };\n      };\n      this.getInputProps = function (_temp4) {\n        let {\n          onKeyDown,\n          onBlur,\n          onChange,\n          onInput,\n          onChangeText,\n          ...rest\n        } = _temp4 === void 0 ? {} : _temp4;\n        let onChangeKey;\n        let eventHandlers = {};\n        /* istanbul ignore next (preact) */\n\n        {\n          onChangeKey = 'onChange';\n        }\n        const {\n          inputValue,\n          isOpen,\n          highlightedIndex\n        } = _this.getState();\n        if (!rest.disabled) {\n          eventHandlers = {\n            [onChangeKey]: callAllEventHandlers(onChange, onInput, _this.inputHandleChange),\n            onKeyDown: callAllEventHandlers(onKeyDown, _this.inputHandleKeyDown),\n            onBlur: callAllEventHandlers(onBlur, _this.inputHandleBlur)\n          };\n        }\n        return {\n          'aria-autocomplete': 'list',\n          'aria-activedescendant': isOpen && typeof highlightedIndex === 'number' && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : null,\n          'aria-controls': isOpen ? _this.menuId : null,\n          'aria-labelledby': _this.labelId,\n          // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion\n          // revert back since autocomplete=\"nope\" is ignored on latest Chrome and Opera\n          autoComplete: 'off',\n          value: inputValue,\n          id: _this.inputId,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n      this.inputHandleKeyDown = event => {\n        const key = normalizeArrowKey(event);\n        if (key && this.inputKeyDownHandlers[key]) {\n          this.inputKeyDownHandlers[key].call(this, event);\n        }\n      };\n      this.inputHandleChange = event => {\n        this.internalSetState({\n          type: changeInput,\n          isOpen: true,\n          inputValue: event.target.value,\n          highlightedIndex: this.props.defaultHighlightedIndex\n        });\n      };\n      this.inputHandleBlur = () => {\n        // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not the body element\n        this.internalSetTimeout(() => {\n          const downshiftButtonIsActive = this.props.environment.document && !!this.props.environment.document.activeElement && !!this.props.environment.document.activeElement.dataset && this.props.environment.document.activeElement.dataset.toggle && this._rootNode && this._rootNode.contains(this.props.environment.document.activeElement);\n          if (!this.isMouseDown && !downshiftButtonIsActive) {\n            this.reset({\n              type: blurInput\n            });\n          }\n        });\n      };\n      this.menuRef = node => {\n        this._menuNode = node;\n      };\n      this.getMenuProps = function (_temp5, _temp6) {\n        let {\n          refKey = 'ref',\n          ref,\n          ...props\n        } = _temp5 === void 0 ? {} : _temp5;\n        let {\n          suppressRefError = false\n        } = _temp6 === void 0 ? {} : _temp6;\n        _this.getMenuProps.called = true;\n        _this.getMenuProps.refKey = refKey;\n        _this.getMenuProps.suppressRefError = suppressRefError;\n        return {\n          [refKey]: handleRefs(ref, _this.menuRef),\n          role: 'listbox',\n          'aria-labelledby': props && props['aria-label'] ? null : _this.labelId,\n          id: _this.menuId,\n          ...props\n        };\n      };\n      this.getItemProps = function (_temp7) {\n        let {\n          onMouseMove,\n          onMouseDown,\n          onClick,\n          onPress,\n          index,\n          item = process.env.NODE_ENV === 'production' ? /* istanbul ignore next */\n          undefined : requiredProp('getItemProps', 'item'),\n          ...rest\n        } = _temp7 === void 0 ? {} : _temp7;\n        if (index === undefined) {\n          _this.items.push(item);\n          index = _this.items.indexOf(item);\n        } else {\n          _this.items[index] = item;\n        }\n        const onSelectKey = 'onClick';\n        const customClickHandler = onClick;\n        const enabledEventHandlers = {\n          // onMouseMove is used over onMouseEnter here. onMouseMove\n          // is only triggered on actual mouse movement while onMouseEnter\n          // can fire on DOM changes, interrupting keyboard navigation\n          onMouseMove: callAllEventHandlers(onMouseMove, () => {\n            if (index === _this.getState().highlightedIndex) {\n              return;\n            }\n            _this.setHighlightedIndex(index, {\n              type: itemMouseEnter\n            }); // We never want to manually scroll when changing state based\n            // on `onMouseMove` because we will be moving the element out\n            // from under the user which is currently scrolling/moving the\n            // cursor\n\n            _this.avoidScrolling = true;\n            _this.internalSetTimeout(() => _this.avoidScrolling = false, 250);\n          }),\n          onMouseDown: callAllEventHandlers(onMouseDown, event => {\n            // This prevents the activeElement from being changed\n            // to the item so it can remain with the current activeElement\n            // which is a more common use case.\n            event.preventDefault();\n          }),\n          [onSelectKey]: callAllEventHandlers(customClickHandler, () => {\n            _this.selectItemAtIndex(index, {\n              type: clickItem\n            });\n          })\n        }; // Passing down the onMouseDown handler to prevent redirect\n        // of the activeElement if clicking on disabled items\n\n        const eventHandlers = rest.disabled ? {\n          onMouseDown: enabledEventHandlers.onMouseDown\n        } : enabledEventHandlers;\n        return {\n          id: _this.getItemId(index),\n          role: 'option',\n          'aria-selected': _this.getState().highlightedIndex === index,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n      this.clearItems = () => {\n        this.items = [];\n      };\n      this.reset = function (otherStateToSet, cb) {\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n        otherStateToSet = pickState(otherStateToSet);\n        _this.internalSetState(_ref => {\n          let {\n            selectedItem\n          } = _ref;\n          return {\n            isOpen: _this.props.defaultIsOpen,\n            highlightedIndex: _this.props.defaultHighlightedIndex,\n            inputValue: _this.props.itemToString(selectedItem),\n            ...otherStateToSet\n          };\n        }, cb);\n      };\n      this.toggleMenu = function (otherStateToSet, cb) {\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n        otherStateToSet = pickState(otherStateToSet);\n        _this.internalSetState(_ref2 => {\n          let {\n            isOpen\n          } = _ref2;\n          return {\n            isOpen: !isOpen,\n            ...(isOpen && {\n              highlightedIndex: _this.props.defaultHighlightedIndex\n            }),\n            ...otherStateToSet\n          };\n        }, () => {\n          const {\n            isOpen,\n            highlightedIndex\n          } = _this.getState();\n          if (isOpen) {\n            if (_this.getItemCount() > 0 && typeof highlightedIndex === 'number') {\n              _this.setHighlightedIndex(highlightedIndex, otherStateToSet);\n            }\n          }\n          cbToCb(cb)();\n        });\n      };\n      this.openMenu = cb => {\n        this.internalSetState({\n          isOpen: true\n        }, cb);\n      };\n      this.closeMenu = cb => {\n        this.internalSetState({\n          isOpen: false\n        }, cb);\n      };\n      this.updateStatus = debounce(() => {\n        const state = this.getState();\n        const item = this.items[state.highlightedIndex];\n        const resultCount = this.getItemCount();\n        const status = this.props.getA11yStatusMessage({\n          itemToString: this.props.itemToString,\n          previousResultCount: this.previousResultCount,\n          resultCount,\n          highlightedItem: item,\n          ...state\n        });\n        this.previousResultCount = resultCount;\n        setStatus(status, this.props.environment.document);\n      }, 200);\n      // fancy destructuring + defaults + aliases\n      // this basically says each value of state should either be set to\n      // the initial value or the default value if the initial value is not provided\n      const {\n        defaultHighlightedIndex,\n        initialHighlightedIndex: _highlightedIndex = defaultHighlightedIndex,\n        defaultIsOpen,\n        initialIsOpen: _isOpen = defaultIsOpen,\n        initialInputValue: _inputValue = '',\n        initialSelectedItem: _selectedItem = null\n      } = this.props;\n      const _state = this.getState({\n        highlightedIndex: _highlightedIndex,\n        isOpen: _isOpen,\n        inputValue: _inputValue,\n        selectedItem: _selectedItem\n      });\n      if (_state.selectedItem != null && this.props.initialInputValue === undefined) {\n        _state.inputValue = this.props.itemToString(_state.selectedItem);\n      }\n      this.state = _state;\n    }\n\n    /**\n     * Clear all running timeouts\n     */\n    internalClearTimeouts() {\n      this.timeoutIds.forEach(id => {\n        clearTimeout(id);\n      });\n      this.timeoutIds = [];\n    }\n    /**\n     * Gets the state based on internal state or props\n     * If a state value is passed via props, then that\n     * is the value given, otherwise it's retrieved from\n     * stateToMerge\n     *\n     * @param {Object} stateToMerge defaults to this.state\n     * @return {Object} the state\n     */\n\n    getState(stateToMerge) {\n      if (stateToMerge === void 0) {\n        stateToMerge = this.state;\n      }\n      return getState(stateToMerge, this.props);\n    }\n    getItemCount() {\n      // things read better this way. They're in priority order:\n      // 1. `this.itemCount`\n      // 2. `this.props.itemCount`\n      // 3. `this.items.length`\n      let itemCount = this.items.length;\n      if (this.itemCount != null) {\n        itemCount = this.itemCount;\n      } else if (this.props.itemCount !== undefined) {\n        itemCount = this.props.itemCount;\n      }\n      return itemCount;\n    }\n    getItemNodeFromIndex(index) {\n      return this.props.environment.document.getElementById(this.getItemId(index));\n    }\n    scrollHighlightedItemIntoView() {\n      /* istanbul ignore else (react-native) */\n      {\n        const node = this.getItemNodeFromIndex(this.getState().highlightedIndex);\n        this.props.scrollIntoView(node, this._menuNode);\n      }\n    }\n    moveHighlightedIndex(amount, otherStateToSet) {\n      const itemCount = this.getItemCount();\n      const {\n        highlightedIndex\n      } = this.getState();\n      if (itemCount > 0) {\n        const nextHighlightedIndex = getNextWrappingIndex(amount, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));\n        this.setHighlightedIndex(nextHighlightedIndex, otherStateToSet);\n      }\n    }\n    getStateAndHelpers() {\n      const {\n        highlightedIndex,\n        inputValue,\n        selectedItem,\n        isOpen\n      } = this.getState();\n      const {\n        itemToString\n      } = this.props;\n      const {\n        id\n      } = this;\n      const {\n        getRootProps,\n        getToggleButtonProps,\n        getLabelProps,\n        getMenuProps,\n        getInputProps,\n        getItemProps,\n        openMenu,\n        closeMenu,\n        toggleMenu,\n        selectItem,\n        selectItemAtIndex,\n        selectHighlightedItem,\n        setHighlightedIndex,\n        clearSelection,\n        clearItems,\n        reset,\n        setItemCount,\n        unsetItemCount,\n        internalSetState: setState\n      } = this;\n      return {\n        // prop getters\n        getRootProps,\n        getToggleButtonProps,\n        getLabelProps,\n        getMenuProps,\n        getInputProps,\n        getItemProps,\n        // actions\n        reset,\n        openMenu,\n        closeMenu,\n        toggleMenu,\n        selectItem,\n        selectItemAtIndex,\n        selectHighlightedItem,\n        setHighlightedIndex,\n        clearSelection,\n        clearItems,\n        setItemCount,\n        unsetItemCount,\n        setState,\n        // props\n        itemToString,\n        // derived\n        id,\n        // state\n        highlightedIndex,\n        inputValue,\n        isOpen,\n        selectedItem\n      };\n    } //////////////////////////// ROOT\n\n    componentDidMount() {\n      /* istanbul ignore if (react-native) */\n      if (process.env.NODE_ENV !== 'production' && !false && this.getMenuProps.called && !this.getMenuProps.suppressRefError) {\n        validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);\n      }\n      /* istanbul ignore if (react-native) */\n\n      {\n        // this.isMouseDown helps us track whether the mouse is currently held down.\n        // This is useful when the user clicks on an item in the list, but holds the mouse\n        // down long enough for the list to disappear (because the blur event fires on the input)\n        // this.isMouseDown is used in the blur handler on the input to determine whether the blur event should\n        // trigger hiding the menu.\n        const onMouseDown = () => {\n          this.isMouseDown = true;\n        };\n        const onMouseUp = event => {\n          this.isMouseDown = false; // if the target element or the activeElement is within a downshift node\n          // then we don't want to reset downshift\n\n          const contextWithinDownshift = targetWithinDownshift(event.target, [this._rootNode, this._menuNode], this.props.environment);\n          if (!contextWithinDownshift && this.getState().isOpen) {\n            this.reset({\n              type: mouseUp\n            }, () => this.props.onOuterClick(this.getStateAndHelpers()));\n          }\n        }; // Touching an element in iOS gives focus and hover states, but touching out of\n        // the element will remove hover, and persist the focus state, resulting in the\n        // blur event not being triggered.\n        // this.isTouchMove helps us track whether the user is tapping or swiping on a touch screen.\n        // If the user taps outside of Downshift, the component should be reset,\n        // but not if the user is swiping\n\n        const onTouchStart = () => {\n          this.isTouchMove = false;\n        };\n        const onTouchMove = () => {\n          this.isTouchMove = true;\n        };\n        const onTouchEnd = event => {\n          const contextWithinDownshift = targetWithinDownshift(event.target, [this._rootNode, this._menuNode], this.props.environment, false);\n          if (!this.isTouchMove && !contextWithinDownshift && this.getState().isOpen) {\n            this.reset({\n              type: touchEnd\n            }, () => this.props.onOuterClick(this.getStateAndHelpers()));\n          }\n        };\n        const {\n          environment\n        } = this.props;\n        environment.addEventListener('mousedown', onMouseDown);\n        environment.addEventListener('mouseup', onMouseUp);\n        environment.addEventListener('touchstart', onTouchStart);\n        environment.addEventListener('touchmove', onTouchMove);\n        environment.addEventListener('touchend', onTouchEnd);\n        this.cleanup = () => {\n          this.internalClearTimeouts();\n          this.updateStatus.cancel();\n          environment.removeEventListener('mousedown', onMouseDown);\n          environment.removeEventListener('mouseup', onMouseUp);\n          environment.removeEventListener('touchstart', onTouchStart);\n          environment.removeEventListener('touchmove', onTouchMove);\n          environment.removeEventListener('touchend', onTouchEnd);\n        };\n      }\n    }\n    shouldScroll(prevState, prevProps) {\n      const {\n        highlightedIndex: currentHighlightedIndex\n      } = this.props.highlightedIndex === undefined ? this.getState() : this.props;\n      const {\n        highlightedIndex: prevHighlightedIndex\n      } = prevProps.highlightedIndex === undefined ? prevState : prevProps;\n      const scrollWhenOpen = currentHighlightedIndex && this.getState().isOpen && !prevState.isOpen;\n      const scrollWhenNavigating = currentHighlightedIndex !== prevHighlightedIndex;\n      return scrollWhenOpen || scrollWhenNavigating;\n    }\n    componentDidUpdate(prevProps, prevState) {\n      if (process.env.NODE_ENV !== 'production') {\n        validateControlledUnchanged(this.state, prevProps, this.props);\n        /* istanbul ignore if (react-native) */\n\n        if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {\n          validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);\n        }\n      }\n      if (isControlledProp(this.props, 'selectedItem') && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {\n        this.internalSetState({\n          type: controlledPropUpdatedSelectedItem,\n          inputValue: this.props.itemToString(this.props.selectedItem)\n        });\n      }\n      if (!this.avoidScrolling && this.shouldScroll(prevState, prevProps)) {\n        this.scrollHighlightedItemIntoView();\n      }\n      /* istanbul ignore else (react-native) */\n\n      {\n        this.updateStatus();\n      }\n    }\n    componentWillUnmount() {\n      this.cleanup(); // avoids memory leak\n    }\n\n    render() {\n      const children = unwrapArray(this.props.children, noop); // because the items are rerendered every time we call the children\n      // we clear this out each render and it will be populated again as\n      // getItemProps is called.\n\n      this.clearItems(); // we reset this so we know whether the user calls getRootProps during\n      // this render. If they do then we don't need to do anything,\n      // if they don't then we need to clone the element they return and\n      // apply the props for them.\n\n      this.getRootProps.called = false;\n      this.getRootProps.refKey = undefined;\n      this.getRootProps.suppressRefError = undefined; // we do something similar for getMenuProps\n\n      this.getMenuProps.called = false;\n      this.getMenuProps.refKey = undefined;\n      this.getMenuProps.suppressRefError = undefined; // we do something similar for getLabelProps\n\n      this.getLabelProps.called = false; // and something similar for getInputProps\n\n      this.getInputProps.called = false;\n      const element = unwrapArray(children(this.getStateAndHelpers()));\n      if (!element) {\n        return null;\n      }\n      if (this.getRootProps.called || this.props.suppressRefError) {\n        if (process.env.NODE_ENV !== 'production' && !this.getRootProps.suppressRefError && !this.props.suppressRefError) {\n          validateGetRootPropsCalledCorrectly(element, this.getRootProps);\n        }\n        return element;\n      } else if (isDOMElement(element)) {\n        // they didn't apply the root props, but we can clone\n        // this and apply the props ourselves\n        return /*#__PURE__*/cloneElement(element, this.getRootProps(getElementProps(element)));\n      }\n      /* istanbul ignore else */\n\n      if (process.env.NODE_ENV !== 'production') {\n        // they didn't apply the root props, but they need to\n        // otherwise we can't query around the autocomplete\n        throw new Error('downshift: If you return a non-DOM element, you must apply the getRootProps function');\n      }\n      /* istanbul ignore next */\n\n      return undefined;\n    }\n  }\n  Downshift.defaultProps = {\n    defaultHighlightedIndex: null,\n    defaultIsOpen: false,\n    getA11yStatusMessage: getA11yStatusMessage$1,\n    itemToString: i => {\n      if (i == null) {\n        return '';\n      }\n      if (process.env.NODE_ENV !== 'production' && isPlainObject(i) && !i.hasOwnProperty('toString')) {\n        // eslint-disable-next-line no-console\n        console.warn('downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.', 'The object that was passed:', i);\n      }\n      return String(i);\n    },\n    onStateChange: noop,\n    onInputValueChange: noop,\n    onUserAction: noop,\n    onChange: noop,\n    onSelect: noop,\n    onOuterClick: noop,\n    selectedItemChanged: (prevItem, item) => prevItem !== item,\n    environment: /* istanbul ignore next (ssr) */\n    typeof window === 'undefined' ? {} : window,\n    stateReducer: (state, stateToSet) => stateToSet,\n    suppressRefError: false,\n    scrollIntoView\n  };\n  Downshift.stateChangeTypes = stateChangeTypes$3;\n  return Downshift;\n})();\nprocess.env.NODE_ENV !== \"production\" ? Downshift.propTypes = {\n  children: PropTypes.func,\n  defaultHighlightedIndex: PropTypes.number,\n  defaultIsOpen: PropTypes.bool,\n  initialHighlightedIndex: PropTypes.number,\n  initialSelectedItem: PropTypes.any,\n  initialInputValue: PropTypes.string,\n  initialIsOpen: PropTypes.bool,\n  getA11yStatusMessage: PropTypes.func,\n  itemToString: PropTypes.func,\n  onChange: PropTypes.func,\n  onSelect: PropTypes.func,\n  onStateChange: PropTypes.func,\n  onInputValueChange: PropTypes.func,\n  onUserAction: PropTypes.func,\n  onOuterClick: PropTypes.func,\n  selectedItemChanged: PropTypes.func,\n  stateReducer: PropTypes.func,\n  itemCount: PropTypes.number,\n  id: PropTypes.string,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  }),\n  suppressRefError: PropTypes.bool,\n  scrollIntoView: PropTypes.func,\n  // things we keep in state for uncontrolled components\n  // but can accept as props for controlled components\n\n  /* eslint-disable react/no-unused-prop-types */\n  selectedItem: PropTypes.any,\n  isOpen: PropTypes.bool,\n  inputValue: PropTypes.string,\n  highlightedIndex: PropTypes.number,\n  labelId: PropTypes.string,\n  inputId: PropTypes.string,\n  menuId: PropTypes.string,\n  getItemId: PropTypes.func\n  /* eslint-enable react/no-unused-prop-types */\n} : void 0;\nvar Downshift$1 = Downshift;\nfunction validateGetMenuPropsCalledCorrectly(node, _ref3) {\n  let {\n    refKey\n  } = _ref3;\n  if (!node) {\n    // eslint-disable-next-line no-console\n    console.error(`downshift: The ref prop \"${refKey}\" from getMenuProps was not applied correctly on your menu element.`);\n  }\n}\nfunction validateGetRootPropsCalledCorrectly(element, _ref4) {\n  let {\n    refKey\n  } = _ref4;\n  const refKeySpecified = refKey !== 'ref';\n  const isComposite = !isDOMElement(element);\n  if (isComposite && !refKeySpecified && !isForwardRef(element)) {\n    // eslint-disable-next-line no-console\n    console.error('downshift: You returned a non-DOM element. You must specify a refKey in getRootProps');\n  } else if (!isComposite && refKeySpecified) {\n    // eslint-disable-next-line no-console\n    console.error(`downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified \"${refKey}\"`);\n  }\n  if (!isForwardRef(element) && !getElementProps(element)[refKey]) {\n    // eslint-disable-next-line no-console\n    console.error(`downshift: You must apply the ref prop \"${refKey}\" from getRootProps onto your root element.`);\n  }\n}\nconst dropdownDefaultStateValues = {\n  highlightedIndex: -1,\n  isOpen: false,\n  selectedItem: null,\n  inputValue: ''\n};\nfunction callOnChangeProps(action, state, newState) {\n  const {\n    props,\n    type\n  } = action;\n  const changes = {};\n  Object.keys(state).forEach(key => {\n    invokeOnChangeHandler(key, action, state, newState);\n    if (newState[key] !== state[key]) {\n      changes[key] = newState[key];\n    }\n  });\n  if (props.onStateChange && Object.keys(changes).length) {\n    props.onStateChange({\n      type,\n      ...changes\n    });\n  }\n}\nfunction invokeOnChangeHandler(key, action, state, newState) {\n  const {\n    props,\n    type\n  } = action;\n  const handler = `on${capitalizeString(key)}Change`;\n  if (props[handler] && newState[key] !== undefined && newState[key] !== state[key]) {\n    props[handler]({\n      type,\n      ...newState\n    });\n  }\n}\n/**\n * Default state reducer that returns the changes.\n *\n * @param {Object} s state.\n * @param {Object} a action with changes.\n * @returns {Object} changes.\n */\n\nfunction stateReducer(s, a) {\n  return a.changes;\n}\n/**\n * Returns a message to be added to aria-live region when item is selected.\n *\n * @param {Object} selectionParameters Parameters required to build the message.\n * @returns {string} The a11y message.\n */\n\nfunction getA11ySelectionMessage(selectionParameters) {\n  const {\n    selectedItem,\n    itemToString: itemToStringLocal\n  } = selectionParameters;\n  return selectedItem ? `${itemToStringLocal(selectedItem)} has been selected.` : '';\n}\n/**\n * Debounced call for updating the a11y message.\n */\n\nconst updateA11yStatus = debounce((getA11yMessage, document) => {\n  setStatus(getA11yMessage(), document);\n}, 200); // istanbul ignore next\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? useLayoutEffect : useEffect;\nfunction useElementIds(_ref) {\n  let {\n    id = `downshift-${generateId()}`,\n    labelId,\n    menuId,\n    getItemId,\n    toggleButtonId,\n    inputId\n  } = _ref;\n  const elementIdsRef = useRef({\n    labelId: labelId || `${id}-label`,\n    menuId: menuId || `${id}-menu`,\n    getItemId: getItemId || (index => `${id}-item-${index}`),\n    toggleButtonId: toggleButtonId || `${id}-toggle-button`,\n    inputId: inputId || `${id}-input`\n  });\n  return elementIdsRef.current;\n}\nfunction getItemIndex(index, item, items) {\n  if (index !== undefined) {\n    return index;\n  }\n  if (items.length === 0) {\n    return -1;\n  }\n  return items.indexOf(item);\n}\nfunction itemToString(item) {\n  return item ? String(item) : '';\n}\nfunction isAcceptedCharacterKey(key) {\n  return /^\\S{1}$/.test(key);\n}\nfunction capitalizeString(string) {\n  return `${string.slice(0, 1).toUpperCase()}${string.slice(1)}`;\n}\nfunction useLatestRef(val) {\n  const ref = useRef(val); // technically this is not \"concurrent mode safe\" because we're manipulating\n  // the value during render (so it's not idempotent). However, the places this\n  // hook is used is to support memoizing callbacks which will be called\n  // *during* render, so we need the latest values *during* render.\n  // If not for this, then we'd probably want to use useLayoutEffect instead.\n\n  ref.current = val;\n  return ref;\n}\n/**\n * Computes the controlled state using a the previous state, props,\n * two reducers, one from downshift and an optional one from the user.\n * Also calls the onChange handlers for state values that have changed.\n *\n * @param {Function} reducer Reducer function from downshift.\n * @param {Object} initialState Initial state of the hook.\n * @param {Object} props The hook props.\n * @returns {Array} An array with the state and an action dispatcher.\n */\n\nfunction useEnhancedReducer(reducer, initialState, props) {\n  const prevStateRef = useRef();\n  const actionRef = useRef();\n  const enhancedReducer = useCallback((state, action) => {\n    actionRef.current = action;\n    state = getState(state, action.props);\n    const changes = reducer(state, action);\n    const newState = action.props.stateReducer(state, {\n      ...action,\n      changes\n    });\n    return newState;\n  }, [reducer]);\n  const [state, dispatch] = useReducer(enhancedReducer, initialState);\n  const propsRef = useLatestRef(props);\n  const dispatchWithProps = useCallback(action => dispatch({\n    props: propsRef.current,\n    ...action\n  }), [propsRef]);\n  const action = actionRef.current;\n  useEffect(() => {\n    if (action && prevStateRef.current && prevStateRef.current !== state) {\n      callOnChangeProps(action, getState(prevStateRef.current, action.props), state);\n    }\n    prevStateRef.current = state;\n  }, [state, props, action]);\n  return [state, dispatchWithProps];\n}\n/**\n * Wraps the useEnhancedReducer and applies the controlled prop values before\n * returning the new state.\n *\n * @param {Function} reducer Reducer function from downshift.\n * @param {Object} initialState Initial state of the hook.\n * @param {Object} props The hook props.\n * @returns {Array} An array with the state and an action dispatcher.\n */\n\nfunction useControlledReducer$1(reducer, initialState, props) {\n  const [state, dispatch] = useEnhancedReducer(reducer, initialState, props);\n  return [getState(state, props), dispatch];\n}\nconst defaultProps$3 = {\n  itemToString,\n  stateReducer,\n  getA11ySelectionMessage,\n  scrollIntoView,\n  circularNavigation: false,\n  environment: /* istanbul ignore next (ssr) */\n  typeof window === 'undefined' ? {} : window\n};\nfunction getDefaultValue$1(props, propKey, defaultStateValues) {\n  if (defaultStateValues === void 0) {\n    defaultStateValues = dropdownDefaultStateValues;\n  }\n  const defaultValue = props[`default${capitalizeString(propKey)}`];\n  if (defaultValue !== undefined) {\n    return defaultValue;\n  }\n  return defaultStateValues[propKey];\n}\nfunction getInitialValue$1(props, propKey, defaultStateValues) {\n  if (defaultStateValues === void 0) {\n    defaultStateValues = dropdownDefaultStateValues;\n  }\n  const value = props[propKey];\n  if (value !== undefined) {\n    return value;\n  }\n  const initialValue = props[`initial${capitalizeString(propKey)}`];\n  if (initialValue !== undefined) {\n    return initialValue;\n  }\n  return getDefaultValue$1(props, propKey, defaultStateValues);\n}\nfunction getInitialState$2(props) {\n  const selectedItem = getInitialValue$1(props, 'selectedItem');\n  const isOpen = getInitialValue$1(props, 'isOpen');\n  const highlightedIndex = getInitialValue$1(props, 'highlightedIndex');\n  const inputValue = getInitialValue$1(props, 'inputValue');\n  return {\n    highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.indexOf(selectedItem) : highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\nfunction getHighlightedIndexOnOpen(props, state, offset, getItemNodeFromIndex) {\n  const {\n    items,\n    initialHighlightedIndex,\n    defaultHighlightedIndex\n  } = props;\n  const {\n    selectedItem,\n    highlightedIndex\n  } = state;\n  if (items.length === 0) {\n    return -1;\n  } // initialHighlightedIndex will give value to highlightedIndex on initial state only.\n\n  if (initialHighlightedIndex !== undefined && highlightedIndex === initialHighlightedIndex) {\n    return initialHighlightedIndex;\n  }\n  if (defaultHighlightedIndex !== undefined) {\n    return defaultHighlightedIndex;\n  }\n  if (selectedItem) {\n    if (offset === 0) {\n      return items.indexOf(selectedItem);\n    }\n    return getNextWrappingIndex(offset, items.indexOf(selectedItem), items.length, getItemNodeFromIndex, false);\n  }\n  if (offset === 0) {\n    return -1;\n  }\n  return offset < 0 ? items.length - 1 : 0;\n}\n/**\n * Reuse the movement tracking of mouse and touch events.\n *\n * @param {boolean} isOpen Whether the dropdown is open or not.\n * @param {Array<Object>} downshiftElementRefs Downshift element refs to track movement (toggleButton, menu etc.)\n * @param {Object} environment Environment where component/hook exists.\n * @param {Function} handleBlur Handler on blur from mouse or touch.\n * @returns {Object} Ref containing whether mouseDown or touchMove event is happening\n */\n\nfunction useMouseAndTouchTracker(isOpen, downshiftElementRefs, environment, handleBlur) {\n  const mouseAndTouchTrackersRef = useRef({\n    isMouseDown: false,\n    isTouchMove: false\n  });\n  useEffect(() => {\n    // The same strategy for checking if a click occurred inside or outside downsift\n    // as in downshift.js.\n    const onMouseDown = () => {\n      mouseAndTouchTrackersRef.current.isMouseDown = true;\n    };\n    const onMouseUp = event => {\n      mouseAndTouchTrackersRef.current.isMouseDown = false;\n      if (isOpen && !targetWithinDownshift(event.target, downshiftElementRefs.map(ref => ref.current), environment)) {\n        handleBlur();\n      }\n    };\n    const onTouchStart = () => {\n      mouseAndTouchTrackersRef.current.isTouchMove = false;\n    };\n    const onTouchMove = () => {\n      mouseAndTouchTrackersRef.current.isTouchMove = true;\n    };\n    const onTouchEnd = event => {\n      if (isOpen && !mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event.target, downshiftElementRefs.map(ref => ref.current), environment, false)) {\n        handleBlur();\n      }\n    };\n    environment.addEventListener('mousedown', onMouseDown);\n    environment.addEventListener('mouseup', onMouseUp);\n    environment.addEventListener('touchstart', onTouchStart);\n    environment.addEventListener('touchmove', onTouchMove);\n    environment.addEventListener('touchend', onTouchEnd);\n    return function cleanup() {\n      environment.removeEventListener('mousedown', onMouseDown);\n      environment.removeEventListener('mouseup', onMouseUp);\n      environment.removeEventListener('touchstart', onTouchStart);\n      environment.removeEventListener('touchmove', onTouchMove);\n      environment.removeEventListener('touchend', onTouchEnd);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isOpen, environment]);\n  return mouseAndTouchTrackersRef;\n}\n/* istanbul ignore next */\n// eslint-disable-next-line import/no-mutable-exports\n\nlet useGetterPropsCalledChecker = () => noop;\n/**\n * Custom hook that checks if getter props are called correctly.\n *\n * @param  {...any} propKeys Getter prop names to be handled.\n * @returns {Function} Setter function called inside getter props to set call information.\n */\n\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  useGetterPropsCalledChecker = function () {\n    const isInitialMountRef = useRef(true);\n    for (var _len = arguments.length, propKeys = new Array(_len), _key = 0; _key < _len; _key++) {\n      propKeys[_key] = arguments[_key];\n    }\n    const getterPropsCalledRef = useRef(propKeys.reduce((acc, propKey) => {\n      acc[propKey] = {};\n      return acc;\n    }, {}));\n    useEffect(() => {\n      Object.keys(getterPropsCalledRef.current).forEach(propKey => {\n        const propCallInfo = getterPropsCalledRef.current[propKey];\n        if (isInitialMountRef.current) {\n          if (!Object.keys(propCallInfo).length) {\n            // eslint-disable-next-line no-console\n            console.error(`downshift: You forgot to call the ${propKey} getter function on your component / element.`);\n            return;\n          }\n        }\n        const {\n          suppressRefError,\n          refKey,\n          elementRef\n        } = propCallInfo;\n        if ((!elementRef || !elementRef.current) && !suppressRefError) {\n          // eslint-disable-next-line no-console\n          console.error(`downshift: The ref prop \"${refKey}\" from ${propKey} was not applied correctly on your element.`);\n        }\n      });\n      isInitialMountRef.current = false;\n    });\n    const setGetterPropCallInfo = useCallback((propKey, suppressRefError, refKey, elementRef) => {\n      getterPropsCalledRef.current[propKey] = {\n        suppressRefError,\n        refKey,\n        elementRef\n      };\n    }, []);\n    return setGetterPropCallInfo;\n  };\n}\nfunction useA11yMessageSetter(getA11yMessage, dependencyArray, _ref2) {\n  let {\n    isInitialMount,\n    highlightedIndex,\n    items,\n    environment,\n    ...rest\n  } = _ref2;\n  // Sets a11y status message on changes in state.\n  useEffect(() => {\n    if (isInitialMount || false) {\n      return;\n    }\n    updateA11yStatus(() => getA11yMessage({\n      highlightedIndex,\n      highlightedItem: items[highlightedIndex],\n      resultCount: items.length,\n      ...rest\n    }), environment.document); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, dependencyArray);\n}\nfunction useScrollIntoView(_ref3) {\n  let {\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    getItemNodeFromIndex,\n    menuElement,\n    scrollIntoView: scrollIntoViewProp\n  } = _ref3;\n  // used not to scroll on highlight by mouse.\n  const shouldScrollRef = useRef(true); // Scroll on highlighted item if change comes from keyboard.\n\n  useIsomorphicLayoutEffect(() => {\n    if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {\n      return;\n    }\n    if (shouldScrollRef.current === false) {\n      shouldScrollRef.current = true;\n    } else {\n      scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [highlightedIndex]);\n  return shouldScrollRef;\n} // eslint-disable-next-line import/no-mutable-exports\n\nlet useControlPropsValidator = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  useControlPropsValidator = _ref4 => {\n    let {\n      isInitialMount,\n      props,\n      state\n    } = _ref4;\n    // used for checking when props are moving from controlled to uncontrolled.\n    const prevPropsRef = useRef(props);\n    useEffect(() => {\n      if (isInitialMount) {\n        return;\n      }\n      validateControlledUnchanged(state, prevPropsRef.current, props);\n      prevPropsRef.current = props;\n    }, [state, props, isInitialMount]);\n  };\n}\n\n/* eslint-disable complexity */\n\nfunction downshiftCommonReducer(state, action, stateChangeTypes) {\n  const {\n    type,\n    props\n  } = action;\n  let changes;\n  switch (type) {\n    case stateChangeTypes.ItemMouseMove:\n      changes = {\n        highlightedIndex: action.disabled ? -1 : action.index\n      };\n      break;\n    case stateChangeTypes.MenuMouseLeave:\n      changes = {\n        highlightedIndex: -1\n      };\n      break;\n    case stateChangeTypes.ToggleButtonClick:\n    case stateChangeTypes.FunctionToggleMenu:\n      changes = {\n        isOpen: !state.isOpen,\n        highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)\n      };\n      break;\n    case stateChangeTypes.FunctionOpenMenu:\n      changes = {\n        isOpen: true,\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)\n      };\n      break;\n    case stateChangeTypes.FunctionCloseMenu:\n      changes = {\n        isOpen: false\n      };\n      break;\n    case stateChangeTypes.FunctionSetHighlightedIndex:\n      changes = {\n        highlightedIndex: action.highlightedIndex\n      };\n      break;\n    case stateChangeTypes.FunctionSetInputValue:\n      changes = {\n        inputValue: action.inputValue\n      };\n      break;\n    case stateChangeTypes.FunctionReset:\n      changes = {\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        selectedItem: getDefaultValue$1(props, 'selectedItem'),\n        inputValue: getDefaultValue$1(props, 'inputValue')\n      };\n      break;\n    default:\n      throw new Error('Reducer called without proper action type.');\n  }\n  return {\n    ...state,\n    ...changes\n  };\n}\n/* eslint-enable complexity */\n\nfunction getItemIndexByCharacterKey(_a) {\n  var keysSoFar = _a.keysSoFar,\n    highlightedIndex = _a.highlightedIndex,\n    items = _a.items,\n    itemToString = _a.itemToString,\n    getItemNodeFromIndex = _a.getItemNodeFromIndex;\n  var lowerCasedKeysSoFar = keysSoFar.toLowerCase();\n  for (var index = 0; index < items.length; index++) {\n    var offsetIndex = (index + highlightedIndex + 1) % items.length;\n    var item = items[offsetIndex];\n    if (item !== undefined && itemToString(item).toLowerCase().startsWith(lowerCasedKeysSoFar)) {\n      var element = getItemNodeFromIndex(offsetIndex);\n      if (!(element === null || element === void 0 ? void 0 : element.hasAttribute('disabled'))) {\n        return offsetIndex;\n      }\n    }\n  }\n  return highlightedIndex;\n}\nvar propTypes$2 = {\n  items: PropTypes.array.isRequired,\n  itemToString: PropTypes.func,\n  getA11yStatusMessage: PropTypes.func,\n  getA11ySelectionMessage: PropTypes.func,\n  circularNavigation: PropTypes.bool,\n  highlightedIndex: PropTypes.number,\n  defaultHighlightedIndex: PropTypes.number,\n  initialHighlightedIndex: PropTypes.number,\n  isOpen: PropTypes.bool,\n  defaultIsOpen: PropTypes.bool,\n  initialIsOpen: PropTypes.bool,\n  selectedItem: PropTypes.any,\n  initialSelectedItem: PropTypes.any,\n  defaultSelectedItem: PropTypes.any,\n  id: PropTypes.string,\n  labelId: PropTypes.string,\n  menuId: PropTypes.string,\n  getItemId: PropTypes.func,\n  toggleButtonId: PropTypes.string,\n  stateReducer: PropTypes.func,\n  onSelectedItemChange: PropTypes.func,\n  onHighlightedIndexChange: PropTypes.func,\n  onStateChange: PropTypes.func,\n  onIsOpenChange: PropTypes.func,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  })\n};\n/**\n * Default implementation for status message. Only added when menu is open.\n * Will specift if there are results in the list, and if so, how many,\n * and what keys are relevant.\n *\n * @param {Object} param the downshift state and other relevant properties\n * @return {String} the a11y status message\n */\nfunction getA11yStatusMessage(_a) {\n  var isOpen = _a.isOpen,\n    resultCount = _a.resultCount,\n    previousResultCount = _a.previousResultCount;\n  if (!isOpen) {\n    return '';\n  }\n  if (!resultCount) {\n    return 'No results are available.';\n  }\n  if (resultCount !== previousResultCount) {\n    return \"\".concat(resultCount, \" result\").concat(resultCount === 1 ? ' is' : 's are', \" available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.\");\n  }\n  return '';\n}\nvar defaultProps$2 = __assign(__assign({}, defaultProps$3), {\n  getA11yStatusMessage: getA11yStatusMessage\n});\n// eslint-disable-next-line import/no-mutable-exports\nvar validatePropTypes$2 = noop;\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n  validatePropTypes$2 = function (options, caller) {\n    PropTypes.checkPropTypes(propTypes$2, options, 'prop', caller.name);\n  };\n}\nconst MenuKeyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_arrow_down__' : 0;\nconst MenuKeyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_arrow_up__' : 1;\nconst MenuKeyDownEscape = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_escape__' : 2;\nconst MenuKeyDownHome = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_home__' : 3;\nconst MenuKeyDownEnd = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_end__' : 4;\nconst MenuKeyDownEnter = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_enter__' : 5;\nconst MenuKeyDownSpaceButton = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_space_button__' : 6;\nconst MenuKeyDownCharacter = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_character__' : 7;\nconst MenuBlur = process.env.NODE_ENV !== \"production\" ? '__menu_blur__' : 8;\nconst MenuMouseLeave$1 = process.env.NODE_ENV !== \"production\" ? '__menu_mouse_leave__' : 9;\nconst ItemMouseMove$1 = process.env.NODE_ENV !== \"production\" ? '__item_mouse_move__' : 10;\nconst ItemClick$1 = process.env.NODE_ENV !== \"production\" ? '__item_click__' : 11;\nconst ToggleButtonClick$1 = process.env.NODE_ENV !== \"production\" ? '__togglebutton_click__' : 12;\nconst ToggleButtonKeyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__togglebutton_keydown_arrow_down__' : 13;\nconst ToggleButtonKeyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__togglebutton_keydown_arrow_up__' : 14;\nconst ToggleButtonKeyDownCharacter = process.env.NODE_ENV !== \"production\" ? '__togglebutton_keydown_character__' : 15;\nconst FunctionToggleMenu$1 = process.env.NODE_ENV !== \"production\" ? '__function_toggle_menu__' : 16;\nconst FunctionOpenMenu$1 = process.env.NODE_ENV !== \"production\" ? '__function_open_menu__' : 17;\nconst FunctionCloseMenu$1 = process.env.NODE_ENV !== \"production\" ? '__function_close_menu__' : 18;\nconst FunctionSetHighlightedIndex$1 = process.env.NODE_ENV !== \"production\" ? '__function_set_highlighted_index__' : 19;\nconst FunctionSelectItem$1 = process.env.NODE_ENV !== \"production\" ? '__function_select_item__' : 20;\nconst FunctionSetInputValue$1 = process.env.NODE_ENV !== \"production\" ? '__function_set_input_value__' : 21;\nconst FunctionReset$2 = process.env.NODE_ENV !== \"production\" ? '__function_reset__' : 22;\nvar stateChangeTypes$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  MenuKeyDownArrowDown: MenuKeyDownArrowDown,\n  MenuKeyDownArrowUp: MenuKeyDownArrowUp,\n  MenuKeyDownEscape: MenuKeyDownEscape,\n  MenuKeyDownHome: MenuKeyDownHome,\n  MenuKeyDownEnd: MenuKeyDownEnd,\n  MenuKeyDownEnter: MenuKeyDownEnter,\n  MenuKeyDownSpaceButton: MenuKeyDownSpaceButton,\n  MenuKeyDownCharacter: MenuKeyDownCharacter,\n  MenuBlur: MenuBlur,\n  MenuMouseLeave: MenuMouseLeave$1,\n  ItemMouseMove: ItemMouseMove$1,\n  ItemClick: ItemClick$1,\n  ToggleButtonClick: ToggleButtonClick$1,\n  ToggleButtonKeyDownArrowDown: ToggleButtonKeyDownArrowDown,\n  ToggleButtonKeyDownArrowUp: ToggleButtonKeyDownArrowUp,\n  ToggleButtonKeyDownCharacter: ToggleButtonKeyDownCharacter,\n  FunctionToggleMenu: FunctionToggleMenu$1,\n  FunctionOpenMenu: FunctionOpenMenu$1,\n  FunctionCloseMenu: FunctionCloseMenu$1,\n  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex$1,\n  FunctionSelectItem: FunctionSelectItem$1,\n  FunctionSetInputValue: FunctionSetInputValue$1,\n  FunctionReset: FunctionReset$2\n});\n\n/* eslint-disable complexity */\n\nfunction downshiftSelectReducer(state, action) {\n  const {\n    type,\n    props,\n    shiftKey\n  } = action;\n  let changes;\n  switch (type) {\n    case ItemClick$1:\n      changes = {\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        selectedItem: props.items[action.index]\n      };\n      break;\n    case ToggleButtonKeyDownCharacter:\n      {\n        const lowercasedKey = action.key;\n        const inputValue = `${state.inputValue}${lowercasedKey}`;\n        const itemIndex = getItemIndexByCharacterKey({\n          keysSoFar: inputValue,\n          highlightedIndex: state.selectedItem ? props.items.indexOf(state.selectedItem) : -1,\n          items: props.items,\n          itemToString: props.itemToString,\n          getItemNodeFromIndex: action.getItemNodeFromIndex\n        });\n        changes = {\n          inputValue,\n          ...(itemIndex >= 0 && {\n            selectedItem: props.items[itemIndex]\n          })\n        };\n      }\n      break;\n    case ToggleButtonKeyDownArrowDown:\n      changes = {\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),\n        isOpen: true\n      };\n      break;\n    case ToggleButtonKeyDownArrowUp:\n      changes = {\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),\n        isOpen: true\n      };\n      break;\n    case MenuKeyDownEnter:\n    case MenuKeyDownSpaceButton:\n      changes = {\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        ...(state.highlightedIndex >= 0 && {\n          selectedItem: props.items[state.highlightedIndex]\n        })\n      };\n      break;\n    case MenuKeyDownHome:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n    case MenuKeyDownEnd:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n    case MenuKeyDownEscape:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1\n      };\n      break;\n    case MenuBlur:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1\n      };\n      break;\n    case MenuKeyDownCharacter:\n      {\n        const lowercasedKey = action.key;\n        const inputValue = `${state.inputValue}${lowercasedKey}`;\n        const highlightedIndex = getItemIndexByCharacterKey({\n          keysSoFar: inputValue,\n          highlightedIndex: state.highlightedIndex,\n          items: props.items,\n          itemToString: props.itemToString,\n          getItemNodeFromIndex: action.getItemNodeFromIndex\n        });\n        changes = {\n          inputValue,\n          ...(highlightedIndex >= 0 && {\n            highlightedIndex\n          })\n        };\n      }\n      break;\n    case MenuKeyDownArrowDown:\n      changes = {\n        highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n      };\n      break;\n    case MenuKeyDownArrowUp:\n      changes = {\n        highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n      };\n      break;\n    case FunctionSelectItem$1:\n      changes = {\n        selectedItem: action.selectedItem\n      };\n      break;\n    default:\n      return downshiftCommonReducer(state, action, stateChangeTypes$2);\n  }\n  return {\n    ...state,\n    ...changes\n  };\n}\n/* eslint-enable complexity */\n\n/* eslint-disable max-statements */\nuseSelect.stateChangeTypes = stateChangeTypes$2;\nfunction useSelect(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n  validatePropTypes$2(userProps, useSelect); // Props defaults and destructuring.\n\n  const props = {\n    ...defaultProps$2,\n    ...userProps\n  };\n  const {\n    items,\n    scrollIntoView,\n    environment,\n    initialIsOpen,\n    defaultIsOpen,\n    itemToString,\n    getA11ySelectionMessage,\n    getA11yStatusMessage\n  } = props; // Initial state depending on controlled props.\n\n  const initialState = getInitialState$2(props);\n  const [state, dispatch] = useControlledReducer$1(downshiftSelectReducer, initialState, props);\n  const {\n    isOpen,\n    highlightedIndex,\n    selectedItem,\n    inputValue\n  } = state; // Element efs.\n\n  const toggleButtonRef = useRef(null);\n  const menuRef = useRef(null);\n  const itemRefs = useRef({}); // used not to trigger menu blur action in some scenarios.\n\n  const shouldBlurRef = useRef(true); // used to keep the inputValue clearTimeout object between renders.\n\n  const clearTimeoutRef = useRef(null); // prevent id re-generation between renders.\n\n  const elementIds = useElementIds(props); // used to keep track of how many items we had on previous cycle.\n\n  const previousResultCountRef = useRef();\n  const isInitialMountRef = useRef(true); // utility callback to get item element.\n\n  const latest = useLatestRef({\n    state,\n    props\n  }); // Some utils.\n\n  const getItemNodeFromIndex = useCallback(index => itemRefs.current[elementIds.getItemId(index)], [elementIds]); // Effects.\n  // Sets a11y status message on changes in state.\n\n  useA11yMessageSetter(getA11yStatusMessage, [isOpen, highlightedIndex, inputValue, items], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Sets a11y status message on changes in selectedItem.\n\n  useA11yMessageSetter(getA11ySelectionMessage, [selectedItem], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Scroll on highlighted item if change comes from keyboard.\n\n  const shouldScrollRef = useScrollIntoView({\n    menuElement: menuRef.current,\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    scrollIntoView,\n    getItemNodeFromIndex\n  }); // Sets cleanup for the keysSoFar callback, debounded after 500ms.\n\n  useEffect(() => {\n    // init the clean function here as we need access to dispatch.\n    clearTimeoutRef.current = debounce(outerDispatch => {\n      outerDispatch({\n        type: FunctionSetInputValue$1,\n        inputValue: ''\n      });\n    }, 500); // Cancel any pending debounced calls on mount\n\n    return () => {\n      clearTimeoutRef.current.cancel();\n    };\n  }, []); // Invokes the keysSoFar callback set up above.\n\n  useEffect(() => {\n    if (!inputValue) {\n      return;\n    }\n    clearTimeoutRef.current(dispatch);\n  }, [dispatch, inputValue]);\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  });\n  /* Controls the focus on the menu or the toggle button. */\n\n  useEffect(() => {\n    // Don't focus menu on first render.\n    if (isInitialMountRef.current) {\n      // Unless it was initialised as open.\n      if ((initialIsOpen || defaultIsOpen || isOpen) && menuRef.current) {\n        menuRef.current.focus();\n      }\n      return;\n    } // Focus menu on open.\n\n    if (isOpen) {\n      // istanbul ignore else\n      if (menuRef.current) {\n        menuRef.current.focus();\n      }\n      return;\n    } // Focus toggleButton on close, but not if it was closed with (Shift+)Tab.\n\n    if (environment.document.activeElement === menuRef.current) {\n      // istanbul ignore else\n      if (toggleButtonRef.current) {\n        shouldBlurRef.current = false;\n        toggleButtonRef.current.focus();\n      }\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isOpen]);\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n    previousResultCountRef.current = items.length;\n  }); // Add mouse/touch events to document.\n\n  const mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [menuRef, toggleButtonRef], environment, () => {\n    dispatch({\n      type: MenuBlur\n    });\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker('getMenuProps', 'getToggleButtonProps'); // Make initial ref false.\n\n  useEffect(() => {\n    isInitialMountRef.current = false;\n  }, []); // Reset itemRefs on close.\n\n  useEffect(() => {\n    if (!isOpen) {\n      itemRefs.current = {};\n    }\n  }, [isOpen]); // Event handler functions.\n\n  const toggleButtonKeyDownHandlers = useMemo(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch({\n        type: ToggleButtonKeyDownArrowDown,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch({\n        type: ToggleButtonKeyDownArrowUp,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    }\n  }), [dispatch, getItemNodeFromIndex]);\n  const menuKeyDownHandlers = useMemo(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownArrowDown,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownArrowUp,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n    Home(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownHome,\n        getItemNodeFromIndex\n      });\n    },\n    End(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownEnd,\n        getItemNodeFromIndex\n      });\n    },\n    Escape() {\n      dispatch({\n        type: MenuKeyDownEscape\n      });\n    },\n    Enter(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownEnter\n      });\n    },\n    ' '(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownSpaceButton\n      });\n    }\n  }), [dispatch, getItemNodeFromIndex]); // Action functions.\n\n  const toggleMenu = useCallback(() => {\n    dispatch({\n      type: FunctionToggleMenu$1\n    });\n  }, [dispatch]);\n  const closeMenu = useCallback(() => {\n    dispatch({\n      type: FunctionCloseMenu$1\n    });\n  }, [dispatch]);\n  const openMenu = useCallback(() => {\n    dispatch({\n      type: FunctionOpenMenu$1\n    });\n  }, [dispatch]);\n  const setHighlightedIndex = useCallback(newHighlightedIndex => {\n    dispatch({\n      type: FunctionSetHighlightedIndex$1,\n      highlightedIndex: newHighlightedIndex\n    });\n  }, [dispatch]);\n  const selectItem = useCallback(newSelectedItem => {\n    dispatch({\n      type: FunctionSelectItem$1,\n      selectedItem: newSelectedItem\n    });\n  }, [dispatch]);\n  const reset = useCallback(() => {\n    dispatch({\n      type: FunctionReset$2\n    });\n  }, [dispatch]);\n  const setInputValue = useCallback(newInputValue => {\n    dispatch({\n      type: FunctionSetInputValue$1,\n      inputValue: newInputValue\n    });\n  }, [dispatch]); // Getter functions.\n\n  const getLabelProps = useCallback(labelProps => ({\n    id: elementIds.labelId,\n    htmlFor: elementIds.toggleButtonId,\n    ...labelProps\n  }), [elementIds]);\n  const getMenuProps = useCallback(function (_temp, _temp2) {\n    let {\n      onMouseLeave,\n      refKey = 'ref',\n      onKeyDown,\n      onBlur,\n      ref,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    let {\n      suppressRefError = false\n    } = _temp2 === void 0 ? {} : _temp2;\n    const latestState = latest.current.state;\n    const menuHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n      if (key && menuKeyDownHandlers[key]) {\n        menuKeyDownHandlers[key](event);\n      } else if (isAcceptedCharacterKey(key)) {\n        dispatch({\n          type: MenuKeyDownCharacter,\n          key,\n          getItemNodeFromIndex\n        });\n      }\n    };\n    const menuHandleBlur = () => {\n      // if the blur was a result of selection, we don't trigger this action.\n      if (shouldBlurRef.current === false) {\n        shouldBlurRef.current = true;\n        return;\n      }\n      const shouldBlur = !mouseAndTouchTrackersRef.current.isMouseDown;\n      /* istanbul ignore else */\n\n      if (shouldBlur) {\n        dispatch({\n          type: MenuBlur\n        });\n      }\n    };\n    const menuHandleMouseLeave = () => {\n      dispatch({\n        type: MenuMouseLeave$1\n      });\n    };\n    setGetterPropCallInfo('getMenuProps', suppressRefError, refKey, menuRef);\n    return {\n      [refKey]: handleRefs(ref, menuNode => {\n        menuRef.current = menuNode;\n      }),\n      id: elementIds.menuId,\n      role: 'listbox',\n      'aria-labelledby': elementIds.labelId,\n      tabIndex: -1,\n      ...(latestState.isOpen && latestState.highlightedIndex > -1 && {\n        'aria-activedescendant': elementIds.getItemId(latestState.highlightedIndex)\n      }),\n      onMouseLeave: callAllEventHandlers(onMouseLeave, menuHandleMouseLeave),\n      onKeyDown: callAllEventHandlers(onKeyDown, menuHandleKeyDown),\n      onBlur: callAllEventHandlers(onBlur, menuHandleBlur),\n      ...rest\n    };\n  }, [dispatch, latest, menuKeyDownHandlers, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds, getItemNodeFromIndex]);\n  const getToggleButtonProps = useCallback(function (_temp3, _temp4) {\n    let {\n      onClick,\n      onKeyDown,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp3 === void 0 ? {} : _temp3;\n    let {\n      suppressRefError = false\n    } = _temp4 === void 0 ? {} : _temp4;\n    const toggleButtonHandleClick = () => {\n      dispatch({\n        type: ToggleButtonClick$1\n      });\n    };\n    const toggleButtonHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n      if (key && toggleButtonKeyDownHandlers[key]) {\n        toggleButtonKeyDownHandlers[key](event);\n      } else if (isAcceptedCharacterKey(key)) {\n        dispatch({\n          type: ToggleButtonKeyDownCharacter,\n          key,\n          getItemNodeFromIndex\n        });\n      }\n    };\n    const toggleProps = {\n      [refKey]: handleRefs(ref, toggleButtonNode => {\n        toggleButtonRef.current = toggleButtonNode;\n      }),\n      id: elementIds.toggleButtonId,\n      'aria-haspopup': 'listbox',\n      'aria-expanded': latest.current.state.isOpen,\n      'aria-labelledby': `${elementIds.labelId} ${elementIds.toggleButtonId}`,\n      ...rest\n    };\n    if (!rest.disabled) {\n      toggleProps.onClick = callAllEventHandlers(onClick, toggleButtonHandleClick);\n      toggleProps.onKeyDown = callAllEventHandlers(onKeyDown, toggleButtonHandleKeyDown);\n    }\n    setGetterPropCallInfo('getToggleButtonProps', suppressRefError, refKey, toggleButtonRef);\n    return toggleProps;\n  }, [dispatch, latest, toggleButtonKeyDownHandlers, setGetterPropCallInfo, elementIds, getItemNodeFromIndex]);\n  const getItemProps = useCallback(function (_temp5) {\n    let {\n      item,\n      index,\n      onMouseMove,\n      onClick,\n      refKey = 'ref',\n      ref,\n      disabled,\n      ...rest\n    } = _temp5 === void 0 ? {} : _temp5;\n    const {\n      state: latestState,\n      props: latestProps\n    } = latest.current;\n    const itemHandleMouseMove = () => {\n      if (index === latestState.highlightedIndex) {\n        return;\n      }\n      shouldScrollRef.current = false;\n      dispatch({\n        type: ItemMouseMove$1,\n        index,\n        disabled\n      });\n    };\n    const itemHandleClick = () => {\n      dispatch({\n        type: ItemClick$1,\n        index\n      });\n    };\n    const itemIndex = getItemIndex(index, item, latestProps.items);\n    if (itemIndex < 0) {\n      throw new Error('Pass either item or item index in getItemProps!');\n    }\n    const itemProps = {\n      disabled,\n      role: 'option',\n      'aria-selected': `${itemIndex === latestState.highlightedIndex}`,\n      id: elementIds.getItemId(itemIndex),\n      [refKey]: handleRefs(ref, itemNode => {\n        if (itemNode) {\n          itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;\n        }\n      }),\n      ...rest\n    };\n    if (!disabled) {\n      itemProps.onClick = callAllEventHandlers(onClick, itemHandleClick);\n    }\n    itemProps.onMouseMove = callAllEventHandlers(onMouseMove, itemHandleMouseMove);\n    return itemProps;\n  }, [dispatch, latest, shouldScrollRef, elementIds]);\n  return {\n    // prop getters.\n    getToggleButtonProps,\n    getLabelProps,\n    getMenuProps,\n    getItemProps,\n    // actions.\n    toggleMenu,\n    openMenu,\n    closeMenu,\n    setHighlightedIndex,\n    selectItem,\n    reset,\n    setInputValue,\n    // state.\n    highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\nconst InputKeyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__input_keydown_arrow_down__' : 0;\nconst InputKeyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__input_keydown_arrow_up__' : 1;\nconst InputKeyDownEscape = process.env.NODE_ENV !== \"production\" ? '__input_keydown_escape__' : 2;\nconst InputKeyDownHome = process.env.NODE_ENV !== \"production\" ? '__input_keydown_home__' : 3;\nconst InputKeyDownEnd = process.env.NODE_ENV !== \"production\" ? '__input_keydown_end__' : 4;\nconst InputKeyDownEnter = process.env.NODE_ENV !== \"production\" ? '__input_keydown_enter__' : 5;\nconst InputChange = process.env.NODE_ENV !== \"production\" ? '__input_change__' : 6;\nconst InputBlur = process.env.NODE_ENV !== \"production\" ? '__input_blur__' : 7;\nconst MenuMouseLeave = process.env.NODE_ENV !== \"production\" ? '__menu_mouse_leave__' : 8;\nconst ItemMouseMove = process.env.NODE_ENV !== \"production\" ? '__item_mouse_move__' : 9;\nconst ItemClick = process.env.NODE_ENV !== \"production\" ? '__item_click__' : 10;\nconst ToggleButtonClick = process.env.NODE_ENV !== \"production\" ? '__togglebutton_click__' : 11;\nconst FunctionToggleMenu = process.env.NODE_ENV !== \"production\" ? '__function_toggle_menu__' : 12;\nconst FunctionOpenMenu = process.env.NODE_ENV !== \"production\" ? '__function_open_menu__' : 13;\nconst FunctionCloseMenu = process.env.NODE_ENV !== \"production\" ? '__function_close_menu__' : 14;\nconst FunctionSetHighlightedIndex = process.env.NODE_ENV !== \"production\" ? '__function_set_highlighted_index__' : 15;\nconst FunctionSelectItem = process.env.NODE_ENV !== \"production\" ? '__function_select_item__' : 16;\nconst FunctionSetInputValue = process.env.NODE_ENV !== \"production\" ? '__function_set_input_value__' : 17;\nconst FunctionReset$1 = process.env.NODE_ENV !== \"production\" ? '__function_reset__' : 18;\nconst ControlledPropUpdatedSelectedItem = process.env.NODE_ENV !== \"production\" ? '__controlled_prop_updated_selected_item__' : 19;\nvar stateChangeTypes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  InputKeyDownArrowDown: InputKeyDownArrowDown,\n  InputKeyDownArrowUp: InputKeyDownArrowUp,\n  InputKeyDownEscape: InputKeyDownEscape,\n  InputKeyDownHome: InputKeyDownHome,\n  InputKeyDownEnd: InputKeyDownEnd,\n  InputKeyDownEnter: InputKeyDownEnter,\n  InputChange: InputChange,\n  InputBlur: InputBlur,\n  MenuMouseLeave: MenuMouseLeave,\n  ItemMouseMove: ItemMouseMove,\n  ItemClick: ItemClick,\n  ToggleButtonClick: ToggleButtonClick,\n  FunctionToggleMenu: FunctionToggleMenu,\n  FunctionOpenMenu: FunctionOpenMenu,\n  FunctionCloseMenu: FunctionCloseMenu,\n  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex,\n  FunctionSelectItem: FunctionSelectItem,\n  FunctionSetInputValue: FunctionSetInputValue,\n  FunctionReset: FunctionReset$1,\n  ControlledPropUpdatedSelectedItem: ControlledPropUpdatedSelectedItem\n});\nfunction getInitialState$1(props) {\n  const initialState = getInitialState$2(props);\n  const {\n    selectedItem\n  } = initialState;\n  let {\n    inputValue\n  } = initialState;\n  if (inputValue === '' && selectedItem && props.defaultInputValue === undefined && props.initialInputValue === undefined && props.inputValue === undefined) {\n    inputValue = props.itemToString(selectedItem);\n  }\n  return {\n    ...initialState,\n    inputValue\n  };\n}\nconst propTypes$1 = {\n  items: PropTypes.array.isRequired,\n  itemToString: PropTypes.func,\n  getA11yStatusMessage: PropTypes.func,\n  getA11ySelectionMessage: PropTypes.func,\n  circularNavigation: PropTypes.bool,\n  highlightedIndex: PropTypes.number,\n  defaultHighlightedIndex: PropTypes.number,\n  initialHighlightedIndex: PropTypes.number,\n  isOpen: PropTypes.bool,\n  defaultIsOpen: PropTypes.bool,\n  initialIsOpen: PropTypes.bool,\n  selectedItem: PropTypes.any,\n  initialSelectedItem: PropTypes.any,\n  defaultSelectedItem: PropTypes.any,\n  inputValue: PropTypes.string,\n  defaultInputValue: PropTypes.string,\n  initialInputValue: PropTypes.string,\n  id: PropTypes.string,\n  labelId: PropTypes.string,\n  menuId: PropTypes.string,\n  getItemId: PropTypes.func,\n  inputId: PropTypes.string,\n  toggleButtonId: PropTypes.string,\n  stateReducer: PropTypes.func,\n  onSelectedItemChange: PropTypes.func,\n  onHighlightedIndexChange: PropTypes.func,\n  onStateChange: PropTypes.func,\n  onIsOpenChange: PropTypes.func,\n  onInputValueChange: PropTypes.func,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  })\n};\n/**\n * The useCombobox version of useControlledReducer, which also\n * checks if the controlled prop selectedItem changed between\n * renders. If so, it will also update inputValue with its\n * string equivalent. It uses the common useEnhancedReducer to\n * compute the rest of the state.\n *\n * @param {Function} reducer Reducer function from downshift.\n * @param {Object} initialState Initial state of the hook.\n * @param {Object} props The hook props.\n * @returns {Array} An array with the state and an action dispatcher.\n */\n\nfunction useControlledReducer(reducer, initialState, props) {\n  const previousSelectedItemRef = useRef();\n  const [state, dispatch] = useEnhancedReducer(reducer, initialState, props); // ToDo: if needed, make same approach as selectedItemChanged from Downshift.\n\n  useEffect(() => {\n    if (isControlledProp(props, 'selectedItem')) {\n      if (previousSelectedItemRef.current !== props.selectedItem) {\n        dispatch({\n          type: ControlledPropUpdatedSelectedItem,\n          inputValue: props.itemToString(props.selectedItem)\n        });\n      }\n      previousSelectedItemRef.current = state.selectedItem === previousSelectedItemRef.current ? props.selectedItem : state.selectedItem;\n    }\n  });\n  return [getState(state, props), dispatch];\n} // eslint-disable-next-line import/no-mutable-exports\n\nlet validatePropTypes$1 = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validatePropTypes$1 = (options, caller) => {\n    PropTypes.checkPropTypes(propTypes$1, options, 'prop', caller.name);\n  };\n}\nconst defaultProps$1 = {\n  ...defaultProps$3,\n  getA11yStatusMessage: getA11yStatusMessage$1,\n  circularNavigation: true\n};\n\n/* eslint-disable complexity */\n\nfunction downshiftUseComboboxReducer(state, action) {\n  const {\n    type,\n    props,\n    shiftKey\n  } = action;\n  let changes;\n  switch (type) {\n    case ItemClick:\n      changes = {\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        selectedItem: props.items[action.index],\n        inputValue: props.itemToString(props.items[action.index])\n      };\n      break;\n    case InputKeyDownArrowDown:\n      if (state.isOpen) {\n        changes = {\n          highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n        };\n      } else {\n        changes = {\n          highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),\n          isOpen: props.items.length >= 0\n        };\n      }\n      break;\n    case InputKeyDownArrowUp:\n      if (state.isOpen) {\n        changes = {\n          highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n        };\n      } else {\n        changes = {\n          highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),\n          isOpen: props.items.length >= 0\n        };\n      }\n      break;\n    case InputKeyDownEnter:\n      changes = {\n        ...(state.isOpen && state.highlightedIndex >= 0 && {\n          selectedItem: props.items[state.highlightedIndex],\n          isOpen: getDefaultValue$1(props, 'isOpen'),\n          highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n          inputValue: props.itemToString(props.items[state.highlightedIndex])\n        })\n      };\n      break;\n    case InputKeyDownEscape:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1,\n        ...(!state.isOpen && {\n          selectedItem: null,\n          inputValue: ''\n        })\n      };\n      break;\n    case InputKeyDownHome:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n    case InputKeyDownEnd:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n    case InputBlur:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1,\n        ...(state.highlightedIndex >= 0 && action.selectItem && {\n          selectedItem: props.items[state.highlightedIndex],\n          inputValue: props.itemToString(props.items[state.highlightedIndex])\n        })\n      };\n      break;\n    case InputChange:\n      changes = {\n        isOpen: true,\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        inputValue: action.inputValue\n      };\n      break;\n    case FunctionSelectItem:\n      changes = {\n        selectedItem: action.selectedItem,\n        inputValue: props.itemToString(action.selectedItem)\n      };\n      break;\n    case ControlledPropUpdatedSelectedItem:\n      changes = {\n        inputValue: action.inputValue\n      };\n      break;\n    default:\n      return downshiftCommonReducer(state, action, stateChangeTypes$1);\n  }\n  return {\n    ...state,\n    ...changes\n  };\n}\n/* eslint-enable complexity */\n\n/* eslint-disable max-statements */\nuseCombobox.stateChangeTypes = stateChangeTypes$1;\nfunction useCombobox(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n  validatePropTypes$1(userProps, useCombobox); // Props defaults and destructuring.\n\n  const props = {\n    ...defaultProps$1,\n    ...userProps\n  };\n  const {\n    initialIsOpen,\n    defaultIsOpen,\n    items,\n    scrollIntoView,\n    environment,\n    getA11yStatusMessage,\n    getA11ySelectionMessage,\n    itemToString\n  } = props; // Initial state depending on controlled props.\n\n  const initialState = getInitialState$1(props);\n  const [state, dispatch] = useControlledReducer(downshiftUseComboboxReducer, initialState, props);\n  const {\n    isOpen,\n    highlightedIndex,\n    selectedItem,\n    inputValue\n  } = state; // Element refs.\n\n  const menuRef = useRef(null);\n  const itemRefs = useRef({});\n  const inputRef = useRef(null);\n  const toggleButtonRef = useRef(null);\n  const comboboxRef = useRef(null);\n  const isInitialMountRef = useRef(true); // prevent id re-generation between renders.\n\n  const elementIds = useElementIds(props); // used to keep track of how many items we had on previous cycle.\n\n  const previousResultCountRef = useRef(); // utility callback to get item element.\n\n  const latest = useLatestRef({\n    state,\n    props\n  });\n  const getItemNodeFromIndex = useCallback(index => itemRefs.current[elementIds.getItemId(index)], [elementIds]); // Effects.\n  // Sets a11y status message on changes in state.\n\n  useA11yMessageSetter(getA11yStatusMessage, [isOpen, highlightedIndex, inputValue, items], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Sets a11y status message on changes in selectedItem.\n\n  useA11yMessageSetter(getA11ySelectionMessage, [selectedItem], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Scroll on highlighted item if change comes from keyboard.\n\n  const shouldScrollRef = useScrollIntoView({\n    menuElement: menuRef.current,\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    scrollIntoView,\n    getItemNodeFromIndex\n  });\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  }); // Focus the input on first render if required.\n\n  useEffect(() => {\n    const focusOnOpen = initialIsOpen || defaultIsOpen || isOpen;\n    if (focusOnOpen && inputRef.current) {\n      inputRef.current.focus();\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n    previousResultCountRef.current = items.length;\n  }); // Add mouse/touch events to document.\n\n  const mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [comboboxRef, menuRef, toggleButtonRef], environment, () => {\n    dispatch({\n      type: InputBlur,\n      selectItem: false\n    });\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker('getInputProps', 'getComboboxProps', 'getMenuProps'); // Make initial ref false.\n\n  useEffect(() => {\n    isInitialMountRef.current = false;\n  }, []); // Reset itemRefs on close.\n\n  useEffect(() => {\n    if (!isOpen) {\n      itemRefs.current = {};\n    }\n  }, [isOpen]);\n  /* Event handler functions */\n\n  const inputKeyDownHandlers = useMemo(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownArrowDown,\n        shiftKey: event.shiftKey,\n        getItemNodeFromIndex\n      });\n    },\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownArrowUp,\n        shiftKey: event.shiftKey,\n        getItemNodeFromIndex\n      });\n    },\n    Home(event) {\n      if (!latest.current.state.isOpen) {\n        return;\n      }\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownHome,\n        getItemNodeFromIndex\n      });\n    },\n    End(event) {\n      if (!latest.current.state.isOpen) {\n        return;\n      }\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownEnd,\n        getItemNodeFromIndex\n      });\n    },\n    Escape(event) {\n      const latestState = latest.current.state;\n      if (latestState.isOpen || latestState.inputValue || latestState.selectedItem || latestState.highlightedIndex > -1) {\n        event.preventDefault();\n        dispatch({\n          type: InputKeyDownEscape\n        });\n      }\n    },\n    Enter(event) {\n      const latestState = latest.current.state; // if closed or no highlighted index, do nothing.\n\n      if (!latestState.isOpen || latestState.highlightedIndex < 0 || event.which === 229 // if IME composing, wait for next Enter keydown event.\n      ) {\n        return;\n      }\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownEnter,\n        getItemNodeFromIndex\n      });\n    }\n  }), [dispatch, latest, getItemNodeFromIndex]); // Getter props.\n\n  const getLabelProps = useCallback(labelProps => ({\n    id: elementIds.labelId,\n    htmlFor: elementIds.inputId,\n    ...labelProps\n  }), [elementIds]);\n  const getMenuProps = useCallback(function (_temp, _temp2) {\n    let {\n      onMouseLeave,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    let {\n      suppressRefError = false\n    } = _temp2 === void 0 ? {} : _temp2;\n    setGetterPropCallInfo('getMenuProps', suppressRefError, refKey, menuRef);\n    return {\n      [refKey]: handleRefs(ref, menuNode => {\n        menuRef.current = menuNode;\n      }),\n      id: elementIds.menuId,\n      role: 'listbox',\n      'aria-labelledby': elementIds.labelId,\n      onMouseLeave: callAllEventHandlers(onMouseLeave, () => {\n        dispatch({\n          type: MenuMouseLeave\n        });\n      }),\n      ...rest\n    };\n  }, [dispatch, setGetterPropCallInfo, elementIds]);\n  const getItemProps = useCallback(function (_temp3) {\n    let {\n      item,\n      index,\n      refKey = 'ref',\n      ref,\n      onMouseMove,\n      onMouseDown,\n      onClick,\n      onPress,\n      disabled,\n      ...rest\n    } = _temp3 === void 0 ? {} : _temp3;\n    const {\n      props: latestProps,\n      state: latestState\n    } = latest.current;\n    const itemIndex = getItemIndex(index, item, latestProps.items);\n    if (itemIndex < 0) {\n      throw new Error('Pass either item or item index in getItemProps!');\n    }\n    const onSelectKey = 'onClick';\n    const customClickHandler = onClick;\n    const itemHandleMouseMove = () => {\n      if (index === latestState.highlightedIndex) {\n        return;\n      }\n      shouldScrollRef.current = false;\n      dispatch({\n        type: ItemMouseMove,\n        index,\n        disabled\n      });\n    };\n    const itemHandleClick = () => {\n      dispatch({\n        type: ItemClick,\n        index\n      });\n    };\n    const itemHandleMouseDown = e => e.preventDefault();\n    return {\n      [refKey]: handleRefs(ref, itemNode => {\n        if (itemNode) {\n          itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;\n        }\n      }),\n      disabled,\n      role: 'option',\n      'aria-selected': `${itemIndex === latestState.highlightedIndex}`,\n      id: elementIds.getItemId(itemIndex),\n      ...(!disabled && {\n        [onSelectKey]: callAllEventHandlers(customClickHandler, itemHandleClick)\n      }),\n      onMouseMove: callAllEventHandlers(onMouseMove, itemHandleMouseMove),\n      onMouseDown: callAllEventHandlers(onMouseDown, itemHandleMouseDown),\n      ...rest\n    };\n  }, [dispatch, latest, shouldScrollRef, elementIds]);\n  const getToggleButtonProps = useCallback(function (_temp4) {\n    let {\n      onClick,\n      onPress,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp4 === void 0 ? {} : _temp4;\n    const toggleButtonHandleClick = () => {\n      dispatch({\n        type: ToggleButtonClick\n      });\n      if (!latest.current.state.isOpen && inputRef.current) {\n        inputRef.current.focus();\n      }\n    };\n    return {\n      [refKey]: handleRefs(ref, toggleButtonNode => {\n        toggleButtonRef.current = toggleButtonNode;\n      }),\n      id: elementIds.toggleButtonId,\n      tabIndex: -1,\n      ...(!rest.disabled && {\n        ...{\n          onClick: callAllEventHandlers(onClick, toggleButtonHandleClick)\n        }\n      }),\n      ...rest\n    };\n  }, [dispatch, latest, elementIds]);\n  const getInputProps = useCallback(function (_temp5, _temp6) {\n    let {\n      onKeyDown,\n      onChange,\n      onInput,\n      onBlur,\n      onChangeText,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp5 === void 0 ? {} : _temp5;\n    let {\n      suppressRefError = false\n    } = _temp6 === void 0 ? {} : _temp6;\n    setGetterPropCallInfo('getInputProps', suppressRefError, refKey, inputRef);\n    const latestState = latest.current.state;\n    const inputHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n      if (key && inputKeyDownHandlers[key]) {\n        inputKeyDownHandlers[key](event);\n      }\n    };\n    const inputHandleChange = event => {\n      dispatch({\n        type: InputChange,\n        inputValue: event.target.value\n      });\n    };\n    const inputHandleBlur = () => {\n      /* istanbul ignore else */\n      if (latestState.isOpen && !mouseAndTouchTrackersRef.current.isMouseDown) {\n        dispatch({\n          type: InputBlur,\n          selectItem: true\n        });\n      }\n    };\n    /* istanbul ignore next (preact) */\n\n    const onChangeKey = 'onChange';\n    let eventHandlers = {};\n    if (!rest.disabled) {\n      eventHandlers = {\n        [onChangeKey]: callAllEventHandlers(onChange, onInput, inputHandleChange),\n        onKeyDown: callAllEventHandlers(onKeyDown, inputHandleKeyDown),\n        onBlur: callAllEventHandlers(onBlur, inputHandleBlur)\n      };\n    }\n    return {\n      [refKey]: handleRefs(ref, inputNode => {\n        inputRef.current = inputNode;\n      }),\n      id: elementIds.inputId,\n      'aria-autocomplete': 'list',\n      'aria-controls': elementIds.menuId,\n      ...(latestState.isOpen && latestState.highlightedIndex > -1 && {\n        'aria-activedescendant': elementIds.getItemId(latestState.highlightedIndex)\n      }),\n      'aria-labelledby': elementIds.labelId,\n      // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion\n      // revert back since autocomplete=\"nope\" is ignored on latest Chrome and Opera\n      autoComplete: 'off',\n      value: latestState.inputValue,\n      ...eventHandlers,\n      ...rest\n    };\n  }, [dispatch, inputKeyDownHandlers, latest, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds]);\n  const getComboboxProps = useCallback(function (_temp7, _temp8) {\n    let {\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp7 === void 0 ? {} : _temp7;\n    let {\n      suppressRefError = false\n    } = _temp8 === void 0 ? {} : _temp8;\n    setGetterPropCallInfo('getComboboxProps', suppressRefError, refKey, comboboxRef);\n    return {\n      [refKey]: handleRefs(ref, comboboxNode => {\n        comboboxRef.current = comboboxNode;\n      }),\n      role: 'combobox',\n      'aria-haspopup': 'listbox',\n      'aria-owns': elementIds.menuId,\n      'aria-expanded': latest.current.state.isOpen,\n      ...rest\n    };\n  }, [latest, setGetterPropCallInfo, elementIds]); // returns\n\n  const toggleMenu = useCallback(() => {\n    dispatch({\n      type: FunctionToggleMenu\n    });\n  }, [dispatch]);\n  const closeMenu = useCallback(() => {\n    dispatch({\n      type: FunctionCloseMenu\n    });\n  }, [dispatch]);\n  const openMenu = useCallback(() => {\n    dispatch({\n      type: FunctionOpenMenu\n    });\n  }, [dispatch]);\n  const setHighlightedIndex = useCallback(newHighlightedIndex => {\n    dispatch({\n      type: FunctionSetHighlightedIndex,\n      highlightedIndex: newHighlightedIndex\n    });\n  }, [dispatch]);\n  const selectItem = useCallback(newSelectedItem => {\n    dispatch({\n      type: FunctionSelectItem,\n      selectedItem: newSelectedItem\n    });\n  }, [dispatch]);\n  const setInputValue = useCallback(newInputValue => {\n    dispatch({\n      type: FunctionSetInputValue,\n      inputValue: newInputValue\n    });\n  }, [dispatch]);\n  const reset = useCallback(() => {\n    dispatch({\n      type: FunctionReset$1\n    });\n  }, [dispatch]);\n  return {\n    // prop getters.\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    getInputProps,\n    getComboboxProps,\n    getToggleButtonProps,\n    // actions.\n    toggleMenu,\n    openMenu,\n    closeMenu,\n    setHighlightedIndex,\n    setInputValue,\n    selectItem,\n    reset,\n    // state.\n    highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\nconst defaultStateValues = {\n  activeIndex: -1,\n  selectedItems: []\n};\n/**\n * Returns the initial value for a state key in the following order:\n * 1. controlled prop, 2. initial prop, 3. default prop, 4. default\n * value from Downshift.\n *\n * @param {Object} props Props passed to the hook.\n * @param {string} propKey Props key to generate the value for.\n * @returns {any} The initial value for that prop.\n */\n\nfunction getInitialValue(props, propKey) {\n  return getInitialValue$1(props, propKey, defaultStateValues);\n}\n/**\n * Returns the default value for a state key in the following order:\n * 1. controlled prop, 2. default prop, 3. default value from Downshift.\n *\n * @param {Object} props Props passed to the hook.\n * @param {string} propKey Props key to generate the value for.\n * @returns {any} The initial value for that prop.\n */\n\nfunction getDefaultValue(props, propKey) {\n  return getDefaultValue$1(props, propKey, defaultStateValues);\n}\n/**\n * Gets the initial state based on the provided props. It uses initial, default\n * and controlled props related to state in order to compute the initial value.\n *\n * @param {Object} props Props passed to the hook.\n * @returns {Object} The initial state.\n */\n\nfunction getInitialState(props) {\n  const activeIndex = getInitialValue(props, 'activeIndex');\n  const selectedItems = getInitialValue(props, 'selectedItems');\n  return {\n    activeIndex,\n    selectedItems\n  };\n}\n/**\n * Returns true if dropdown keydown operation is permitted. Should not be\n * allowed on keydown with modifier keys (ctrl, alt, shift, meta), on\n * input element with text content that is either highlighted or selection\n * cursor is not at the starting position.\n *\n * @param {KeyboardEvent} event The event from keydown.\n * @returns {boolean} Whether the operation is allowed.\n */\n\nfunction isKeyDownOperationPermitted(event) {\n  if (event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {\n    return false;\n  }\n  const element = event.target;\n  if (element instanceof HTMLInputElement &&\n  // if element is a text input\n  element.value !== '' && (\n  // and we have text in it\n  // and cursor is either not at the start or is currently highlighting text.\n  element.selectionStart !== 0 || element.selectionEnd !== 0)) {\n    return false;\n  }\n  return true;\n}\n/**\n * Returns a message to be added to aria-live region when item is removed.\n *\n * @param {Object} selectionParameters Parameters required to build the message.\n * @returns {string} The a11y message.\n */\n\nfunction getA11yRemovalMessage(selectionParameters) {\n  const {\n    removedSelectedItem,\n    itemToString: itemToStringLocal\n  } = selectionParameters;\n  return `${itemToStringLocal(removedSelectedItem)} has been removed.`;\n}\nconst propTypes = {\n  selectedItems: PropTypes.array,\n  initialSelectedItems: PropTypes.array,\n  defaultSelectedItems: PropTypes.array,\n  itemToString: PropTypes.func,\n  getA11yRemovalMessage: PropTypes.func,\n  stateReducer: PropTypes.func,\n  activeIndex: PropTypes.number,\n  initialActiveIndex: PropTypes.number,\n  defaultActiveIndex: PropTypes.number,\n  onActiveIndexChange: PropTypes.func,\n  onSelectedItemsChange: PropTypes.func,\n  keyNavigationNext: PropTypes.string,\n  keyNavigationPrevious: PropTypes.string,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  })\n};\nconst defaultProps = {\n  itemToString: defaultProps$3.itemToString,\n  stateReducer: defaultProps$3.stateReducer,\n  environment: defaultProps$3.environment,\n  getA11yRemovalMessage,\n  keyNavigationNext: 'ArrowRight',\n  keyNavigationPrevious: 'ArrowLeft'\n}; // eslint-disable-next-line import/no-mutable-exports\n\nlet validatePropTypes = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validatePropTypes = (options, caller) => {\n    PropTypes.checkPropTypes(propTypes, options, 'prop', caller.name);\n  };\n}\nconst SelectedItemClick = process.env.NODE_ENV !== \"production\" ? '__selected_item_click__' : 0;\nconst SelectedItemKeyDownDelete = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_delete__' : 1;\nconst SelectedItemKeyDownBackspace = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_backspace__' : 2;\nconst SelectedItemKeyDownNavigationNext = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_navigation_next__' : 3;\nconst SelectedItemKeyDownNavigationPrevious = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_navigation_previous__' : 4;\nconst DropdownKeyDownNavigationPrevious = process.env.NODE_ENV !== \"production\" ? '__dropdown_keydown_navigation_previous__' : 5;\nconst DropdownKeyDownBackspace = process.env.NODE_ENV !== \"production\" ? '__dropdown_keydown_backspace__' : 6;\nconst DropdownClick = process.env.NODE_ENV !== \"production\" ? '__dropdown_click__' : 7;\nconst FunctionAddSelectedItem = process.env.NODE_ENV !== \"production\" ? '__function_add_selected_item__' : 8;\nconst FunctionRemoveSelectedItem = process.env.NODE_ENV !== \"production\" ? '__function_remove_selected_item__' : 9;\nconst FunctionSetSelectedItems = process.env.NODE_ENV !== \"production\" ? '__function_set_selected_items__' : 10;\nconst FunctionSetActiveIndex = process.env.NODE_ENV !== \"production\" ? '__function_set_active_index__' : 11;\nconst FunctionReset = process.env.NODE_ENV !== \"production\" ? '__function_reset__' : 12;\nvar stateChangeTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  SelectedItemClick: SelectedItemClick,\n  SelectedItemKeyDownDelete: SelectedItemKeyDownDelete,\n  SelectedItemKeyDownBackspace: SelectedItemKeyDownBackspace,\n  SelectedItemKeyDownNavigationNext: SelectedItemKeyDownNavigationNext,\n  SelectedItemKeyDownNavigationPrevious: SelectedItemKeyDownNavigationPrevious,\n  DropdownKeyDownNavigationPrevious: DropdownKeyDownNavigationPrevious,\n  DropdownKeyDownBackspace: DropdownKeyDownBackspace,\n  DropdownClick: DropdownClick,\n  FunctionAddSelectedItem: FunctionAddSelectedItem,\n  FunctionRemoveSelectedItem: FunctionRemoveSelectedItem,\n  FunctionSetSelectedItems: FunctionSetSelectedItems,\n  FunctionSetActiveIndex: FunctionSetActiveIndex,\n  FunctionReset: FunctionReset\n});\n\n/* eslint-disable complexity */\n\nfunction downshiftMultipleSelectionReducer(state, action) {\n  const {\n    type,\n    index,\n    props,\n    selectedItem\n  } = action;\n  const {\n    activeIndex,\n    selectedItems\n  } = state;\n  let changes;\n  switch (type) {\n    case SelectedItemClick:\n      changes = {\n        activeIndex: index\n      };\n      break;\n    case SelectedItemKeyDownNavigationPrevious:\n      changes = {\n        activeIndex: activeIndex - 1 < 0 ? 0 : activeIndex - 1\n      };\n      break;\n    case SelectedItemKeyDownNavigationNext:\n      changes = {\n        activeIndex: activeIndex + 1 >= selectedItems.length ? -1 : activeIndex + 1\n      };\n      break;\n    case SelectedItemKeyDownBackspace:\n    case SelectedItemKeyDownDelete:\n      {\n        let newActiveIndex = activeIndex;\n        if (selectedItems.length === 1) {\n          newActiveIndex = -1;\n        } else if (activeIndex === selectedItems.length - 1) {\n          newActiveIndex = selectedItems.length - 2;\n        }\n        changes = {\n          selectedItems: [...selectedItems.slice(0, activeIndex), ...selectedItems.slice(activeIndex + 1)],\n          ...{\n            activeIndex: newActiveIndex\n          }\n        };\n        break;\n      }\n    case DropdownKeyDownNavigationPrevious:\n      changes = {\n        activeIndex: selectedItems.length - 1\n      };\n      break;\n    case DropdownKeyDownBackspace:\n      changes = {\n        selectedItems: selectedItems.slice(0, selectedItems.length - 1)\n      };\n      break;\n    case FunctionAddSelectedItem:\n      changes = {\n        selectedItems: [...selectedItems, selectedItem]\n      };\n      break;\n    case DropdownClick:\n      changes = {\n        activeIndex: -1\n      };\n      break;\n    case FunctionRemoveSelectedItem:\n      {\n        let newActiveIndex = activeIndex;\n        const selectedItemIndex = selectedItems.indexOf(selectedItem);\n        if (selectedItemIndex >= 0) {\n          if (selectedItems.length === 1) {\n            newActiveIndex = -1;\n          } else if (selectedItemIndex === selectedItems.length - 1) {\n            newActiveIndex = selectedItems.length - 2;\n          }\n          changes = {\n            selectedItems: [...selectedItems.slice(0, selectedItemIndex), ...selectedItems.slice(selectedItemIndex + 1)],\n            activeIndex: newActiveIndex\n          };\n        }\n        break;\n      }\n    case FunctionSetSelectedItems:\n      {\n        const {\n          selectedItems: newSelectedItems\n        } = action;\n        changes = {\n          selectedItems: newSelectedItems\n        };\n        break;\n      }\n    case FunctionSetActiveIndex:\n      {\n        const {\n          activeIndex: newActiveIndex\n        } = action;\n        changes = {\n          activeIndex: newActiveIndex\n        };\n        break;\n      }\n    case FunctionReset:\n      changes = {\n        activeIndex: getDefaultValue(props, 'activeIndex'),\n        selectedItems: getDefaultValue(props, 'selectedItems')\n      };\n      break;\n    default:\n      throw new Error('Reducer called without proper action type.');\n  }\n  return {\n    ...state,\n    ...changes\n  };\n}\nuseMultipleSelection.stateChangeTypes = stateChangeTypes;\nfunction useMultipleSelection(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n  validatePropTypes(userProps, useMultipleSelection); // Props defaults and destructuring.\n\n  const props = {\n    ...defaultProps,\n    ...userProps\n  };\n  const {\n    getA11yRemovalMessage,\n    itemToString,\n    environment,\n    keyNavigationNext,\n    keyNavigationPrevious\n  } = props; // Reducer init.\n\n  const [state, dispatch] = useControlledReducer$1(downshiftMultipleSelectionReducer, getInitialState(props), props);\n  const {\n    activeIndex,\n    selectedItems\n  } = state; // Refs.\n\n  const isInitialMountRef = useRef(true);\n  const dropdownRef = useRef(null);\n  const previousSelectedItemsRef = useRef(selectedItems);\n  const selectedItemRefs = useRef();\n  selectedItemRefs.current = [];\n  const latest = useLatestRef({\n    state,\n    props\n  }); // Effects.\n\n  /* Sets a11y status message on changes in selectedItem. */\n\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n    if (selectedItems.length < previousSelectedItemsRef.current.length) {\n      const removedSelectedItem = previousSelectedItemsRef.current.find(item => selectedItems.indexOf(item) < 0);\n      setStatus(getA11yRemovalMessage({\n        itemToString,\n        resultCount: selectedItems.length,\n        removedSelectedItem,\n        activeIndex,\n        activeSelectedItem: selectedItems[activeIndex]\n      }), environment.document);\n    }\n    previousSelectedItemsRef.current = selectedItems; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [selectedItems.length]); // Sets focus on active item.\n\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n    if (activeIndex === -1 && dropdownRef.current) {\n      dropdownRef.current.focus();\n    } else if (selectedItemRefs.current[activeIndex]) {\n      selectedItemRefs.current[activeIndex].focus();\n    }\n  }, [activeIndex]);\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker('getDropdownProps'); // Make initial ref false.\n\n  useEffect(() => {\n    isInitialMountRef.current = false;\n  }, []); // Event handler functions.\n\n  const selectedItemKeyDownHandlers = useMemo(() => ({\n    [keyNavigationPrevious]() {\n      dispatch({\n        type: SelectedItemKeyDownNavigationPrevious\n      });\n    },\n    [keyNavigationNext]() {\n      dispatch({\n        type: SelectedItemKeyDownNavigationNext\n      });\n    },\n    Delete() {\n      dispatch({\n        type: SelectedItemKeyDownDelete\n      });\n    },\n    Backspace() {\n      dispatch({\n        type: SelectedItemKeyDownBackspace\n      });\n    }\n  }), [dispatch, keyNavigationNext, keyNavigationPrevious]);\n  const dropdownKeyDownHandlers = useMemo(() => ({\n    [keyNavigationPrevious](event) {\n      if (isKeyDownOperationPermitted(event)) {\n        dispatch({\n          type: DropdownKeyDownNavigationPrevious\n        });\n      }\n    },\n    Backspace(event) {\n      if (isKeyDownOperationPermitted(event)) {\n        dispatch({\n          type: DropdownKeyDownBackspace\n        });\n      }\n    }\n  }), [dispatch, keyNavigationPrevious]); // Getter props.\n\n  const getSelectedItemProps = useCallback(function (_temp) {\n    let {\n      refKey = 'ref',\n      ref,\n      onClick,\n      onKeyDown,\n      selectedItem,\n      index,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    const {\n      state: latestState\n    } = latest.current;\n    const itemIndex = getItemIndex(index, selectedItem, latestState.selectedItems);\n    if (itemIndex < 0) {\n      throw new Error('Pass either selectedItem or index in getSelectedItemProps!');\n    }\n    const selectedItemHandleClick = () => {\n      dispatch({\n        type: SelectedItemClick,\n        index\n      });\n    };\n    const selectedItemHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n      if (key && selectedItemKeyDownHandlers[key]) {\n        selectedItemKeyDownHandlers[key](event);\n      }\n    };\n    return {\n      [refKey]: handleRefs(ref, selectedItemNode => {\n        if (selectedItemNode) {\n          selectedItemRefs.current.push(selectedItemNode);\n        }\n      }),\n      tabIndex: index === latestState.activeIndex ? 0 : -1,\n      onClick: callAllEventHandlers(onClick, selectedItemHandleClick),\n      onKeyDown: callAllEventHandlers(onKeyDown, selectedItemHandleKeyDown),\n      ...rest\n    };\n  }, [dispatch, latest, selectedItemKeyDownHandlers]);\n  const getDropdownProps = useCallback(function (_temp2, _temp3) {\n    let {\n      refKey = 'ref',\n      ref,\n      onKeyDown,\n      onClick,\n      preventKeyAction = false,\n      ...rest\n    } = _temp2 === void 0 ? {} : _temp2;\n    let {\n      suppressRefError = false\n    } = _temp3 === void 0 ? {} : _temp3;\n    setGetterPropCallInfo('getDropdownProps', suppressRefError, refKey, dropdownRef);\n    const dropdownHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n      if (key && dropdownKeyDownHandlers[key]) {\n        dropdownKeyDownHandlers[key](event);\n      }\n    };\n    const dropdownHandleClick = () => {\n      dispatch({\n        type: DropdownClick\n      });\n    };\n    return {\n      [refKey]: handleRefs(ref, dropdownNode => {\n        if (dropdownNode) {\n          dropdownRef.current = dropdownNode;\n        }\n      }),\n      ...(!preventKeyAction && {\n        onKeyDown: callAllEventHandlers(onKeyDown, dropdownHandleKeyDown),\n        onClick: callAllEventHandlers(onClick, dropdownHandleClick)\n      }),\n      ...rest\n    };\n  }, [dispatch, dropdownKeyDownHandlers, setGetterPropCallInfo]); // returns\n\n  const addSelectedItem = useCallback(selectedItem => {\n    dispatch({\n      type: FunctionAddSelectedItem,\n      selectedItem\n    });\n  }, [dispatch]);\n  const removeSelectedItem = useCallback(selectedItem => {\n    dispatch({\n      type: FunctionRemoveSelectedItem,\n      selectedItem\n    });\n  }, [dispatch]);\n  const setSelectedItems = useCallback(newSelectedItems => {\n    dispatch({\n      type: FunctionSetSelectedItems,\n      selectedItems: newSelectedItems\n    });\n  }, [dispatch]);\n  const setActiveIndex = useCallback(newActiveIndex => {\n    dispatch({\n      type: FunctionSetActiveIndex,\n      activeIndex: newActiveIndex\n    });\n  }, [dispatch]);\n  const reset = useCallback(() => {\n    dispatch({\n      type: FunctionReset\n    });\n  }, [dispatch]);\n  return {\n    getSelectedItemProps,\n    getDropdownProps,\n    addSelectedItem,\n    removeSelectedItem,\n    setSelectedItems,\n    setActiveIndex,\n    reset,\n    selectedItems,\n    activeIndex\n  };\n}\nexport { Downshift$1 as default, resetIdCounter, useCombobox, useMultipleSelection, useSelect };","map":{"version":3,"names":["PropTypes","Component","cloneElement","useRef","useEffect","useCallback","useLayoutEffect","useReducer","useMemo","isForwardRef","computeScrollIntoView","__assign","idCounter","cbToCb","cb","noop","scrollIntoView","node","menuNode","actions","boundary","block","scrollMode","forEach","_ref","el","top","left","scrollTop","scrollLeft","isOrContainsNode","parent","child","environment","result","Node","contains","debounce","fn","time","timeoutId","cancel","clearTimeout","wrapper","_len","arguments","length","args","Array","_key","setTimeout","callAllEventHandlers","_len2","fns","_key2","event","_len3","_key3","some","preventDownshiftDefault","hasOwnProperty","nativeEvent","handleRefs","_len4","refs","_key4","ref","current","generateId","String","resetIdCounter","getA11yStatusMessage$1","_ref2","isOpen","resultCount","previousResultCount","unwrapArray","arg","defaultValue","isArray","isDOMElement","element","type","getElementProps","props","requiredProp","fnName","propName","console","error","stateKeys","pickState","state","k","getState","Object","keys","reduce","prevState","key","isControlledProp","undefined","normalizeArrowKey","keyCode","indexOf","isPlainObject","obj","prototype","toString","call","getNextWrappingIndex","moveAmount","baseIndex","itemCount","getItemNodeFromIndex","circular","itemsLastIndex","newIndex","nonDisabledNewIndex","getNextNonDisabledIndex","currentElementNode","hasAttribute","index","targetWithinDownshift","target","downshiftElements","checkActiveElement","contextNode","document","activeElement","validateControlledUnchanged","process","env","NODE_ENV","prevProps","nextProps","warningDescription","propKey","cleanupStatus","documentProp","getStatusDiv","textContent","setStatus","status","div","statusDiv","getElementById","createElement","setAttribute","assign","style","border","clip","height","margin","overflow","padding","position","width","body","appendChild","unknown","mouseUp","itemMouseEnter","keyDownArrowUp","keyDownArrowDown","keyDownEscape","keyDownEnter","keyDownHome","keyDownEnd","clickItem","blurInput","changeInput","keyDownSpaceButton","clickButton","blurButton","controlledPropUpdatedSelectedItem","touchEnd","stateChangeTypes$3","freeze","__proto__","Downshift","constructor","_props","_this","id","menuId","labelId","inputId","getItemId","input","items","timeoutIds","internalSetTimeout","filter","i","push","setItemCount","count","unsetItemCount","setHighlightedIndex","highlightedIndex","otherStateToSet","defaultHighlightedIndex","internalSetState","clearSelection","selectedItem","inputValue","defaultIsOpen","selectItem","item","itemToString","selectItemAtIndex","itemIndex","selectHighlightedItem","stateToSet","isItemSelected","onChangeArg","onStateChangeArg","isStateToSetFunction","onInputValueChange","getStateAndHelpers","setState","newStateToSet","stateReducer","nextState","hasMoreStateThanType","onStateChange","onSelect","onChange","onUserAction","rootRef","_rootNode","getRootProps","_temp","_temp2","refKey","rest","suppressRefError","called","role","keyDownHandlers","ArrowDown","preventDefault","amount","shiftKey","moveHighlightedIndex","getItemCount","nextHighlightedIndex","ArrowUp","Enter","which","itemNode","Escape","reset","buttonKeyDownHandlers"," ","toggleMenu","inputKeyDownHandlers","Home","newHighlightedIndex","End","getToggleButtonProps","_temp3","onClick","onPress","onKeyDown","onKeyUp","onBlur","enabledEventHandlers","buttonHandleClick","buttonHandleKeyDown","buttonHandleKeyUp","buttonHandleBlur","eventHandlers","disabled","focus","blurTarget","isMouseDown","getLabelProps","htmlFor","getInputProps","_temp4","onInput","onChangeText","onChangeKey","inputHandleChange","inputHandleKeyDown","inputHandleBlur","autoComplete","value","downshiftButtonIsActive","dataset","toggle","menuRef","_menuNode","getMenuProps","_temp5","_temp6","getItemProps","_temp7","onMouseMove","onMouseDown","onSelectKey","customClickHandler","avoidScrolling","clearItems","openMenu","closeMenu","updateStatus","getA11yStatusMessage","highlightedItem","initialHighlightedIndex","_highlightedIndex","initialIsOpen","_isOpen","initialInputValue","_inputValue","initialSelectedItem","_selectedItem","_state","internalClearTimeouts","stateToMerge","scrollHighlightedItemIntoView","componentDidMount","validateGetMenuPropsCalledCorrectly","onMouseUp","contextWithinDownshift","onOuterClick","onTouchStart","isTouchMove","onTouchMove","onTouchEnd","addEventListener","cleanup","removeEventListener","shouldScroll","currentHighlightedIndex","prevHighlightedIndex","scrollWhenOpen","scrollWhenNavigating","componentDidUpdate","selectedItemChanged","componentWillUnmount","render","children","validateGetRootPropsCalledCorrectly","Error","defaultProps","warn","prevItem","window","stateChangeTypes","propTypes","func","number","bool","any","string","shape","Downshift$1","_ref3","_ref4","refKeySpecified","isComposite","dropdownDefaultStateValues","callOnChangeProps","action","newState","changes","invokeOnChangeHandler","handler","capitalizeString","s","a","getA11ySelectionMessage","selectionParameters","itemToStringLocal","updateA11yStatus","getA11yMessage","useIsomorphicLayoutEffect","useElementIds","toggleButtonId","elementIdsRef","getItemIndex","isAcceptedCharacterKey","test","slice","toUpperCase","useLatestRef","val","useEnhancedReducer","reducer","initialState","prevStateRef","actionRef","enhancedReducer","dispatch","propsRef","dispatchWithProps","useControlledReducer$1","defaultProps$3","circularNavigation","getDefaultValue$1","defaultStateValues","getInitialValue$1","initialValue","getInitialState$2","getHighlightedIndexOnOpen","offset","useMouseAndTouchTracker","downshiftElementRefs","handleBlur","mouseAndTouchTrackersRef","map","useGetterPropsCalledChecker","isInitialMountRef","propKeys","getterPropsCalledRef","acc","propCallInfo","elementRef","setGetterPropCallInfo","useA11yMessageSetter","dependencyArray","isInitialMount","useScrollIntoView","itemRefs","menuElement","scrollIntoViewProp","shouldScrollRef","useControlPropsValidator","prevPropsRef","downshiftCommonReducer","ItemMouseMove","MenuMouseLeave","ToggleButtonClick","FunctionToggleMenu","FunctionOpenMenu","FunctionCloseMenu","FunctionSetHighlightedIndex","FunctionSetInputValue","FunctionReset","getItemIndexByCharacterKey","_a","keysSoFar","lowerCasedKeysSoFar","toLowerCase","offsetIndex","startsWith","propTypes$2","array","isRequired","defaultSelectedItem","onSelectedItemChange","onHighlightedIndexChange","onIsOpenChange","concat","defaultProps$2","validatePropTypes$2","options","caller","checkPropTypes","name","MenuKeyDownArrowDown","MenuKeyDownArrowUp","MenuKeyDownEscape","MenuKeyDownHome","MenuKeyDownEnd","MenuKeyDownEnter","MenuKeyDownSpaceButton","MenuKeyDownCharacter","MenuBlur","MenuMouseLeave$1","ItemMouseMove$1","ItemClick$1","ToggleButtonClick$1","ToggleButtonKeyDownArrowDown","ToggleButtonKeyDownArrowUp","ToggleButtonKeyDownCharacter","FunctionToggleMenu$1","FunctionOpenMenu$1","FunctionCloseMenu$1","FunctionSetHighlightedIndex$1","FunctionSelectItem$1","FunctionSetInputValue$1","FunctionReset$2","stateChangeTypes$2","ItemClick","FunctionSelectItem","downshiftSelectReducer","lowercasedKey","useSelect","userProps","toggleButtonRef","shouldBlurRef","clearTimeoutRef","elementIds","previousResultCountRef","latest","outerDispatch","toggleButtonKeyDownHandlers","menuKeyDownHandlers","newSelectedItem","setInputValue","newInputValue","labelProps","onMouseLeave","latestState","menuHandleKeyDown","menuHandleBlur","shouldBlur","menuHandleMouseLeave","tabIndex","toggleButtonHandleClick","toggleButtonHandleKeyDown","toggleProps","toggleButtonNode","latestProps","itemHandleMouseMove","itemHandleClick","itemProps","InputKeyDownArrowDown","InputKeyDownArrowUp","InputKeyDownEscape","InputKeyDownHome","InputKeyDownEnd","InputKeyDownEnter","InputChange","InputBlur","FunctionReset$1","ControlledPropUpdatedSelectedItem","stateChangeTypes$1","getInitialState$1","defaultInputValue","propTypes$1","useControlledReducer","previousSelectedItemRef","validatePropTypes$1","defaultProps$1","downshiftUseComboboxReducer","useCombobox","inputRef","comboboxRef","focusOnOpen","itemHandleMouseDown","e","inputNode","getComboboxProps","_temp8","comboboxNode","activeIndex","selectedItems","getInitialValue","getDefaultValue","getInitialState","isKeyDownOperationPermitted","metaKey","ctrlKey","altKey","HTMLInputElement","selectionStart","selectionEnd","getA11yRemovalMessage","removedSelectedItem","initialSelectedItems","defaultSelectedItems","initialActiveIndex","defaultActiveIndex","onActiveIndexChange","onSelectedItemsChange","keyNavigationNext","keyNavigationPrevious","validatePropTypes","SelectedItemClick","SelectedItemKeyDownDelete","SelectedItemKeyDownBackspace","SelectedItemKeyDownNavigationNext","SelectedItemKeyDownNavigationPrevious","DropdownKeyDownNavigationPrevious","DropdownKeyDownBackspace","DropdownClick","FunctionAddSelectedItem","FunctionRemoveSelectedItem","FunctionSetSelectedItems","FunctionSetActiveIndex","downshiftMultipleSelectionReducer","newActiveIndex","selectedItemIndex","newSelectedItems","useMultipleSelection","dropdownRef","previousSelectedItemsRef","selectedItemRefs","find","activeSelectedItem","selectedItemKeyDownHandlers","Delete","Backspace","dropdownKeyDownHandlers","getSelectedItemProps","selectedItemHandleClick","selectedItemHandleKeyDown","selectedItemNode","getDropdownProps","preventKeyAction","dropdownHandleKeyDown","dropdownHandleClick","dropdownNode","addSelectedItem","removeSelectedItem","setSelectedItems","setActiveIndex","default"],"sources":["/Users/tsharliz/Documents/contentful/my-first-app/node_modules/downshift/dist/downshift.esm.js"],"sourcesContent":["import PropTypes from 'prop-types';\nimport { Component, cloneElement, useRef, useEffect, useCallback, useLayoutEffect, useReducer, useMemo } from 'react';\nimport { isForwardRef } from 'react-is';\nimport computeScrollIntoView from 'compute-scroll-into-view';\nimport { __assign } from 'tslib';\n\nlet idCounter = 0;\n/**\n * Accepts a parameter and returns it if it's a function\n * or a noop function if it's not. This allows us to\n * accept a callback, but not worry about it if it's not\n * passed.\n * @param {Function} cb the callback\n * @return {Function} a function\n */\n\nfunction cbToCb(cb) {\n  return typeof cb === 'function' ? cb : noop;\n}\n\nfunction noop() {}\n/**\n * Scroll node into view if necessary\n * @param {HTMLElement} node the element that should scroll into view\n * @param {HTMLElement} menuNode the menu element of the component\n */\n\n\nfunction scrollIntoView(node, menuNode) {\n  if (!node) {\n    return;\n  }\n\n  const actions = computeScrollIntoView(node, {\n    boundary: menuNode,\n    block: 'nearest',\n    scrollMode: 'if-needed'\n  });\n  actions.forEach(_ref => {\n    let {\n      el,\n      top,\n      left\n    } = _ref;\n    el.scrollTop = top;\n    el.scrollLeft = left;\n  });\n}\n/**\n * @param {HTMLElement} parent the parent node\n * @param {HTMLElement} child the child node\n * @param {Window} environment The window context where downshift renders.\n * @return {Boolean} whether the parent is the child or the child is in the parent\n */\n\n\nfunction isOrContainsNode(parent, child, environment) {\n  const result = parent === child || child instanceof environment.Node && parent.contains && parent.contains(child);\n  return result;\n}\n/**\n * Simple debounce implementation. Will call the given\n * function once after the time given has passed since\n * it was last called.\n * @param {Function} fn the function to call after the time\n * @param {Number} time the time to wait\n * @return {Function} the debounced function\n */\n\n\nfunction debounce(fn, time) {\n  let timeoutId;\n\n  function cancel() {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  function wrapper() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    cancel();\n    timeoutId = setTimeout(() => {\n      timeoutId = null;\n      fn(...args);\n    }, time);\n  }\n\n  wrapper.cancel = cancel;\n  return wrapper;\n}\n/**\n * This is intended to be used to compose event handlers.\n * They are executed in order until one of them sets\n * `event.preventDownshiftDefault = true`.\n * @param {...Function} fns the event handler functions\n * @return {Function} the event handler to add to an element\n */\n\n\nfunction callAllEventHandlers() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return function (event) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    return fns.some(fn => {\n      if (fn) {\n        fn(event, ...args);\n      }\n\n      return event.preventDownshiftDefault || event.hasOwnProperty('nativeEvent') && event.nativeEvent.preventDownshiftDefault;\n    });\n  };\n}\n\nfunction handleRefs() {\n  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    refs[_key4] = arguments[_key4];\n  }\n\n  return node => {\n    refs.forEach(ref => {\n      if (typeof ref === 'function') {\n        ref(node);\n      } else if (ref) {\n        ref.current = node;\n      }\n    });\n  };\n}\n/**\n * This generates a unique ID for an instance of Downshift\n * @return {String} the unique ID\n */\n\n\nfunction generateId() {\n  return String(idCounter++);\n}\n/**\n * Resets idCounter to 0. Used for SSR.\n */\n\n\nfunction resetIdCounter() {\n  idCounter = 0;\n}\n/**\n * Default implementation for status message. Only added when menu is open.\n * Will specify if there are results in the list, and if so, how many,\n * and what keys are relevant.\n *\n * @param {Object} param the downshift state and other relevant properties\n * @return {String} the a11y status message\n */\n\n\nfunction getA11yStatusMessage$1(_ref2) {\n  let {\n    isOpen,\n    resultCount,\n    previousResultCount\n  } = _ref2;\n\n  if (!isOpen) {\n    return '';\n  }\n\n  if (!resultCount) {\n    return 'No results are available.';\n  }\n\n  if (resultCount !== previousResultCount) {\n    return `${resultCount} result${resultCount === 1 ? ' is' : 's are'} available, use up and down arrow keys to navigate. Press Enter key to select.`;\n  }\n\n  return '';\n}\n/**\n * Takes an argument and if it's an array, returns the first item in the array\n * otherwise returns the argument\n * @param {*} arg the maybe-array\n * @param {*} defaultValue the value if arg is falsey not defined\n * @return {*} the arg or it's first item\n */\n\n\nfunction unwrapArray(arg, defaultValue) {\n  arg = Array.isArray(arg) ?\n  /* istanbul ignore next (preact) */\n  arg[0] : arg;\n\n  if (!arg && defaultValue) {\n    return defaultValue;\n  } else {\n    return arg;\n  }\n}\n/**\n * @param {Object} element (P)react element\n * @return {Boolean} whether it's a DOM element\n */\n\n\nfunction isDOMElement(element) {\n\n\n  return typeof element.type === 'string';\n}\n/**\n * @param {Object} element (P)react element\n * @return {Object} the props\n */\n\n\nfunction getElementProps(element) {\n\n  return element.props;\n}\n/**\n * Throws a helpful error message for required properties. Useful\n * to be used as a default in destructuring or object params.\n * @param {String} fnName the function name\n * @param {String} propName the prop name\n */\n\n\nfunction requiredProp(fnName, propName) {\n  // eslint-disable-next-line no-console\n  console.error(`The property \"${propName}\" is required in \"${fnName}\"`);\n}\n\nconst stateKeys = ['highlightedIndex', 'inputValue', 'isOpen', 'selectedItem', 'type'];\n/**\n * @param {Object} state the state object\n * @return {Object} state that is relevant to downshift\n */\n\nfunction pickState(state) {\n  if (state === void 0) {\n    state = {};\n  }\n\n  const result = {};\n  stateKeys.forEach(k => {\n    if (state.hasOwnProperty(k)) {\n      result[k] = state[k];\n    }\n  });\n  return result;\n}\n/**\n * This will perform a shallow merge of the given state object\n * with the state coming from props\n * (for the controlled component scenario)\n * This is used in state updater functions so they're referencing\n * the right state regardless of where it comes from.\n *\n * @param {Object} state The state of the component/hook.\n * @param {Object} props The props that may contain controlled values.\n * @returns {Object} The merged controlled state.\n */\n\n\nfunction getState(state, props) {\n  return Object.keys(state).reduce((prevState, key) => {\n    prevState[key] = isControlledProp(props, key) ? props[key] : state[key];\n    return prevState;\n  }, {});\n}\n/**\n * This determines whether a prop is a \"controlled prop\" meaning it is\n * state which is controlled by the outside of this component rather\n * than within this component.\n *\n * @param {Object} props The props that may contain controlled values.\n * @param {String} key the key to check\n * @return {Boolean} whether it is a controlled controlled prop\n */\n\n\nfunction isControlledProp(props, key) {\n  return props[key] !== undefined;\n}\n/**\n * Normalizes the 'key' property of a KeyboardEvent in IE/Edge\n * @param {Object} event a keyboardEvent object\n * @return {String} keyboard key\n */\n\n\nfunction normalizeArrowKey(event) {\n  const {\n    key,\n    keyCode\n  } = event;\n  /* istanbul ignore next (ie) */\n\n  if (keyCode >= 37 && keyCode <= 40 && key.indexOf('Arrow') !== 0) {\n    return `Arrow${key}`;\n  }\n\n  return key;\n}\n/**\n * Simple check if the value passed is object literal\n * @param {*} obj any things\n * @return {Boolean} whether it's object literal\n */\n\n\nfunction isPlainObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n/**\n * Returns the new index in the list, in a circular way. If next value is out of bonds from the total,\n * it will wrap to either 0 or itemCount - 1.\n *\n * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.\n * @param {number} baseIndex The initial position to move from.\n * @param {number} itemCount The total number of items.\n * @param {Function} getItemNodeFromIndex Used to check if item is disabled.\n * @param {boolean} circular Specify if navigation is circular. Default is true.\n * @returns {number} The new index after the move.\n */\n\n\nfunction getNextWrappingIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {\n  if (circular === void 0) {\n    circular = true;\n  }\n\n  if (itemCount === 0) {\n    return -1;\n  }\n\n  const itemsLastIndex = itemCount - 1;\n\n  if (typeof baseIndex !== 'number' || baseIndex < 0 || baseIndex >= itemCount) {\n    baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;\n  }\n\n  let newIndex = baseIndex + moveAmount;\n\n  if (newIndex < 0) {\n    newIndex = circular ? itemsLastIndex : 0;\n  } else if (newIndex > itemsLastIndex) {\n    newIndex = circular ? 0 : itemsLastIndex;\n  }\n\n  const nonDisabledNewIndex = getNextNonDisabledIndex(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular);\n\n  if (nonDisabledNewIndex === -1) {\n    return baseIndex >= itemCount ? -1 : baseIndex;\n  }\n\n  return nonDisabledNewIndex;\n}\n/**\n * Returns the next index in the list of an item that is not disabled.\n *\n * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.\n * @param {number} baseIndex The initial position to move from.\n * @param {number} itemCount The total number of items.\n * @param {Function} getItemNodeFromIndex Used to check if item is disabled.\n * @param {boolean} circular Specify if navigation is circular. Default is true.\n * @returns {number} The new index. Returns baseIndex if item is not disabled. Returns next non-disabled item otherwise. If no non-disabled found it will return -1.\n */\n\n\nfunction getNextNonDisabledIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {\n  const currentElementNode = getItemNodeFromIndex(baseIndex);\n\n  if (!currentElementNode || !currentElementNode.hasAttribute('disabled')) {\n    return baseIndex;\n  }\n\n  if (moveAmount > 0) {\n    for (let index = baseIndex + 1; index < itemCount; index++) {\n      if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {\n        return index;\n      }\n    }\n  } else {\n    for (let index = baseIndex - 1; index >= 0; index--) {\n      if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {\n        return index;\n      }\n    }\n  }\n\n  if (circular) {\n    return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);\n  }\n\n  return -1;\n}\n/**\n * Checks if event target is within the downshift elements.\n *\n * @param {EventTarget} target Target to check.\n * @param {HTMLElement[]} downshiftElements The elements that form downshift (list, toggle button etc).\n * @param {Window} environment The window context where downshift renders.\n * @param {boolean} checkActiveElement Whether to also check activeElement.\n *\n * @returns {boolean} Whether or not the target is within downshift elements.\n */\n\n\nfunction targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {\n  if (checkActiveElement === void 0) {\n    checkActiveElement = true;\n  }\n\n  return downshiftElements.some(contextNode => contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment)));\n} // eslint-disable-next-line import/no-mutable-exports\n\n\nlet validateControlledUnchanged = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validateControlledUnchanged = (state, prevProps, nextProps) => {\n    const warningDescription = `This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/downshift-js/downshift#control-props`;\n    Object.keys(state).forEach(propKey => {\n      if (prevProps[propKey] !== undefined && nextProps[propKey] === undefined) {\n        // eslint-disable-next-line no-console\n        console.error(`downshift: A component has changed the controlled prop \"${propKey}\" to be uncontrolled. ${warningDescription}`);\n      } else if (prevProps[propKey] === undefined && nextProps[propKey] !== undefined) {\n        // eslint-disable-next-line no-console\n        console.error(`downshift: A component has changed the uncontrolled prop \"${propKey}\" to be controlled. ${warningDescription}`);\n      }\n    });\n  };\n}\n\nconst cleanupStatus = debounce(documentProp => {\n  getStatusDiv(documentProp).textContent = '';\n}, 500);\n/**\n * @param {String} status the status message\n * @param {Object} documentProp document passed by the user.\n */\n\nfunction setStatus(status, documentProp) {\n  const div = getStatusDiv(documentProp);\n\n  if (!status) {\n    return;\n  }\n\n  div.textContent = status;\n  cleanupStatus(documentProp);\n}\n/**\n * Get the status node or create it if it does not already exist.\n * @param {Object} documentProp document passed by the user.\n * @return {HTMLElement} the status node.\n */\n\n\nfunction getStatusDiv(documentProp) {\n  if (documentProp === void 0) {\n    documentProp = document;\n  }\n\n  let statusDiv = documentProp.getElementById('a11y-status-message');\n\n  if (statusDiv) {\n    return statusDiv;\n  }\n\n  statusDiv = documentProp.createElement('div');\n  statusDiv.setAttribute('id', 'a11y-status-message');\n  statusDiv.setAttribute('role', 'status');\n  statusDiv.setAttribute('aria-live', 'polite');\n  statusDiv.setAttribute('aria-relevant', 'additions text');\n  Object.assign(statusDiv.style, {\n    border: '0',\n    clip: 'rect(0 0 0 0)',\n    height: '1px',\n    margin: '-1px',\n    overflow: 'hidden',\n    padding: '0',\n    position: 'absolute',\n    width: '1px'\n  });\n  documentProp.body.appendChild(statusDiv);\n  return statusDiv;\n}\n\nconst unknown = process.env.NODE_ENV !== \"production\" ? '__autocomplete_unknown__' : 0;\nconst mouseUp = process.env.NODE_ENV !== \"production\" ? '__autocomplete_mouseup__' : 1;\nconst itemMouseEnter = process.env.NODE_ENV !== \"production\" ? '__autocomplete_item_mouseenter__' : 2;\nconst keyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_arrow_up__' : 3;\nconst keyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_arrow_down__' : 4;\nconst keyDownEscape = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_escape__' : 5;\nconst keyDownEnter = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_enter__' : 6;\nconst keyDownHome = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_home__' : 7;\nconst keyDownEnd = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_end__' : 8;\nconst clickItem = process.env.NODE_ENV !== \"production\" ? '__autocomplete_click_item__' : 9;\nconst blurInput = process.env.NODE_ENV !== \"production\" ? '__autocomplete_blur_input__' : 10;\nconst changeInput = process.env.NODE_ENV !== \"production\" ? '__autocomplete_change_input__' : 11;\nconst keyDownSpaceButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_space_button__' : 12;\nconst clickButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_click_button__' : 13;\nconst blurButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_blur_button__' : 14;\nconst controlledPropUpdatedSelectedItem = process.env.NODE_ENV !== \"production\" ? '__autocomplete_controlled_prop_updated_selected_item__' : 15;\nconst touchEnd = process.env.NODE_ENV !== \"production\" ? '__autocomplete_touchend__' : 16;\n\nvar stateChangeTypes$3 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  unknown: unknown,\n  mouseUp: mouseUp,\n  itemMouseEnter: itemMouseEnter,\n  keyDownArrowUp: keyDownArrowUp,\n  keyDownArrowDown: keyDownArrowDown,\n  keyDownEscape: keyDownEscape,\n  keyDownEnter: keyDownEnter,\n  keyDownHome: keyDownHome,\n  keyDownEnd: keyDownEnd,\n  clickItem: clickItem,\n  blurInput: blurInput,\n  changeInput: changeInput,\n  keyDownSpaceButton: keyDownSpaceButton,\n  clickButton: clickButton,\n  blurButton: blurButton,\n  controlledPropUpdatedSelectedItem: controlledPropUpdatedSelectedItem,\n  touchEnd: touchEnd\n});\n\n/* eslint camelcase:0 */\n\nconst Downshift = /*#__PURE__*/(() => {\n  class Downshift extends Component {\n    constructor(_props) {\n      var _this;\n\n      super(_props);\n      _this = this;\n      this.id = this.props.id || `downshift-${generateId()}`;\n      this.menuId = this.props.menuId || `${this.id}-menu`;\n      this.labelId = this.props.labelId || `${this.id}-label`;\n      this.inputId = this.props.inputId || `${this.id}-input`;\n\n      this.getItemId = this.props.getItemId || (index => `${this.id}-item-${index}`);\n\n      this.input = null;\n      this.items = [];\n      this.itemCount = null;\n      this.previousResultCount = 0;\n      this.timeoutIds = [];\n\n      this.internalSetTimeout = (fn, time) => {\n        const id = setTimeout(() => {\n          this.timeoutIds = this.timeoutIds.filter(i => i !== id);\n          fn();\n        }, time);\n        this.timeoutIds.push(id);\n      };\n\n      this.setItemCount = count => {\n        this.itemCount = count;\n      };\n\n      this.unsetItemCount = () => {\n        this.itemCount = null;\n      };\n\n      this.setHighlightedIndex = function (highlightedIndex, otherStateToSet) {\n        if (highlightedIndex === void 0) {\n          highlightedIndex = _this.props.defaultHighlightedIndex;\n        }\n\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n\n        otherStateToSet = pickState(otherStateToSet);\n\n        _this.internalSetState({\n          highlightedIndex,\n          ...otherStateToSet\n        });\n      };\n\n      this.clearSelection = cb => {\n        this.internalSetState({\n          selectedItem: null,\n          inputValue: '',\n          highlightedIndex: this.props.defaultHighlightedIndex,\n          isOpen: this.props.defaultIsOpen\n        }, cb);\n      };\n\n      this.selectItem = (item, otherStateToSet, cb) => {\n        otherStateToSet = pickState(otherStateToSet);\n        this.internalSetState({\n          isOpen: this.props.defaultIsOpen,\n          highlightedIndex: this.props.defaultHighlightedIndex,\n          selectedItem: item,\n          inputValue: this.props.itemToString(item),\n          ...otherStateToSet\n        }, cb);\n      };\n\n      this.selectItemAtIndex = (itemIndex, otherStateToSet, cb) => {\n        const item = this.items[itemIndex];\n\n        if (item == null) {\n          return;\n        }\n\n        this.selectItem(item, otherStateToSet, cb);\n      };\n\n      this.selectHighlightedItem = (otherStateToSet, cb) => {\n        return this.selectItemAtIndex(this.getState().highlightedIndex, otherStateToSet, cb);\n      };\n\n      this.internalSetState = (stateToSet, cb) => {\n        let isItemSelected, onChangeArg;\n        const onStateChangeArg = {};\n        const isStateToSetFunction = typeof stateToSet === 'function'; // we want to call `onInputValueChange` before the `setState` call\n        // so someone controlling the `inputValue` state gets notified of\n        // the input change as soon as possible. This avoids issues with\n        // preserving the cursor position.\n        // See https://github.com/downshift-js/downshift/issues/217 for more info.\n\n        if (!isStateToSetFunction && stateToSet.hasOwnProperty('inputValue')) {\n          this.props.onInputValueChange(stateToSet.inputValue, { ...this.getStateAndHelpers(),\n            ...stateToSet\n          });\n        }\n\n        return this.setState(state => {\n          state = this.getState(state);\n          let newStateToSet = isStateToSetFunction ? stateToSet(state) : stateToSet; // Your own function that could modify the state that will be set.\n\n          newStateToSet = this.props.stateReducer(state, newStateToSet); // checks if an item is selected, regardless of if it's different from\n          // what was selected before\n          // used to determine if onSelect and onChange callbacks should be called\n\n          isItemSelected = newStateToSet.hasOwnProperty('selectedItem'); // this keeps track of the object we want to call with setState\n\n          const nextState = {}; // this is just used to tell whether the state changed\n          // and we're trying to update that state. OR if the selection has changed and we're\n          // trying to update the selection\n\n          if (isItemSelected && newStateToSet.selectedItem !== state.selectedItem) {\n            onChangeArg = newStateToSet.selectedItem;\n          }\n\n          newStateToSet.type = newStateToSet.type || unknown;\n          Object.keys(newStateToSet).forEach(key => {\n            // onStateChangeArg should only have the state that is\n            // actually changing\n            if (state[key] !== newStateToSet[key]) {\n              onStateChangeArg[key] = newStateToSet[key];\n            } // the type is useful for the onStateChangeArg\n            // but we don't actually want to set it in internal state.\n            // this is an undocumented feature for now... Not all internalSetState\n            // calls support it and I'm not certain we want them to yet.\n            // But it enables users controlling the isOpen state to know when\n            // the isOpen state changes due to mouseup events which is quite handy.\n\n\n            if (key === 'type') {\n              return;\n            }\n\n            newStateToSet[key]; // if it's coming from props, then we don't care to set it internally\n\n            if (!isControlledProp(this.props, key)) {\n              nextState[key] = newStateToSet[key];\n            }\n          }); // if stateToSet is a function, then we weren't able to call onInputValueChange\n          // earlier, so we'll call it now that we know what the inputValue state will be.\n\n          if (isStateToSetFunction && newStateToSet.hasOwnProperty('inputValue')) {\n            this.props.onInputValueChange(newStateToSet.inputValue, { ...this.getStateAndHelpers(),\n              ...newStateToSet\n            });\n          }\n\n          return nextState;\n        }, () => {\n          // call the provided callback if it's a function\n          cbToCb(cb)(); // only call the onStateChange and onChange callbacks if\n          // we have relevant information to pass them.\n\n          const hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;\n\n          if (hasMoreStateThanType) {\n            this.props.onStateChange(onStateChangeArg, this.getStateAndHelpers());\n          }\n\n          if (isItemSelected) {\n            this.props.onSelect(stateToSet.selectedItem, this.getStateAndHelpers());\n          }\n\n          if (onChangeArg !== undefined) {\n            this.props.onChange(onChangeArg, this.getStateAndHelpers());\n          } // this is currently undocumented and therefore subject to change\n          // We'll try to not break it, but just be warned.\n\n\n          this.props.onUserAction(onStateChangeArg, this.getStateAndHelpers());\n        });\n      };\n\n      this.rootRef = node => this._rootNode = node;\n\n      this.getRootProps = function (_temp, _temp2) {\n        let {\n          refKey = 'ref',\n          ref,\n          ...rest\n        } = _temp === void 0 ? {} : _temp;\n        let {\n          suppressRefError = false\n        } = _temp2 === void 0 ? {} : _temp2;\n        // this is used in the render to know whether the user has called getRootProps.\n        // It uses that to know whether to apply the props automatically\n        _this.getRootProps.called = true;\n        _this.getRootProps.refKey = refKey;\n        _this.getRootProps.suppressRefError = suppressRefError;\n\n        const {\n          isOpen\n        } = _this.getState();\n\n        return {\n          [refKey]: handleRefs(ref, _this.rootRef),\n          role: 'combobox',\n          'aria-expanded': isOpen,\n          'aria-haspopup': 'listbox',\n          'aria-owns': isOpen ? _this.menuId : null,\n          'aria-labelledby': _this.labelId,\n          ...rest\n        };\n      };\n\n      this.keyDownHandlers = {\n        ArrowDown(event) {\n          event.preventDefault();\n\n          if (this.getState().isOpen) {\n            const amount = event.shiftKey ? 5 : 1;\n            this.moveHighlightedIndex(amount, {\n              type: keyDownArrowDown\n            });\n          } else {\n            this.internalSetState({\n              isOpen: true,\n              type: keyDownArrowDown\n            }, () => {\n              const itemCount = this.getItemCount();\n\n              if (itemCount > 0) {\n                const {\n                  highlightedIndex\n                } = this.getState();\n                const nextHighlightedIndex = getNextWrappingIndex(1, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));\n                this.setHighlightedIndex(nextHighlightedIndex, {\n                  type: keyDownArrowDown\n                });\n              }\n            });\n          }\n        },\n\n        ArrowUp(event) {\n          event.preventDefault();\n\n          if (this.getState().isOpen) {\n            const amount = event.shiftKey ? -5 : -1;\n            this.moveHighlightedIndex(amount, {\n              type: keyDownArrowUp\n            });\n          } else {\n            this.internalSetState({\n              isOpen: true,\n              type: keyDownArrowUp\n            }, () => {\n              const itemCount = this.getItemCount();\n\n              if (itemCount > 0) {\n                const {\n                  highlightedIndex\n                } = this.getState();\n                const nextHighlightedIndex = getNextWrappingIndex(-1, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));\n                this.setHighlightedIndex(nextHighlightedIndex, {\n                  type: keyDownArrowUp\n                });\n              }\n            });\n          }\n        },\n\n        Enter(event) {\n          if (event.which === 229) {\n            return;\n          }\n\n          const {\n            isOpen,\n            highlightedIndex\n          } = this.getState();\n\n          if (isOpen && highlightedIndex != null) {\n            event.preventDefault();\n            const item = this.items[highlightedIndex];\n            const itemNode = this.getItemNodeFromIndex(highlightedIndex);\n\n            if (item == null || itemNode && itemNode.hasAttribute('disabled')) {\n              return;\n            }\n\n            this.selectHighlightedItem({\n              type: keyDownEnter\n            });\n          }\n        },\n\n        Escape(event) {\n          event.preventDefault();\n          this.reset({\n            type: keyDownEscape,\n            ...(!this.state.isOpen && {\n              selectedItem: null,\n              inputValue: ''\n            })\n          });\n        }\n\n      };\n      this.buttonKeyDownHandlers = { ...this.keyDownHandlers,\n\n        ' '(event) {\n          event.preventDefault();\n          this.toggleMenu({\n            type: keyDownSpaceButton\n          });\n        }\n\n      };\n      this.inputKeyDownHandlers = { ...this.keyDownHandlers,\n\n        Home(event) {\n          const {\n            isOpen\n          } = this.getState();\n\n          if (!isOpen) {\n            return;\n          }\n\n          event.preventDefault();\n          const itemCount = this.getItemCount();\n\n          if (itemCount <= 0 || !isOpen) {\n            return;\n          } // get next non-disabled starting downwards from 0 if that's disabled.\n\n\n          const newHighlightedIndex = getNextNonDisabledIndex(1, 0, itemCount, index => this.getItemNodeFromIndex(index), false);\n          this.setHighlightedIndex(newHighlightedIndex, {\n            type: keyDownHome\n          });\n        },\n\n        End(event) {\n          const {\n            isOpen\n          } = this.getState();\n\n          if (!isOpen) {\n            return;\n          }\n\n          event.preventDefault();\n          const itemCount = this.getItemCount();\n\n          if (itemCount <= 0 || !isOpen) {\n            return;\n          } // get next non-disabled starting upwards from last index if that's disabled.\n\n\n          const newHighlightedIndex = getNextNonDisabledIndex(-1, itemCount - 1, itemCount, index => this.getItemNodeFromIndex(index), false);\n          this.setHighlightedIndex(newHighlightedIndex, {\n            type: keyDownEnd\n          });\n        }\n\n      };\n\n      this.getToggleButtonProps = function (_temp3) {\n        let {\n          onClick,\n          onPress,\n          onKeyDown,\n          onKeyUp,\n          onBlur,\n          ...rest\n        } = _temp3 === void 0 ? {} : _temp3;\n\n        const {\n          isOpen\n        } = _this.getState();\n\n        const enabledEventHandlers = {\n          onClick: callAllEventHandlers(onClick, _this.buttonHandleClick),\n          onKeyDown: callAllEventHandlers(onKeyDown, _this.buttonHandleKeyDown),\n          onKeyUp: callAllEventHandlers(onKeyUp, _this.buttonHandleKeyUp),\n          onBlur: callAllEventHandlers(onBlur, _this.buttonHandleBlur)\n        };\n        const eventHandlers = rest.disabled ? {} : enabledEventHandlers;\n        return {\n          type: 'button',\n          role: 'button',\n          'aria-label': isOpen ? 'close menu' : 'open menu',\n          'aria-haspopup': true,\n          'data-toggle': true,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n\n      this.buttonHandleKeyUp = event => {\n        // Prevent click event from emitting in Firefox\n        event.preventDefault();\n      };\n\n      this.buttonHandleKeyDown = event => {\n        const key = normalizeArrowKey(event);\n\n        if (this.buttonKeyDownHandlers[key]) {\n          this.buttonKeyDownHandlers[key].call(this, event);\n        }\n      };\n\n      this.buttonHandleClick = event => {\n        event.preventDefault(); // handle odd case for Safari and Firefox which\n        // don't give the button the focus properly.\n\n        /* istanbul ignore if (can't reasonably test this) */\n\n        if (this.props.environment.document.activeElement === this.props.environment.document.body) {\n          event.target.focus();\n        } // to simplify testing components that use downshift, we'll not wrap this in a setTimeout\n        // if the NODE_ENV is test. With the proper build system, this should be dead code eliminated\n        // when building for production and should therefore have no impact on production code.\n\n\n        if (process.env.NODE_ENV === 'test') {\n          this.toggleMenu({\n            type: clickButton\n          });\n        } else {\n          // Ensure that toggle of menu occurs after the potential blur event in iOS\n          this.internalSetTimeout(() => this.toggleMenu({\n            type: clickButton\n          }));\n        }\n      };\n\n      this.buttonHandleBlur = event => {\n        const blurTarget = event.target; // Save blur target for comparison with activeElement later\n        // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not body element\n\n        this.internalSetTimeout(() => {\n          if (!this.isMouseDown && (this.props.environment.document.activeElement == null || this.props.environment.document.activeElement.id !== this.inputId) && this.props.environment.document.activeElement !== blurTarget // Do nothing if we refocus the same element again (to solve issue in Safari on iOS)\n          ) {\n            this.reset({\n              type: blurButton\n            });\n          }\n        });\n      };\n\n      this.getLabelProps = props => {\n        return {\n          htmlFor: this.inputId,\n          id: this.labelId,\n          ...props\n        };\n      };\n\n      this.getInputProps = function (_temp4) {\n        let {\n          onKeyDown,\n          onBlur,\n          onChange,\n          onInput,\n          onChangeText,\n          ...rest\n        } = _temp4 === void 0 ? {} : _temp4;\n        let onChangeKey;\n        let eventHandlers = {};\n        /* istanbul ignore next (preact) */\n\n        {\n          onChangeKey = 'onChange';\n        }\n\n        const {\n          inputValue,\n          isOpen,\n          highlightedIndex\n        } = _this.getState();\n\n        if (!rest.disabled) {\n          eventHandlers = {\n            [onChangeKey]: callAllEventHandlers(onChange, onInput, _this.inputHandleChange),\n            onKeyDown: callAllEventHandlers(onKeyDown, _this.inputHandleKeyDown),\n            onBlur: callAllEventHandlers(onBlur, _this.inputHandleBlur)\n          };\n        }\n\n        return {\n          'aria-autocomplete': 'list',\n          'aria-activedescendant': isOpen && typeof highlightedIndex === 'number' && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : null,\n          'aria-controls': isOpen ? _this.menuId : null,\n          'aria-labelledby': _this.labelId,\n          // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion\n          // revert back since autocomplete=\"nope\" is ignored on latest Chrome and Opera\n          autoComplete: 'off',\n          value: inputValue,\n          id: _this.inputId,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n\n      this.inputHandleKeyDown = event => {\n        const key = normalizeArrowKey(event);\n\n        if (key && this.inputKeyDownHandlers[key]) {\n          this.inputKeyDownHandlers[key].call(this, event);\n        }\n      };\n\n      this.inputHandleChange = event => {\n        this.internalSetState({\n          type: changeInput,\n          isOpen: true,\n          inputValue: event.target.value,\n          highlightedIndex: this.props.defaultHighlightedIndex\n        });\n      };\n\n      this.inputHandleBlur = () => {\n        // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not the body element\n        this.internalSetTimeout(() => {\n          const downshiftButtonIsActive = this.props.environment.document && !!this.props.environment.document.activeElement && !!this.props.environment.document.activeElement.dataset && this.props.environment.document.activeElement.dataset.toggle && this._rootNode && this._rootNode.contains(this.props.environment.document.activeElement);\n\n          if (!this.isMouseDown && !downshiftButtonIsActive) {\n            this.reset({\n              type: blurInput\n            });\n          }\n        });\n      };\n\n      this.menuRef = node => {\n        this._menuNode = node;\n      };\n\n      this.getMenuProps = function (_temp5, _temp6) {\n        let {\n          refKey = 'ref',\n          ref,\n          ...props\n        } = _temp5 === void 0 ? {} : _temp5;\n        let {\n          suppressRefError = false\n        } = _temp6 === void 0 ? {} : _temp6;\n        _this.getMenuProps.called = true;\n        _this.getMenuProps.refKey = refKey;\n        _this.getMenuProps.suppressRefError = suppressRefError;\n        return {\n          [refKey]: handleRefs(ref, _this.menuRef),\n          role: 'listbox',\n          'aria-labelledby': props && props['aria-label'] ? null : _this.labelId,\n          id: _this.menuId,\n          ...props\n        };\n      };\n\n      this.getItemProps = function (_temp7) {\n        let {\n          onMouseMove,\n          onMouseDown,\n          onClick,\n          onPress,\n          index,\n          item = process.env.NODE_ENV === 'production' ?\n          /* istanbul ignore next */\n          undefined : requiredProp('getItemProps', 'item'),\n          ...rest\n        } = _temp7 === void 0 ? {} : _temp7;\n\n        if (index === undefined) {\n          _this.items.push(item);\n\n          index = _this.items.indexOf(item);\n        } else {\n          _this.items[index] = item;\n        }\n\n        const onSelectKey = 'onClick';\n        const customClickHandler = onClick;\n        const enabledEventHandlers = {\n          // onMouseMove is used over onMouseEnter here. onMouseMove\n          // is only triggered on actual mouse movement while onMouseEnter\n          // can fire on DOM changes, interrupting keyboard navigation\n          onMouseMove: callAllEventHandlers(onMouseMove, () => {\n            if (index === _this.getState().highlightedIndex) {\n              return;\n            }\n\n            _this.setHighlightedIndex(index, {\n              type: itemMouseEnter\n            }); // We never want to manually scroll when changing state based\n            // on `onMouseMove` because we will be moving the element out\n            // from under the user which is currently scrolling/moving the\n            // cursor\n\n\n            _this.avoidScrolling = true;\n\n            _this.internalSetTimeout(() => _this.avoidScrolling = false, 250);\n          }),\n          onMouseDown: callAllEventHandlers(onMouseDown, event => {\n            // This prevents the activeElement from being changed\n            // to the item so it can remain with the current activeElement\n            // which is a more common use case.\n            event.preventDefault();\n          }),\n          [onSelectKey]: callAllEventHandlers(customClickHandler, () => {\n            _this.selectItemAtIndex(index, {\n              type: clickItem\n            });\n          })\n        }; // Passing down the onMouseDown handler to prevent redirect\n        // of the activeElement if clicking on disabled items\n\n        const eventHandlers = rest.disabled ? {\n          onMouseDown: enabledEventHandlers.onMouseDown\n        } : enabledEventHandlers;\n        return {\n          id: _this.getItemId(index),\n          role: 'option',\n          'aria-selected': _this.getState().highlightedIndex === index,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n\n      this.clearItems = () => {\n        this.items = [];\n      };\n\n      this.reset = function (otherStateToSet, cb) {\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n\n        otherStateToSet = pickState(otherStateToSet);\n\n        _this.internalSetState(_ref => {\n          let {\n            selectedItem\n          } = _ref;\n          return {\n            isOpen: _this.props.defaultIsOpen,\n            highlightedIndex: _this.props.defaultHighlightedIndex,\n            inputValue: _this.props.itemToString(selectedItem),\n            ...otherStateToSet\n          };\n        }, cb);\n      };\n\n      this.toggleMenu = function (otherStateToSet, cb) {\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n\n        otherStateToSet = pickState(otherStateToSet);\n\n        _this.internalSetState(_ref2 => {\n          let {\n            isOpen\n          } = _ref2;\n          return {\n            isOpen: !isOpen,\n            ...(isOpen && {\n              highlightedIndex: _this.props.defaultHighlightedIndex\n            }),\n            ...otherStateToSet\n          };\n        }, () => {\n          const {\n            isOpen,\n            highlightedIndex\n          } = _this.getState();\n\n          if (isOpen) {\n            if (_this.getItemCount() > 0 && typeof highlightedIndex === 'number') {\n              _this.setHighlightedIndex(highlightedIndex, otherStateToSet);\n            }\n          }\n\n          cbToCb(cb)();\n        });\n      };\n\n      this.openMenu = cb => {\n        this.internalSetState({\n          isOpen: true\n        }, cb);\n      };\n\n      this.closeMenu = cb => {\n        this.internalSetState({\n          isOpen: false\n        }, cb);\n      };\n\n      this.updateStatus = debounce(() => {\n        const state = this.getState();\n        const item = this.items[state.highlightedIndex];\n        const resultCount = this.getItemCount();\n        const status = this.props.getA11yStatusMessage({\n          itemToString: this.props.itemToString,\n          previousResultCount: this.previousResultCount,\n          resultCount,\n          highlightedItem: item,\n          ...state\n        });\n        this.previousResultCount = resultCount;\n        setStatus(status, this.props.environment.document);\n      }, 200);\n      // fancy destructuring + defaults + aliases\n      // this basically says each value of state should either be set to\n      // the initial value or the default value if the initial value is not provided\n      const {\n        defaultHighlightedIndex,\n        initialHighlightedIndex: _highlightedIndex = defaultHighlightedIndex,\n        defaultIsOpen,\n        initialIsOpen: _isOpen = defaultIsOpen,\n        initialInputValue: _inputValue = '',\n        initialSelectedItem: _selectedItem = null\n      } = this.props;\n\n      const _state = this.getState({\n        highlightedIndex: _highlightedIndex,\n        isOpen: _isOpen,\n        inputValue: _inputValue,\n        selectedItem: _selectedItem\n      });\n\n      if (_state.selectedItem != null && this.props.initialInputValue === undefined) {\n        _state.inputValue = this.props.itemToString(_state.selectedItem);\n      }\n\n      this.state = _state;\n    }\n\n    /**\n     * Clear all running timeouts\n     */\n    internalClearTimeouts() {\n      this.timeoutIds.forEach(id => {\n        clearTimeout(id);\n      });\n      this.timeoutIds = [];\n    }\n    /**\n     * Gets the state based on internal state or props\n     * If a state value is passed via props, then that\n     * is the value given, otherwise it's retrieved from\n     * stateToMerge\n     *\n     * @param {Object} stateToMerge defaults to this.state\n     * @return {Object} the state\n     */\n\n\n    getState(stateToMerge) {\n      if (stateToMerge === void 0) {\n        stateToMerge = this.state;\n      }\n\n      return getState(stateToMerge, this.props);\n    }\n\n    getItemCount() {\n      // things read better this way. They're in priority order:\n      // 1. `this.itemCount`\n      // 2. `this.props.itemCount`\n      // 3. `this.items.length`\n      let itemCount = this.items.length;\n\n      if (this.itemCount != null) {\n        itemCount = this.itemCount;\n      } else if (this.props.itemCount !== undefined) {\n        itemCount = this.props.itemCount;\n      }\n\n      return itemCount;\n    }\n\n    getItemNodeFromIndex(index) {\n      return this.props.environment.document.getElementById(this.getItemId(index));\n    }\n\n    scrollHighlightedItemIntoView() {\n      /* istanbul ignore else (react-native) */\n      {\n        const node = this.getItemNodeFromIndex(this.getState().highlightedIndex);\n        this.props.scrollIntoView(node, this._menuNode);\n      }\n    }\n\n    moveHighlightedIndex(amount, otherStateToSet) {\n      const itemCount = this.getItemCount();\n      const {\n        highlightedIndex\n      } = this.getState();\n\n      if (itemCount > 0) {\n        const nextHighlightedIndex = getNextWrappingIndex(amount, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));\n        this.setHighlightedIndex(nextHighlightedIndex, otherStateToSet);\n      }\n    }\n\n    getStateAndHelpers() {\n      const {\n        highlightedIndex,\n        inputValue,\n        selectedItem,\n        isOpen\n      } = this.getState();\n      const {\n        itemToString\n      } = this.props;\n      const {\n        id\n      } = this;\n      const {\n        getRootProps,\n        getToggleButtonProps,\n        getLabelProps,\n        getMenuProps,\n        getInputProps,\n        getItemProps,\n        openMenu,\n        closeMenu,\n        toggleMenu,\n        selectItem,\n        selectItemAtIndex,\n        selectHighlightedItem,\n        setHighlightedIndex,\n        clearSelection,\n        clearItems,\n        reset,\n        setItemCount,\n        unsetItemCount,\n        internalSetState: setState\n      } = this;\n      return {\n        // prop getters\n        getRootProps,\n        getToggleButtonProps,\n        getLabelProps,\n        getMenuProps,\n        getInputProps,\n        getItemProps,\n        // actions\n        reset,\n        openMenu,\n        closeMenu,\n        toggleMenu,\n        selectItem,\n        selectItemAtIndex,\n        selectHighlightedItem,\n        setHighlightedIndex,\n        clearSelection,\n        clearItems,\n        setItemCount,\n        unsetItemCount,\n        setState,\n        // props\n        itemToString,\n        // derived\n        id,\n        // state\n        highlightedIndex,\n        inputValue,\n        isOpen,\n        selectedItem\n      };\n    } //////////////////////////// ROOT\n\n\n    componentDidMount() {\n      /* istanbul ignore if (react-native) */\n      if (process.env.NODE_ENV !== 'production' && !false && this.getMenuProps.called && !this.getMenuProps.suppressRefError) {\n        validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);\n      }\n      /* istanbul ignore if (react-native) */\n\n\n      {\n        // this.isMouseDown helps us track whether the mouse is currently held down.\n        // This is useful when the user clicks on an item in the list, but holds the mouse\n        // down long enough for the list to disappear (because the blur event fires on the input)\n        // this.isMouseDown is used in the blur handler on the input to determine whether the blur event should\n        // trigger hiding the menu.\n        const onMouseDown = () => {\n          this.isMouseDown = true;\n        };\n\n        const onMouseUp = event => {\n          this.isMouseDown = false; // if the target element or the activeElement is within a downshift node\n          // then we don't want to reset downshift\n\n          const contextWithinDownshift = targetWithinDownshift(event.target, [this._rootNode, this._menuNode], this.props.environment);\n\n          if (!contextWithinDownshift && this.getState().isOpen) {\n            this.reset({\n              type: mouseUp\n            }, () => this.props.onOuterClick(this.getStateAndHelpers()));\n          }\n        }; // Touching an element in iOS gives focus and hover states, but touching out of\n        // the element will remove hover, and persist the focus state, resulting in the\n        // blur event not being triggered.\n        // this.isTouchMove helps us track whether the user is tapping or swiping on a touch screen.\n        // If the user taps outside of Downshift, the component should be reset,\n        // but not if the user is swiping\n\n\n        const onTouchStart = () => {\n          this.isTouchMove = false;\n        };\n\n        const onTouchMove = () => {\n          this.isTouchMove = true;\n        };\n\n        const onTouchEnd = event => {\n          const contextWithinDownshift = targetWithinDownshift(event.target, [this._rootNode, this._menuNode], this.props.environment, false);\n\n          if (!this.isTouchMove && !contextWithinDownshift && this.getState().isOpen) {\n            this.reset({\n              type: touchEnd\n            }, () => this.props.onOuterClick(this.getStateAndHelpers()));\n          }\n        };\n\n        const {\n          environment\n        } = this.props;\n        environment.addEventListener('mousedown', onMouseDown);\n        environment.addEventListener('mouseup', onMouseUp);\n        environment.addEventListener('touchstart', onTouchStart);\n        environment.addEventListener('touchmove', onTouchMove);\n        environment.addEventListener('touchend', onTouchEnd);\n\n        this.cleanup = () => {\n          this.internalClearTimeouts();\n          this.updateStatus.cancel();\n          environment.removeEventListener('mousedown', onMouseDown);\n          environment.removeEventListener('mouseup', onMouseUp);\n          environment.removeEventListener('touchstart', onTouchStart);\n          environment.removeEventListener('touchmove', onTouchMove);\n          environment.removeEventListener('touchend', onTouchEnd);\n        };\n      }\n    }\n\n    shouldScroll(prevState, prevProps) {\n      const {\n        highlightedIndex: currentHighlightedIndex\n      } = this.props.highlightedIndex === undefined ? this.getState() : this.props;\n      const {\n        highlightedIndex: prevHighlightedIndex\n      } = prevProps.highlightedIndex === undefined ? prevState : prevProps;\n      const scrollWhenOpen = currentHighlightedIndex && this.getState().isOpen && !prevState.isOpen;\n      const scrollWhenNavigating = currentHighlightedIndex !== prevHighlightedIndex;\n      return scrollWhenOpen || scrollWhenNavigating;\n    }\n\n    componentDidUpdate(prevProps, prevState) {\n      if (process.env.NODE_ENV !== 'production') {\n        validateControlledUnchanged(this.state, prevProps, this.props);\n        /* istanbul ignore if (react-native) */\n\n        if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {\n          validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);\n        }\n      }\n\n      if (isControlledProp(this.props, 'selectedItem') && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {\n        this.internalSetState({\n          type: controlledPropUpdatedSelectedItem,\n          inputValue: this.props.itemToString(this.props.selectedItem)\n        });\n      }\n\n      if (!this.avoidScrolling && this.shouldScroll(prevState, prevProps)) {\n        this.scrollHighlightedItemIntoView();\n      }\n      /* istanbul ignore else (react-native) */\n\n\n      {\n        this.updateStatus();\n      }\n    }\n\n    componentWillUnmount() {\n      this.cleanup(); // avoids memory leak\n    }\n\n    render() {\n      const children = unwrapArray(this.props.children, noop); // because the items are rerendered every time we call the children\n      // we clear this out each render and it will be populated again as\n      // getItemProps is called.\n\n      this.clearItems(); // we reset this so we know whether the user calls getRootProps during\n      // this render. If they do then we don't need to do anything,\n      // if they don't then we need to clone the element they return and\n      // apply the props for them.\n\n      this.getRootProps.called = false;\n      this.getRootProps.refKey = undefined;\n      this.getRootProps.suppressRefError = undefined; // we do something similar for getMenuProps\n\n      this.getMenuProps.called = false;\n      this.getMenuProps.refKey = undefined;\n      this.getMenuProps.suppressRefError = undefined; // we do something similar for getLabelProps\n\n      this.getLabelProps.called = false; // and something similar for getInputProps\n\n      this.getInputProps.called = false;\n      const element = unwrapArray(children(this.getStateAndHelpers()));\n\n      if (!element) {\n        return null;\n      }\n\n      if (this.getRootProps.called || this.props.suppressRefError) {\n        if (process.env.NODE_ENV !== 'production' && !this.getRootProps.suppressRefError && !this.props.suppressRefError) {\n          validateGetRootPropsCalledCorrectly(element, this.getRootProps);\n        }\n\n        return element;\n      } else if (isDOMElement(element)) {\n        // they didn't apply the root props, but we can clone\n        // this and apply the props ourselves\n        return /*#__PURE__*/cloneElement(element, this.getRootProps(getElementProps(element)));\n      }\n      /* istanbul ignore else */\n\n\n      if (process.env.NODE_ENV !== 'production') {\n        // they didn't apply the root props, but they need to\n        // otherwise we can't query around the autocomplete\n        throw new Error('downshift: If you return a non-DOM element, you must apply the getRootProps function');\n      }\n      /* istanbul ignore next */\n\n\n      return undefined;\n    }\n\n  }\n\n  Downshift.defaultProps = {\n    defaultHighlightedIndex: null,\n    defaultIsOpen: false,\n    getA11yStatusMessage: getA11yStatusMessage$1,\n    itemToString: i => {\n      if (i == null) {\n        return '';\n      }\n\n      if (process.env.NODE_ENV !== 'production' && isPlainObject(i) && !i.hasOwnProperty('toString')) {\n        // eslint-disable-next-line no-console\n        console.warn('downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.', 'The object that was passed:', i);\n      }\n\n      return String(i);\n    },\n    onStateChange: noop,\n    onInputValueChange: noop,\n    onUserAction: noop,\n    onChange: noop,\n    onSelect: noop,\n    onOuterClick: noop,\n    selectedItemChanged: (prevItem, item) => prevItem !== item,\n    environment:\n    /* istanbul ignore next (ssr) */\n    typeof window === 'undefined' ? {} : window,\n    stateReducer: (state, stateToSet) => stateToSet,\n    suppressRefError: false,\n    scrollIntoView\n  };\n  Downshift.stateChangeTypes = stateChangeTypes$3;\n  return Downshift;\n})();\n\nprocess.env.NODE_ENV !== \"production\" ? Downshift.propTypes = {\n  children: PropTypes.func,\n  defaultHighlightedIndex: PropTypes.number,\n  defaultIsOpen: PropTypes.bool,\n  initialHighlightedIndex: PropTypes.number,\n  initialSelectedItem: PropTypes.any,\n  initialInputValue: PropTypes.string,\n  initialIsOpen: PropTypes.bool,\n  getA11yStatusMessage: PropTypes.func,\n  itemToString: PropTypes.func,\n  onChange: PropTypes.func,\n  onSelect: PropTypes.func,\n  onStateChange: PropTypes.func,\n  onInputValueChange: PropTypes.func,\n  onUserAction: PropTypes.func,\n  onOuterClick: PropTypes.func,\n  selectedItemChanged: PropTypes.func,\n  stateReducer: PropTypes.func,\n  itemCount: PropTypes.number,\n  id: PropTypes.string,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  }),\n  suppressRefError: PropTypes.bool,\n  scrollIntoView: PropTypes.func,\n  // things we keep in state for uncontrolled components\n  // but can accept as props for controlled components\n\n  /* eslint-disable react/no-unused-prop-types */\n  selectedItem: PropTypes.any,\n  isOpen: PropTypes.bool,\n  inputValue: PropTypes.string,\n  highlightedIndex: PropTypes.number,\n  labelId: PropTypes.string,\n  inputId: PropTypes.string,\n  menuId: PropTypes.string,\n  getItemId: PropTypes.func\n  /* eslint-enable react/no-unused-prop-types */\n\n} : void 0;\nvar Downshift$1 = Downshift;\n\nfunction validateGetMenuPropsCalledCorrectly(node, _ref3) {\n  let {\n    refKey\n  } = _ref3;\n\n  if (!node) {\n    // eslint-disable-next-line no-console\n    console.error(`downshift: The ref prop \"${refKey}\" from getMenuProps was not applied correctly on your menu element.`);\n  }\n}\n\nfunction validateGetRootPropsCalledCorrectly(element, _ref4) {\n  let {\n    refKey\n  } = _ref4;\n  const refKeySpecified = refKey !== 'ref';\n  const isComposite = !isDOMElement(element);\n\n  if (isComposite && !refKeySpecified && !isForwardRef(element)) {\n    // eslint-disable-next-line no-console\n    console.error('downshift: You returned a non-DOM element. You must specify a refKey in getRootProps');\n  } else if (!isComposite && refKeySpecified) {\n    // eslint-disable-next-line no-console\n    console.error(`downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified \"${refKey}\"`);\n  }\n\n  if (!isForwardRef(element) && !getElementProps(element)[refKey]) {\n    // eslint-disable-next-line no-console\n    console.error(`downshift: You must apply the ref prop \"${refKey}\" from getRootProps onto your root element.`);\n  }\n}\n\nconst dropdownDefaultStateValues = {\n  highlightedIndex: -1,\n  isOpen: false,\n  selectedItem: null,\n  inputValue: ''\n};\n\nfunction callOnChangeProps(action, state, newState) {\n  const {\n    props,\n    type\n  } = action;\n  const changes = {};\n  Object.keys(state).forEach(key => {\n    invokeOnChangeHandler(key, action, state, newState);\n\n    if (newState[key] !== state[key]) {\n      changes[key] = newState[key];\n    }\n  });\n\n  if (props.onStateChange && Object.keys(changes).length) {\n    props.onStateChange({\n      type,\n      ...changes\n    });\n  }\n}\n\nfunction invokeOnChangeHandler(key, action, state, newState) {\n  const {\n    props,\n    type\n  } = action;\n  const handler = `on${capitalizeString(key)}Change`;\n\n  if (props[handler] && newState[key] !== undefined && newState[key] !== state[key]) {\n    props[handler]({\n      type,\n      ...newState\n    });\n  }\n}\n/**\n * Default state reducer that returns the changes.\n *\n * @param {Object} s state.\n * @param {Object} a action with changes.\n * @returns {Object} changes.\n */\n\n\nfunction stateReducer(s, a) {\n  return a.changes;\n}\n/**\n * Returns a message to be added to aria-live region when item is selected.\n *\n * @param {Object} selectionParameters Parameters required to build the message.\n * @returns {string} The a11y message.\n */\n\n\nfunction getA11ySelectionMessage(selectionParameters) {\n  const {\n    selectedItem,\n    itemToString: itemToStringLocal\n  } = selectionParameters;\n  return selectedItem ? `${itemToStringLocal(selectedItem)} has been selected.` : '';\n}\n/**\n * Debounced call for updating the a11y message.\n */\n\n\nconst updateA11yStatus = debounce((getA11yMessage, document) => {\n  setStatus(getA11yMessage(), document);\n}, 200); // istanbul ignore next\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? useLayoutEffect : useEffect;\n\nfunction useElementIds(_ref) {\n  let {\n    id = `downshift-${generateId()}`,\n    labelId,\n    menuId,\n    getItemId,\n    toggleButtonId,\n    inputId\n  } = _ref;\n  const elementIdsRef = useRef({\n    labelId: labelId || `${id}-label`,\n    menuId: menuId || `${id}-menu`,\n    getItemId: getItemId || (index => `${id}-item-${index}`),\n    toggleButtonId: toggleButtonId || `${id}-toggle-button`,\n    inputId: inputId || `${id}-input`\n  });\n  return elementIdsRef.current;\n}\n\nfunction getItemIndex(index, item, items) {\n  if (index !== undefined) {\n    return index;\n  }\n\n  if (items.length === 0) {\n    return -1;\n  }\n\n  return items.indexOf(item);\n}\n\nfunction itemToString(item) {\n  return item ? String(item) : '';\n}\n\nfunction isAcceptedCharacterKey(key) {\n  return /^\\S{1}$/.test(key);\n}\n\nfunction capitalizeString(string) {\n  return `${string.slice(0, 1).toUpperCase()}${string.slice(1)}`;\n}\n\nfunction useLatestRef(val) {\n  const ref = useRef(val); // technically this is not \"concurrent mode safe\" because we're manipulating\n  // the value during render (so it's not idempotent). However, the places this\n  // hook is used is to support memoizing callbacks which will be called\n  // *during* render, so we need the latest values *during* render.\n  // If not for this, then we'd probably want to use useLayoutEffect instead.\n\n  ref.current = val;\n  return ref;\n}\n/**\n * Computes the controlled state using a the previous state, props,\n * two reducers, one from downshift and an optional one from the user.\n * Also calls the onChange handlers for state values that have changed.\n *\n * @param {Function} reducer Reducer function from downshift.\n * @param {Object} initialState Initial state of the hook.\n * @param {Object} props The hook props.\n * @returns {Array} An array with the state and an action dispatcher.\n */\n\n\nfunction useEnhancedReducer(reducer, initialState, props) {\n  const prevStateRef = useRef();\n  const actionRef = useRef();\n  const enhancedReducer = useCallback((state, action) => {\n    actionRef.current = action;\n    state = getState(state, action.props);\n    const changes = reducer(state, action);\n    const newState = action.props.stateReducer(state, { ...action,\n      changes\n    });\n    return newState;\n  }, [reducer]);\n  const [state, dispatch] = useReducer(enhancedReducer, initialState);\n  const propsRef = useLatestRef(props);\n  const dispatchWithProps = useCallback(action => dispatch({\n    props: propsRef.current,\n    ...action\n  }), [propsRef]);\n  const action = actionRef.current;\n  useEffect(() => {\n    if (action && prevStateRef.current && prevStateRef.current !== state) {\n      callOnChangeProps(action, getState(prevStateRef.current, action.props), state);\n    }\n\n    prevStateRef.current = state;\n  }, [state, props, action]);\n  return [state, dispatchWithProps];\n}\n/**\n * Wraps the useEnhancedReducer and applies the controlled prop values before\n * returning the new state.\n *\n * @param {Function} reducer Reducer function from downshift.\n * @param {Object} initialState Initial state of the hook.\n * @param {Object} props The hook props.\n * @returns {Array} An array with the state and an action dispatcher.\n */\n\n\nfunction useControlledReducer$1(reducer, initialState, props) {\n  const [state, dispatch] = useEnhancedReducer(reducer, initialState, props);\n  return [getState(state, props), dispatch];\n}\n\nconst defaultProps$3 = {\n  itemToString,\n  stateReducer,\n  getA11ySelectionMessage,\n  scrollIntoView,\n  circularNavigation: false,\n  environment:\n  /* istanbul ignore next (ssr) */\n  typeof window === 'undefined' ? {} : window\n};\n\nfunction getDefaultValue$1(props, propKey, defaultStateValues) {\n  if (defaultStateValues === void 0) {\n    defaultStateValues = dropdownDefaultStateValues;\n  }\n\n  const defaultValue = props[`default${capitalizeString(propKey)}`];\n\n  if (defaultValue !== undefined) {\n    return defaultValue;\n  }\n\n  return defaultStateValues[propKey];\n}\n\nfunction getInitialValue$1(props, propKey, defaultStateValues) {\n  if (defaultStateValues === void 0) {\n    defaultStateValues = dropdownDefaultStateValues;\n  }\n\n  const value = props[propKey];\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  const initialValue = props[`initial${capitalizeString(propKey)}`];\n\n  if (initialValue !== undefined) {\n    return initialValue;\n  }\n\n  return getDefaultValue$1(props, propKey, defaultStateValues);\n}\n\nfunction getInitialState$2(props) {\n  const selectedItem = getInitialValue$1(props, 'selectedItem');\n  const isOpen = getInitialValue$1(props, 'isOpen');\n  const highlightedIndex = getInitialValue$1(props, 'highlightedIndex');\n  const inputValue = getInitialValue$1(props, 'inputValue');\n  return {\n    highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.indexOf(selectedItem) : highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\n\nfunction getHighlightedIndexOnOpen(props, state, offset, getItemNodeFromIndex) {\n  const {\n    items,\n    initialHighlightedIndex,\n    defaultHighlightedIndex\n  } = props;\n  const {\n    selectedItem,\n    highlightedIndex\n  } = state;\n\n  if (items.length === 0) {\n    return -1;\n  } // initialHighlightedIndex will give value to highlightedIndex on initial state only.\n\n\n  if (initialHighlightedIndex !== undefined && highlightedIndex === initialHighlightedIndex) {\n    return initialHighlightedIndex;\n  }\n\n  if (defaultHighlightedIndex !== undefined) {\n    return defaultHighlightedIndex;\n  }\n\n  if (selectedItem) {\n    if (offset === 0) {\n      return items.indexOf(selectedItem);\n    }\n\n    return getNextWrappingIndex(offset, items.indexOf(selectedItem), items.length, getItemNodeFromIndex, false);\n  }\n\n  if (offset === 0) {\n    return -1;\n  }\n\n  return offset < 0 ? items.length - 1 : 0;\n}\n/**\n * Reuse the movement tracking of mouse and touch events.\n *\n * @param {boolean} isOpen Whether the dropdown is open or not.\n * @param {Array<Object>} downshiftElementRefs Downshift element refs to track movement (toggleButton, menu etc.)\n * @param {Object} environment Environment where component/hook exists.\n * @param {Function} handleBlur Handler on blur from mouse or touch.\n * @returns {Object} Ref containing whether mouseDown or touchMove event is happening\n */\n\n\nfunction useMouseAndTouchTracker(isOpen, downshiftElementRefs, environment, handleBlur) {\n  const mouseAndTouchTrackersRef = useRef({\n    isMouseDown: false,\n    isTouchMove: false\n  });\n  useEffect(() => {\n    // The same strategy for checking if a click occurred inside or outside downsift\n    // as in downshift.js.\n    const onMouseDown = () => {\n      mouseAndTouchTrackersRef.current.isMouseDown = true;\n    };\n\n    const onMouseUp = event => {\n      mouseAndTouchTrackersRef.current.isMouseDown = false;\n\n      if (isOpen && !targetWithinDownshift(event.target, downshiftElementRefs.map(ref => ref.current), environment)) {\n        handleBlur();\n      }\n    };\n\n    const onTouchStart = () => {\n      mouseAndTouchTrackersRef.current.isTouchMove = false;\n    };\n\n    const onTouchMove = () => {\n      mouseAndTouchTrackersRef.current.isTouchMove = true;\n    };\n\n    const onTouchEnd = event => {\n      if (isOpen && !mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event.target, downshiftElementRefs.map(ref => ref.current), environment, false)) {\n        handleBlur();\n      }\n    };\n\n    environment.addEventListener('mousedown', onMouseDown);\n    environment.addEventListener('mouseup', onMouseUp);\n    environment.addEventListener('touchstart', onTouchStart);\n    environment.addEventListener('touchmove', onTouchMove);\n    environment.addEventListener('touchend', onTouchEnd);\n    return function cleanup() {\n      environment.removeEventListener('mousedown', onMouseDown);\n      environment.removeEventListener('mouseup', onMouseUp);\n      environment.removeEventListener('touchstart', onTouchStart);\n      environment.removeEventListener('touchmove', onTouchMove);\n      environment.removeEventListener('touchend', onTouchEnd);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isOpen, environment]);\n  return mouseAndTouchTrackersRef;\n}\n/* istanbul ignore next */\n// eslint-disable-next-line import/no-mutable-exports\n\n\nlet useGetterPropsCalledChecker = () => noop;\n/**\n * Custom hook that checks if getter props are called correctly.\n *\n * @param  {...any} propKeys Getter prop names to be handled.\n * @returns {Function} Setter function called inside getter props to set call information.\n */\n\n/* istanbul ignore next */\n\n\nif (process.env.NODE_ENV !== 'production') {\n  useGetterPropsCalledChecker = function () {\n    const isInitialMountRef = useRef(true);\n\n    for (var _len = arguments.length, propKeys = new Array(_len), _key = 0; _key < _len; _key++) {\n      propKeys[_key] = arguments[_key];\n    }\n\n    const getterPropsCalledRef = useRef(propKeys.reduce((acc, propKey) => {\n      acc[propKey] = {};\n      return acc;\n    }, {}));\n    useEffect(() => {\n      Object.keys(getterPropsCalledRef.current).forEach(propKey => {\n        const propCallInfo = getterPropsCalledRef.current[propKey];\n\n        if (isInitialMountRef.current) {\n          if (!Object.keys(propCallInfo).length) {\n            // eslint-disable-next-line no-console\n            console.error(`downshift: You forgot to call the ${propKey} getter function on your component / element.`);\n            return;\n          }\n        }\n\n        const {\n          suppressRefError,\n          refKey,\n          elementRef\n        } = propCallInfo;\n\n        if ((!elementRef || !elementRef.current) && !suppressRefError) {\n          // eslint-disable-next-line no-console\n          console.error(`downshift: The ref prop \"${refKey}\" from ${propKey} was not applied correctly on your element.`);\n        }\n      });\n      isInitialMountRef.current = false;\n    });\n    const setGetterPropCallInfo = useCallback((propKey, suppressRefError, refKey, elementRef) => {\n      getterPropsCalledRef.current[propKey] = {\n        suppressRefError,\n        refKey,\n        elementRef\n      };\n    }, []);\n    return setGetterPropCallInfo;\n  };\n}\n\nfunction useA11yMessageSetter(getA11yMessage, dependencyArray, _ref2) {\n  let {\n    isInitialMount,\n    highlightedIndex,\n    items,\n    environment,\n    ...rest\n  } = _ref2;\n  // Sets a11y status message on changes in state.\n  useEffect(() => {\n    if (isInitialMount || false) {\n      return;\n    }\n\n    updateA11yStatus(() => getA11yMessage({\n      highlightedIndex,\n      highlightedItem: items[highlightedIndex],\n      resultCount: items.length,\n      ...rest\n    }), environment.document); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, dependencyArray);\n}\n\nfunction useScrollIntoView(_ref3) {\n  let {\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    getItemNodeFromIndex,\n    menuElement,\n    scrollIntoView: scrollIntoViewProp\n  } = _ref3;\n  // used not to scroll on highlight by mouse.\n  const shouldScrollRef = useRef(true); // Scroll on highlighted item if change comes from keyboard.\n\n  useIsomorphicLayoutEffect(() => {\n    if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {\n      return;\n    }\n\n    if (shouldScrollRef.current === false) {\n      shouldScrollRef.current = true;\n    } else {\n      scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [highlightedIndex]);\n  return shouldScrollRef;\n} // eslint-disable-next-line import/no-mutable-exports\n\n\nlet useControlPropsValidator = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  useControlPropsValidator = _ref4 => {\n    let {\n      isInitialMount,\n      props,\n      state\n    } = _ref4;\n    // used for checking when props are moving from controlled to uncontrolled.\n    const prevPropsRef = useRef(props);\n    useEffect(() => {\n      if (isInitialMount) {\n        return;\n      }\n\n      validateControlledUnchanged(state, prevPropsRef.current, props);\n      prevPropsRef.current = props;\n    }, [state, props, isInitialMount]);\n  };\n}\n\n/* eslint-disable complexity */\n\nfunction downshiftCommonReducer(state, action, stateChangeTypes) {\n  const {\n    type,\n    props\n  } = action;\n  let changes;\n\n  switch (type) {\n    case stateChangeTypes.ItemMouseMove:\n      changes = {\n        highlightedIndex: action.disabled ? -1 : action.index\n      };\n      break;\n\n    case stateChangeTypes.MenuMouseLeave:\n      changes = {\n        highlightedIndex: -1\n      };\n      break;\n\n    case stateChangeTypes.ToggleButtonClick:\n    case stateChangeTypes.FunctionToggleMenu:\n      changes = {\n        isOpen: !state.isOpen,\n        highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)\n      };\n      break;\n\n    case stateChangeTypes.FunctionOpenMenu:\n      changes = {\n        isOpen: true,\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)\n      };\n      break;\n\n    case stateChangeTypes.FunctionCloseMenu:\n      changes = {\n        isOpen: false\n      };\n      break;\n\n    case stateChangeTypes.FunctionSetHighlightedIndex:\n      changes = {\n        highlightedIndex: action.highlightedIndex\n      };\n      break;\n\n    case stateChangeTypes.FunctionSetInputValue:\n      changes = {\n        inputValue: action.inputValue\n      };\n      break;\n\n    case stateChangeTypes.FunctionReset:\n      changes = {\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        selectedItem: getDefaultValue$1(props, 'selectedItem'),\n        inputValue: getDefaultValue$1(props, 'inputValue')\n      };\n      break;\n\n    default:\n      throw new Error('Reducer called without proper action type.');\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n/* eslint-enable complexity */\n\nfunction getItemIndexByCharacterKey(_a) {\n    var keysSoFar = _a.keysSoFar, highlightedIndex = _a.highlightedIndex, items = _a.items, itemToString = _a.itemToString, getItemNodeFromIndex = _a.getItemNodeFromIndex;\n    var lowerCasedKeysSoFar = keysSoFar.toLowerCase();\n    for (var index = 0; index < items.length; index++) {\n        var offsetIndex = (index + highlightedIndex + 1) % items.length;\n        var item = items[offsetIndex];\n        if (item !== undefined &&\n            itemToString(item)\n                .toLowerCase()\n                .startsWith(lowerCasedKeysSoFar)) {\n            var element = getItemNodeFromIndex(offsetIndex);\n            if (!(element === null || element === void 0 ? void 0 : element.hasAttribute('disabled'))) {\n                return offsetIndex;\n            }\n        }\n    }\n    return highlightedIndex;\n}\nvar propTypes$2 = {\n    items: PropTypes.array.isRequired,\n    itemToString: PropTypes.func,\n    getA11yStatusMessage: PropTypes.func,\n    getA11ySelectionMessage: PropTypes.func,\n    circularNavigation: PropTypes.bool,\n    highlightedIndex: PropTypes.number,\n    defaultHighlightedIndex: PropTypes.number,\n    initialHighlightedIndex: PropTypes.number,\n    isOpen: PropTypes.bool,\n    defaultIsOpen: PropTypes.bool,\n    initialIsOpen: PropTypes.bool,\n    selectedItem: PropTypes.any,\n    initialSelectedItem: PropTypes.any,\n    defaultSelectedItem: PropTypes.any,\n    id: PropTypes.string,\n    labelId: PropTypes.string,\n    menuId: PropTypes.string,\n    getItemId: PropTypes.func,\n    toggleButtonId: PropTypes.string,\n    stateReducer: PropTypes.func,\n    onSelectedItemChange: PropTypes.func,\n    onHighlightedIndexChange: PropTypes.func,\n    onStateChange: PropTypes.func,\n    onIsOpenChange: PropTypes.func,\n    environment: PropTypes.shape({\n        addEventListener: PropTypes.func,\n        removeEventListener: PropTypes.func,\n        document: PropTypes.shape({\n            getElementById: PropTypes.func,\n            activeElement: PropTypes.any,\n            body: PropTypes.any\n        })\n    })\n};\n/**\n * Default implementation for status message. Only added when menu is open.\n * Will specift if there are results in the list, and if so, how many,\n * and what keys are relevant.\n *\n * @param {Object} param the downshift state and other relevant properties\n * @return {String} the a11y status message\n */\nfunction getA11yStatusMessage(_a) {\n    var isOpen = _a.isOpen, resultCount = _a.resultCount, previousResultCount = _a.previousResultCount;\n    if (!isOpen) {\n        return '';\n    }\n    if (!resultCount) {\n        return 'No results are available.';\n    }\n    if (resultCount !== previousResultCount) {\n        return \"\".concat(resultCount, \" result\").concat(resultCount === 1 ? ' is' : 's are', \" available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.\");\n    }\n    return '';\n}\nvar defaultProps$2 = __assign(__assign({}, defaultProps$3), { getA11yStatusMessage: getA11yStatusMessage });\n// eslint-disable-next-line import/no-mutable-exports\nvar validatePropTypes$2 = noop;\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    validatePropTypes$2 = function (options, caller) {\n        PropTypes.checkPropTypes(propTypes$2, options, 'prop', caller.name);\n    };\n}\n\nconst MenuKeyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_arrow_down__' : 0;\nconst MenuKeyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_arrow_up__' : 1;\nconst MenuKeyDownEscape = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_escape__' : 2;\nconst MenuKeyDownHome = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_home__' : 3;\nconst MenuKeyDownEnd = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_end__' : 4;\nconst MenuKeyDownEnter = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_enter__' : 5;\nconst MenuKeyDownSpaceButton = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_space_button__' : 6;\nconst MenuKeyDownCharacter = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_character__' : 7;\nconst MenuBlur = process.env.NODE_ENV !== \"production\" ? '__menu_blur__' : 8;\nconst MenuMouseLeave$1 = process.env.NODE_ENV !== \"production\" ? '__menu_mouse_leave__' : 9;\nconst ItemMouseMove$1 = process.env.NODE_ENV !== \"production\" ? '__item_mouse_move__' : 10;\nconst ItemClick$1 = process.env.NODE_ENV !== \"production\" ? '__item_click__' : 11;\nconst ToggleButtonClick$1 = process.env.NODE_ENV !== \"production\" ? '__togglebutton_click__' : 12;\nconst ToggleButtonKeyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__togglebutton_keydown_arrow_down__' : 13;\nconst ToggleButtonKeyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__togglebutton_keydown_arrow_up__' : 14;\nconst ToggleButtonKeyDownCharacter = process.env.NODE_ENV !== \"production\" ? '__togglebutton_keydown_character__' : 15;\nconst FunctionToggleMenu$1 = process.env.NODE_ENV !== \"production\" ? '__function_toggle_menu__' : 16;\nconst FunctionOpenMenu$1 = process.env.NODE_ENV !== \"production\" ? '__function_open_menu__' : 17;\nconst FunctionCloseMenu$1 = process.env.NODE_ENV !== \"production\" ? '__function_close_menu__' : 18;\nconst FunctionSetHighlightedIndex$1 = process.env.NODE_ENV !== \"production\" ? '__function_set_highlighted_index__' : 19;\nconst FunctionSelectItem$1 = process.env.NODE_ENV !== \"production\" ? '__function_select_item__' : 20;\nconst FunctionSetInputValue$1 = process.env.NODE_ENV !== \"production\" ? '__function_set_input_value__' : 21;\nconst FunctionReset$2 = process.env.NODE_ENV !== \"production\" ? '__function_reset__' : 22;\n\nvar stateChangeTypes$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  MenuKeyDownArrowDown: MenuKeyDownArrowDown,\n  MenuKeyDownArrowUp: MenuKeyDownArrowUp,\n  MenuKeyDownEscape: MenuKeyDownEscape,\n  MenuKeyDownHome: MenuKeyDownHome,\n  MenuKeyDownEnd: MenuKeyDownEnd,\n  MenuKeyDownEnter: MenuKeyDownEnter,\n  MenuKeyDownSpaceButton: MenuKeyDownSpaceButton,\n  MenuKeyDownCharacter: MenuKeyDownCharacter,\n  MenuBlur: MenuBlur,\n  MenuMouseLeave: MenuMouseLeave$1,\n  ItemMouseMove: ItemMouseMove$1,\n  ItemClick: ItemClick$1,\n  ToggleButtonClick: ToggleButtonClick$1,\n  ToggleButtonKeyDownArrowDown: ToggleButtonKeyDownArrowDown,\n  ToggleButtonKeyDownArrowUp: ToggleButtonKeyDownArrowUp,\n  ToggleButtonKeyDownCharacter: ToggleButtonKeyDownCharacter,\n  FunctionToggleMenu: FunctionToggleMenu$1,\n  FunctionOpenMenu: FunctionOpenMenu$1,\n  FunctionCloseMenu: FunctionCloseMenu$1,\n  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex$1,\n  FunctionSelectItem: FunctionSelectItem$1,\n  FunctionSetInputValue: FunctionSetInputValue$1,\n  FunctionReset: FunctionReset$2\n});\n\n/* eslint-disable complexity */\n\nfunction downshiftSelectReducer(state, action) {\n  const {\n    type,\n    props,\n    shiftKey\n  } = action;\n  let changes;\n\n  switch (type) {\n    case ItemClick$1:\n      changes = {\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        selectedItem: props.items[action.index]\n      };\n      break;\n\n    case ToggleButtonKeyDownCharacter:\n      {\n        const lowercasedKey = action.key;\n        const inputValue = `${state.inputValue}${lowercasedKey}`;\n        const itemIndex = getItemIndexByCharacterKey({\n          keysSoFar: inputValue,\n          highlightedIndex: state.selectedItem ? props.items.indexOf(state.selectedItem) : -1,\n          items: props.items,\n          itemToString: props.itemToString,\n          getItemNodeFromIndex: action.getItemNodeFromIndex\n        });\n        changes = {\n          inputValue,\n          ...(itemIndex >= 0 && {\n            selectedItem: props.items[itemIndex]\n          })\n        };\n      }\n      break;\n\n    case ToggleButtonKeyDownArrowDown:\n      changes = {\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),\n        isOpen: true\n      };\n      break;\n\n    case ToggleButtonKeyDownArrowUp:\n      changes = {\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),\n        isOpen: true\n      };\n      break;\n\n    case MenuKeyDownEnter:\n    case MenuKeyDownSpaceButton:\n      changes = {\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        ...(state.highlightedIndex >= 0 && {\n          selectedItem: props.items[state.highlightedIndex]\n        })\n      };\n      break;\n\n    case MenuKeyDownHome:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case MenuKeyDownEnd:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case MenuKeyDownEscape:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1\n      };\n      break;\n\n    case MenuBlur:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1\n      };\n      break;\n\n    case MenuKeyDownCharacter:\n      {\n        const lowercasedKey = action.key;\n        const inputValue = `${state.inputValue}${lowercasedKey}`;\n        const highlightedIndex = getItemIndexByCharacterKey({\n          keysSoFar: inputValue,\n          highlightedIndex: state.highlightedIndex,\n          items: props.items,\n          itemToString: props.itemToString,\n          getItemNodeFromIndex: action.getItemNodeFromIndex\n        });\n        changes = {\n          inputValue,\n          ...(highlightedIndex >= 0 && {\n            highlightedIndex\n          })\n        };\n      }\n      break;\n\n    case MenuKeyDownArrowDown:\n      changes = {\n        highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n      };\n      break;\n\n    case MenuKeyDownArrowUp:\n      changes = {\n        highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n      };\n      break;\n\n    case FunctionSelectItem$1:\n      changes = {\n        selectedItem: action.selectedItem\n      };\n      break;\n\n    default:\n      return downshiftCommonReducer(state, action, stateChangeTypes$2);\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n/* eslint-enable complexity */\n\n/* eslint-disable max-statements */\nuseSelect.stateChangeTypes = stateChangeTypes$2;\n\nfunction useSelect(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n\n  validatePropTypes$2(userProps, useSelect); // Props defaults and destructuring.\n\n  const props = { ...defaultProps$2,\n    ...userProps\n  };\n  const {\n    items,\n    scrollIntoView,\n    environment,\n    initialIsOpen,\n    defaultIsOpen,\n    itemToString,\n    getA11ySelectionMessage,\n    getA11yStatusMessage\n  } = props; // Initial state depending on controlled props.\n\n  const initialState = getInitialState$2(props);\n  const [state, dispatch] = useControlledReducer$1(downshiftSelectReducer, initialState, props);\n  const {\n    isOpen,\n    highlightedIndex,\n    selectedItem,\n    inputValue\n  } = state; // Element efs.\n\n  const toggleButtonRef = useRef(null);\n  const menuRef = useRef(null);\n  const itemRefs = useRef({}); // used not to trigger menu blur action in some scenarios.\n\n  const shouldBlurRef = useRef(true); // used to keep the inputValue clearTimeout object between renders.\n\n  const clearTimeoutRef = useRef(null); // prevent id re-generation between renders.\n\n  const elementIds = useElementIds(props); // used to keep track of how many items we had on previous cycle.\n\n  const previousResultCountRef = useRef();\n  const isInitialMountRef = useRef(true); // utility callback to get item element.\n\n  const latest = useLatestRef({\n    state,\n    props\n  }); // Some utils.\n\n  const getItemNodeFromIndex = useCallback(index => itemRefs.current[elementIds.getItemId(index)], [elementIds]); // Effects.\n  // Sets a11y status message on changes in state.\n\n  useA11yMessageSetter(getA11yStatusMessage, [isOpen, highlightedIndex, inputValue, items], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Sets a11y status message on changes in selectedItem.\n\n  useA11yMessageSetter(getA11ySelectionMessage, [selectedItem], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Scroll on highlighted item if change comes from keyboard.\n\n  const shouldScrollRef = useScrollIntoView({\n    menuElement: menuRef.current,\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    scrollIntoView,\n    getItemNodeFromIndex\n  }); // Sets cleanup for the keysSoFar callback, debounded after 500ms.\n\n  useEffect(() => {\n    // init the clean function here as we need access to dispatch.\n    clearTimeoutRef.current = debounce(outerDispatch => {\n      outerDispatch({\n        type: FunctionSetInputValue$1,\n        inputValue: ''\n      });\n    }, 500); // Cancel any pending debounced calls on mount\n\n    return () => {\n      clearTimeoutRef.current.cancel();\n    };\n  }, []); // Invokes the keysSoFar callback set up above.\n\n  useEffect(() => {\n    if (!inputValue) {\n      return;\n    }\n\n    clearTimeoutRef.current(dispatch);\n  }, [dispatch, inputValue]);\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  });\n  /* Controls the focus on the menu or the toggle button. */\n\n  useEffect(() => {\n    // Don't focus menu on first render.\n    if (isInitialMountRef.current) {\n      // Unless it was initialised as open.\n      if ((initialIsOpen || defaultIsOpen || isOpen) && menuRef.current) {\n        menuRef.current.focus();\n      }\n\n      return;\n    } // Focus menu on open.\n\n\n    if (isOpen) {\n      // istanbul ignore else\n      if (menuRef.current) {\n        menuRef.current.focus();\n      }\n\n      return;\n    } // Focus toggleButton on close, but not if it was closed with (Shift+)Tab.\n\n\n    if (environment.document.activeElement === menuRef.current) {\n      // istanbul ignore else\n      if (toggleButtonRef.current) {\n        shouldBlurRef.current = false;\n        toggleButtonRef.current.focus();\n      }\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [isOpen]);\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    previousResultCountRef.current = items.length;\n  }); // Add mouse/touch events to document.\n\n  const mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [menuRef, toggleButtonRef], environment, () => {\n    dispatch({\n      type: MenuBlur\n    });\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker('getMenuProps', 'getToggleButtonProps'); // Make initial ref false.\n\n  useEffect(() => {\n    isInitialMountRef.current = false;\n  }, []); // Reset itemRefs on close.\n\n  useEffect(() => {\n    if (!isOpen) {\n      itemRefs.current = {};\n    }\n  }, [isOpen]); // Event handler functions.\n\n  const toggleButtonKeyDownHandlers = useMemo(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch({\n        type: ToggleButtonKeyDownArrowDown,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch({\n        type: ToggleButtonKeyDownArrowUp,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    }\n\n  }), [dispatch, getItemNodeFromIndex]);\n  const menuKeyDownHandlers = useMemo(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownArrowDown,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownArrowUp,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n\n    Home(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownHome,\n        getItemNodeFromIndex\n      });\n    },\n\n    End(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownEnd,\n        getItemNodeFromIndex\n      });\n    },\n\n    Escape() {\n      dispatch({\n        type: MenuKeyDownEscape\n      });\n    },\n\n    Enter(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownEnter\n      });\n    },\n\n    ' '(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownSpaceButton\n      });\n    }\n\n  }), [dispatch, getItemNodeFromIndex]); // Action functions.\n\n  const toggleMenu = useCallback(() => {\n    dispatch({\n      type: FunctionToggleMenu$1\n    });\n  }, [dispatch]);\n  const closeMenu = useCallback(() => {\n    dispatch({\n      type: FunctionCloseMenu$1\n    });\n  }, [dispatch]);\n  const openMenu = useCallback(() => {\n    dispatch({\n      type: FunctionOpenMenu$1\n    });\n  }, [dispatch]);\n  const setHighlightedIndex = useCallback(newHighlightedIndex => {\n    dispatch({\n      type: FunctionSetHighlightedIndex$1,\n      highlightedIndex: newHighlightedIndex\n    });\n  }, [dispatch]);\n  const selectItem = useCallback(newSelectedItem => {\n    dispatch({\n      type: FunctionSelectItem$1,\n      selectedItem: newSelectedItem\n    });\n  }, [dispatch]);\n  const reset = useCallback(() => {\n    dispatch({\n      type: FunctionReset$2\n    });\n  }, [dispatch]);\n  const setInputValue = useCallback(newInputValue => {\n    dispatch({\n      type: FunctionSetInputValue$1,\n      inputValue: newInputValue\n    });\n  }, [dispatch]); // Getter functions.\n\n  const getLabelProps = useCallback(labelProps => ({\n    id: elementIds.labelId,\n    htmlFor: elementIds.toggleButtonId,\n    ...labelProps\n  }), [elementIds]);\n  const getMenuProps = useCallback(function (_temp, _temp2) {\n    let {\n      onMouseLeave,\n      refKey = 'ref',\n      onKeyDown,\n      onBlur,\n      ref,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    let {\n      suppressRefError = false\n    } = _temp2 === void 0 ? {} : _temp2;\n    const latestState = latest.current.state;\n\n    const menuHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && menuKeyDownHandlers[key]) {\n        menuKeyDownHandlers[key](event);\n      } else if (isAcceptedCharacterKey(key)) {\n        dispatch({\n          type: MenuKeyDownCharacter,\n          key,\n          getItemNodeFromIndex\n        });\n      }\n    };\n\n    const menuHandleBlur = () => {\n      // if the blur was a result of selection, we don't trigger this action.\n      if (shouldBlurRef.current === false) {\n        shouldBlurRef.current = true;\n        return;\n      }\n\n      const shouldBlur = !mouseAndTouchTrackersRef.current.isMouseDown;\n      /* istanbul ignore else */\n\n      if (shouldBlur) {\n        dispatch({\n          type: MenuBlur\n        });\n      }\n    };\n\n    const menuHandleMouseLeave = () => {\n      dispatch({\n        type: MenuMouseLeave$1\n      });\n    };\n\n    setGetterPropCallInfo('getMenuProps', suppressRefError, refKey, menuRef);\n    return {\n      [refKey]: handleRefs(ref, menuNode => {\n        menuRef.current = menuNode;\n      }),\n      id: elementIds.menuId,\n      role: 'listbox',\n      'aria-labelledby': elementIds.labelId,\n      tabIndex: -1,\n      ...(latestState.isOpen && latestState.highlightedIndex > -1 && {\n        'aria-activedescendant': elementIds.getItemId(latestState.highlightedIndex)\n      }),\n      onMouseLeave: callAllEventHandlers(onMouseLeave, menuHandleMouseLeave),\n      onKeyDown: callAllEventHandlers(onKeyDown, menuHandleKeyDown),\n      onBlur: callAllEventHandlers(onBlur, menuHandleBlur),\n      ...rest\n    };\n  }, [dispatch, latest, menuKeyDownHandlers, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds, getItemNodeFromIndex]);\n  const getToggleButtonProps = useCallback(function (_temp3, _temp4) {\n    let {\n      onClick,\n      onKeyDown,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp3 === void 0 ? {} : _temp3;\n    let {\n      suppressRefError = false\n    } = _temp4 === void 0 ? {} : _temp4;\n\n    const toggleButtonHandleClick = () => {\n      dispatch({\n        type: ToggleButtonClick$1\n      });\n    };\n\n    const toggleButtonHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && toggleButtonKeyDownHandlers[key]) {\n        toggleButtonKeyDownHandlers[key](event);\n      } else if (isAcceptedCharacterKey(key)) {\n        dispatch({\n          type: ToggleButtonKeyDownCharacter,\n          key,\n          getItemNodeFromIndex\n        });\n      }\n    };\n\n    const toggleProps = {\n      [refKey]: handleRefs(ref, toggleButtonNode => {\n        toggleButtonRef.current = toggleButtonNode;\n      }),\n      id: elementIds.toggleButtonId,\n      'aria-haspopup': 'listbox',\n      'aria-expanded': latest.current.state.isOpen,\n      'aria-labelledby': `${elementIds.labelId} ${elementIds.toggleButtonId}`,\n      ...rest\n    };\n\n    if (!rest.disabled) {\n      toggleProps.onClick = callAllEventHandlers(onClick, toggleButtonHandleClick);\n      toggleProps.onKeyDown = callAllEventHandlers(onKeyDown, toggleButtonHandleKeyDown);\n    }\n\n    setGetterPropCallInfo('getToggleButtonProps', suppressRefError, refKey, toggleButtonRef);\n    return toggleProps;\n  }, [dispatch, latest, toggleButtonKeyDownHandlers, setGetterPropCallInfo, elementIds, getItemNodeFromIndex]);\n  const getItemProps = useCallback(function (_temp5) {\n    let {\n      item,\n      index,\n      onMouseMove,\n      onClick,\n      refKey = 'ref',\n      ref,\n      disabled,\n      ...rest\n    } = _temp5 === void 0 ? {} : _temp5;\n    const {\n      state: latestState,\n      props: latestProps\n    } = latest.current;\n\n    const itemHandleMouseMove = () => {\n      if (index === latestState.highlightedIndex) {\n        return;\n      }\n\n      shouldScrollRef.current = false;\n      dispatch({\n        type: ItemMouseMove$1,\n        index,\n        disabled\n      });\n    };\n\n    const itemHandleClick = () => {\n      dispatch({\n        type: ItemClick$1,\n        index\n      });\n    };\n\n    const itemIndex = getItemIndex(index, item, latestProps.items);\n\n    if (itemIndex < 0) {\n      throw new Error('Pass either item or item index in getItemProps!');\n    }\n\n    const itemProps = {\n      disabled,\n      role: 'option',\n      'aria-selected': `${itemIndex === latestState.highlightedIndex}`,\n      id: elementIds.getItemId(itemIndex),\n      [refKey]: handleRefs(ref, itemNode => {\n        if (itemNode) {\n          itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;\n        }\n      }),\n      ...rest\n    };\n\n    if (!disabled) {\n      itemProps.onClick = callAllEventHandlers(onClick, itemHandleClick);\n    }\n\n    itemProps.onMouseMove = callAllEventHandlers(onMouseMove, itemHandleMouseMove);\n    return itemProps;\n  }, [dispatch, latest, shouldScrollRef, elementIds]);\n  return {\n    // prop getters.\n    getToggleButtonProps,\n    getLabelProps,\n    getMenuProps,\n    getItemProps,\n    // actions.\n    toggleMenu,\n    openMenu,\n    closeMenu,\n    setHighlightedIndex,\n    selectItem,\n    reset,\n    setInputValue,\n    // state.\n    highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\n\nconst InputKeyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__input_keydown_arrow_down__' : 0;\nconst InputKeyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__input_keydown_arrow_up__' : 1;\nconst InputKeyDownEscape = process.env.NODE_ENV !== \"production\" ? '__input_keydown_escape__' : 2;\nconst InputKeyDownHome = process.env.NODE_ENV !== \"production\" ? '__input_keydown_home__' : 3;\nconst InputKeyDownEnd = process.env.NODE_ENV !== \"production\" ? '__input_keydown_end__' : 4;\nconst InputKeyDownEnter = process.env.NODE_ENV !== \"production\" ? '__input_keydown_enter__' : 5;\nconst InputChange = process.env.NODE_ENV !== \"production\" ? '__input_change__' : 6;\nconst InputBlur = process.env.NODE_ENV !== \"production\" ? '__input_blur__' : 7;\nconst MenuMouseLeave = process.env.NODE_ENV !== \"production\" ? '__menu_mouse_leave__' : 8;\nconst ItemMouseMove = process.env.NODE_ENV !== \"production\" ? '__item_mouse_move__' : 9;\nconst ItemClick = process.env.NODE_ENV !== \"production\" ? '__item_click__' : 10;\nconst ToggleButtonClick = process.env.NODE_ENV !== \"production\" ? '__togglebutton_click__' : 11;\nconst FunctionToggleMenu = process.env.NODE_ENV !== \"production\" ? '__function_toggle_menu__' : 12;\nconst FunctionOpenMenu = process.env.NODE_ENV !== \"production\" ? '__function_open_menu__' : 13;\nconst FunctionCloseMenu = process.env.NODE_ENV !== \"production\" ? '__function_close_menu__' : 14;\nconst FunctionSetHighlightedIndex = process.env.NODE_ENV !== \"production\" ? '__function_set_highlighted_index__' : 15;\nconst FunctionSelectItem = process.env.NODE_ENV !== \"production\" ? '__function_select_item__' : 16;\nconst FunctionSetInputValue = process.env.NODE_ENV !== \"production\" ? '__function_set_input_value__' : 17;\nconst FunctionReset$1 = process.env.NODE_ENV !== \"production\" ? '__function_reset__' : 18;\nconst ControlledPropUpdatedSelectedItem = process.env.NODE_ENV !== \"production\" ? '__controlled_prop_updated_selected_item__' : 19;\n\nvar stateChangeTypes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  InputKeyDownArrowDown: InputKeyDownArrowDown,\n  InputKeyDownArrowUp: InputKeyDownArrowUp,\n  InputKeyDownEscape: InputKeyDownEscape,\n  InputKeyDownHome: InputKeyDownHome,\n  InputKeyDownEnd: InputKeyDownEnd,\n  InputKeyDownEnter: InputKeyDownEnter,\n  InputChange: InputChange,\n  InputBlur: InputBlur,\n  MenuMouseLeave: MenuMouseLeave,\n  ItemMouseMove: ItemMouseMove,\n  ItemClick: ItemClick,\n  ToggleButtonClick: ToggleButtonClick,\n  FunctionToggleMenu: FunctionToggleMenu,\n  FunctionOpenMenu: FunctionOpenMenu,\n  FunctionCloseMenu: FunctionCloseMenu,\n  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex,\n  FunctionSelectItem: FunctionSelectItem,\n  FunctionSetInputValue: FunctionSetInputValue,\n  FunctionReset: FunctionReset$1,\n  ControlledPropUpdatedSelectedItem: ControlledPropUpdatedSelectedItem\n});\n\nfunction getInitialState$1(props) {\n  const initialState = getInitialState$2(props);\n  const {\n    selectedItem\n  } = initialState;\n  let {\n    inputValue\n  } = initialState;\n\n  if (inputValue === '' && selectedItem && props.defaultInputValue === undefined && props.initialInputValue === undefined && props.inputValue === undefined) {\n    inputValue = props.itemToString(selectedItem);\n  }\n\n  return { ...initialState,\n    inputValue\n  };\n}\n\nconst propTypes$1 = {\n  items: PropTypes.array.isRequired,\n  itemToString: PropTypes.func,\n  getA11yStatusMessage: PropTypes.func,\n  getA11ySelectionMessage: PropTypes.func,\n  circularNavigation: PropTypes.bool,\n  highlightedIndex: PropTypes.number,\n  defaultHighlightedIndex: PropTypes.number,\n  initialHighlightedIndex: PropTypes.number,\n  isOpen: PropTypes.bool,\n  defaultIsOpen: PropTypes.bool,\n  initialIsOpen: PropTypes.bool,\n  selectedItem: PropTypes.any,\n  initialSelectedItem: PropTypes.any,\n  defaultSelectedItem: PropTypes.any,\n  inputValue: PropTypes.string,\n  defaultInputValue: PropTypes.string,\n  initialInputValue: PropTypes.string,\n  id: PropTypes.string,\n  labelId: PropTypes.string,\n  menuId: PropTypes.string,\n  getItemId: PropTypes.func,\n  inputId: PropTypes.string,\n  toggleButtonId: PropTypes.string,\n  stateReducer: PropTypes.func,\n  onSelectedItemChange: PropTypes.func,\n  onHighlightedIndexChange: PropTypes.func,\n  onStateChange: PropTypes.func,\n  onIsOpenChange: PropTypes.func,\n  onInputValueChange: PropTypes.func,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  })\n};\n/**\n * The useCombobox version of useControlledReducer, which also\n * checks if the controlled prop selectedItem changed between\n * renders. If so, it will also update inputValue with its\n * string equivalent. It uses the common useEnhancedReducer to\n * compute the rest of the state.\n *\n * @param {Function} reducer Reducer function from downshift.\n * @param {Object} initialState Initial state of the hook.\n * @param {Object} props The hook props.\n * @returns {Array} An array with the state and an action dispatcher.\n */\n\nfunction useControlledReducer(reducer, initialState, props) {\n  const previousSelectedItemRef = useRef();\n  const [state, dispatch] = useEnhancedReducer(reducer, initialState, props); // ToDo: if needed, make same approach as selectedItemChanged from Downshift.\n\n  useEffect(() => {\n    if (isControlledProp(props, 'selectedItem')) {\n      if (previousSelectedItemRef.current !== props.selectedItem) {\n        dispatch({\n          type: ControlledPropUpdatedSelectedItem,\n          inputValue: props.itemToString(props.selectedItem)\n        });\n      }\n\n      previousSelectedItemRef.current = state.selectedItem === previousSelectedItemRef.current ? props.selectedItem : state.selectedItem;\n    }\n  });\n  return [getState(state, props), dispatch];\n} // eslint-disable-next-line import/no-mutable-exports\n\n\nlet validatePropTypes$1 = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validatePropTypes$1 = (options, caller) => {\n    PropTypes.checkPropTypes(propTypes$1, options, 'prop', caller.name);\n  };\n}\n\nconst defaultProps$1 = { ...defaultProps$3,\n  getA11yStatusMessage: getA11yStatusMessage$1,\n  circularNavigation: true\n};\n\n/* eslint-disable complexity */\n\nfunction downshiftUseComboboxReducer(state, action) {\n  const {\n    type,\n    props,\n    shiftKey\n  } = action;\n  let changes;\n\n  switch (type) {\n    case ItemClick:\n      changes = {\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        selectedItem: props.items[action.index],\n        inputValue: props.itemToString(props.items[action.index])\n      };\n      break;\n\n    case InputKeyDownArrowDown:\n      if (state.isOpen) {\n        changes = {\n          highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n        };\n      } else {\n        changes = {\n          highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),\n          isOpen: props.items.length >= 0\n        };\n      }\n\n      break;\n\n    case InputKeyDownArrowUp:\n      if (state.isOpen) {\n        changes = {\n          highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n        };\n      } else {\n        changes = {\n          highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),\n          isOpen: props.items.length >= 0\n        };\n      }\n\n      break;\n\n    case InputKeyDownEnter:\n      changes = { ...(state.isOpen && state.highlightedIndex >= 0 && {\n          selectedItem: props.items[state.highlightedIndex],\n          isOpen: getDefaultValue$1(props, 'isOpen'),\n          highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n          inputValue: props.itemToString(props.items[state.highlightedIndex])\n        })\n      };\n      break;\n\n    case InputKeyDownEscape:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1,\n        ...(!state.isOpen && {\n          selectedItem: null,\n          inputValue: ''\n        })\n      };\n      break;\n\n    case InputKeyDownHome:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case InputKeyDownEnd:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case InputBlur:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1,\n        ...(state.highlightedIndex >= 0 && action.selectItem && {\n          selectedItem: props.items[state.highlightedIndex],\n          inputValue: props.itemToString(props.items[state.highlightedIndex])\n        })\n      };\n      break;\n\n    case InputChange:\n      changes = {\n        isOpen: true,\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        inputValue: action.inputValue\n      };\n      break;\n\n    case FunctionSelectItem:\n      changes = {\n        selectedItem: action.selectedItem,\n        inputValue: props.itemToString(action.selectedItem)\n      };\n      break;\n\n    case ControlledPropUpdatedSelectedItem:\n      changes = {\n        inputValue: action.inputValue\n      };\n      break;\n\n    default:\n      return downshiftCommonReducer(state, action, stateChangeTypes$1);\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n/* eslint-enable complexity */\n\n/* eslint-disable max-statements */\nuseCombobox.stateChangeTypes = stateChangeTypes$1;\n\nfunction useCombobox(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n\n  validatePropTypes$1(userProps, useCombobox); // Props defaults and destructuring.\n\n  const props = { ...defaultProps$1,\n    ...userProps\n  };\n  const {\n    initialIsOpen,\n    defaultIsOpen,\n    items,\n    scrollIntoView,\n    environment,\n    getA11yStatusMessage,\n    getA11ySelectionMessage,\n    itemToString\n  } = props; // Initial state depending on controlled props.\n\n  const initialState = getInitialState$1(props);\n  const [state, dispatch] = useControlledReducer(downshiftUseComboboxReducer, initialState, props);\n  const {\n    isOpen,\n    highlightedIndex,\n    selectedItem,\n    inputValue\n  } = state; // Element refs.\n\n  const menuRef = useRef(null);\n  const itemRefs = useRef({});\n  const inputRef = useRef(null);\n  const toggleButtonRef = useRef(null);\n  const comboboxRef = useRef(null);\n  const isInitialMountRef = useRef(true); // prevent id re-generation between renders.\n\n  const elementIds = useElementIds(props); // used to keep track of how many items we had on previous cycle.\n\n  const previousResultCountRef = useRef(); // utility callback to get item element.\n\n  const latest = useLatestRef({\n    state,\n    props\n  });\n  const getItemNodeFromIndex = useCallback(index => itemRefs.current[elementIds.getItemId(index)], [elementIds]); // Effects.\n  // Sets a11y status message on changes in state.\n\n  useA11yMessageSetter(getA11yStatusMessage, [isOpen, highlightedIndex, inputValue, items], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Sets a11y status message on changes in selectedItem.\n\n  useA11yMessageSetter(getA11ySelectionMessage, [selectedItem], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Scroll on highlighted item if change comes from keyboard.\n\n  const shouldScrollRef = useScrollIntoView({\n    menuElement: menuRef.current,\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    scrollIntoView,\n    getItemNodeFromIndex\n  });\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  }); // Focus the input on first render if required.\n\n  useEffect(() => {\n    const focusOnOpen = initialIsOpen || defaultIsOpen || isOpen;\n\n    if (focusOnOpen && inputRef.current) {\n      inputRef.current.focus();\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    previousResultCountRef.current = items.length;\n  }); // Add mouse/touch events to document.\n\n  const mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [comboboxRef, menuRef, toggleButtonRef], environment, () => {\n    dispatch({\n      type: InputBlur,\n      selectItem: false\n    });\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker('getInputProps', 'getComboboxProps', 'getMenuProps'); // Make initial ref false.\n\n  useEffect(() => {\n    isInitialMountRef.current = false;\n  }, []); // Reset itemRefs on close.\n\n  useEffect(() => {\n    if (!isOpen) {\n      itemRefs.current = {};\n    }\n  }, [isOpen]);\n  /* Event handler functions */\n\n  const inputKeyDownHandlers = useMemo(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownArrowDown,\n        shiftKey: event.shiftKey,\n        getItemNodeFromIndex\n      });\n    },\n\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownArrowUp,\n        shiftKey: event.shiftKey,\n        getItemNodeFromIndex\n      });\n    },\n\n    Home(event) {\n      if (!latest.current.state.isOpen) {\n        return;\n      }\n\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownHome,\n        getItemNodeFromIndex\n      });\n    },\n\n    End(event) {\n      if (!latest.current.state.isOpen) {\n        return;\n      }\n\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownEnd,\n        getItemNodeFromIndex\n      });\n    },\n\n    Escape(event) {\n      const latestState = latest.current.state;\n\n      if (latestState.isOpen || latestState.inputValue || latestState.selectedItem || latestState.highlightedIndex > -1) {\n        event.preventDefault();\n        dispatch({\n          type: InputKeyDownEscape\n        });\n      }\n    },\n\n    Enter(event) {\n      const latestState = latest.current.state; // if closed or no highlighted index, do nothing.\n\n      if (!latestState.isOpen || latestState.highlightedIndex < 0 || event.which === 229 // if IME composing, wait for next Enter keydown event.\n      ) {\n        return;\n      }\n\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownEnter,\n        getItemNodeFromIndex\n      });\n    }\n\n  }), [dispatch, latest, getItemNodeFromIndex]); // Getter props.\n\n  const getLabelProps = useCallback(labelProps => ({\n    id: elementIds.labelId,\n    htmlFor: elementIds.inputId,\n    ...labelProps\n  }), [elementIds]);\n  const getMenuProps = useCallback(function (_temp, _temp2) {\n    let {\n      onMouseLeave,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    let {\n      suppressRefError = false\n    } = _temp2 === void 0 ? {} : _temp2;\n    setGetterPropCallInfo('getMenuProps', suppressRefError, refKey, menuRef);\n    return {\n      [refKey]: handleRefs(ref, menuNode => {\n        menuRef.current = menuNode;\n      }),\n      id: elementIds.menuId,\n      role: 'listbox',\n      'aria-labelledby': elementIds.labelId,\n      onMouseLeave: callAllEventHandlers(onMouseLeave, () => {\n        dispatch({\n          type: MenuMouseLeave\n        });\n      }),\n      ...rest\n    };\n  }, [dispatch, setGetterPropCallInfo, elementIds]);\n  const getItemProps = useCallback(function (_temp3) {\n    let {\n      item,\n      index,\n      refKey = 'ref',\n      ref,\n      onMouseMove,\n      onMouseDown,\n      onClick,\n      onPress,\n      disabled,\n      ...rest\n    } = _temp3 === void 0 ? {} : _temp3;\n    const {\n      props: latestProps,\n      state: latestState\n    } = latest.current;\n    const itemIndex = getItemIndex(index, item, latestProps.items);\n\n    if (itemIndex < 0) {\n      throw new Error('Pass either item or item index in getItemProps!');\n    }\n\n    const onSelectKey = 'onClick';\n    const customClickHandler = onClick;\n\n    const itemHandleMouseMove = () => {\n      if (index === latestState.highlightedIndex) {\n        return;\n      }\n\n      shouldScrollRef.current = false;\n      dispatch({\n        type: ItemMouseMove,\n        index,\n        disabled\n      });\n    };\n\n    const itemHandleClick = () => {\n      dispatch({\n        type: ItemClick,\n        index\n      });\n    };\n\n    const itemHandleMouseDown = e => e.preventDefault();\n\n    return {\n      [refKey]: handleRefs(ref, itemNode => {\n        if (itemNode) {\n          itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;\n        }\n      }),\n      disabled,\n      role: 'option',\n      'aria-selected': `${itemIndex === latestState.highlightedIndex}`,\n      id: elementIds.getItemId(itemIndex),\n      ...(!disabled && {\n        [onSelectKey]: callAllEventHandlers(customClickHandler, itemHandleClick)\n      }),\n      onMouseMove: callAllEventHandlers(onMouseMove, itemHandleMouseMove),\n      onMouseDown: callAllEventHandlers(onMouseDown, itemHandleMouseDown),\n      ...rest\n    };\n  }, [dispatch, latest, shouldScrollRef, elementIds]);\n  const getToggleButtonProps = useCallback(function (_temp4) {\n    let {\n      onClick,\n      onPress,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp4 === void 0 ? {} : _temp4;\n\n    const toggleButtonHandleClick = () => {\n      dispatch({\n        type: ToggleButtonClick\n      });\n\n      if (!latest.current.state.isOpen && inputRef.current) {\n        inputRef.current.focus();\n      }\n    };\n\n    return {\n      [refKey]: handleRefs(ref, toggleButtonNode => {\n        toggleButtonRef.current = toggleButtonNode;\n      }),\n      id: elementIds.toggleButtonId,\n      tabIndex: -1,\n      ...(!rest.disabled && { ...({\n          onClick: callAllEventHandlers(onClick, toggleButtonHandleClick)\n        })\n      }),\n      ...rest\n    };\n  }, [dispatch, latest, elementIds]);\n  const getInputProps = useCallback(function (_temp5, _temp6) {\n    let {\n      onKeyDown,\n      onChange,\n      onInput,\n      onBlur,\n      onChangeText,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp5 === void 0 ? {} : _temp5;\n    let {\n      suppressRefError = false\n    } = _temp6 === void 0 ? {} : _temp6;\n    setGetterPropCallInfo('getInputProps', suppressRefError, refKey, inputRef);\n    const latestState = latest.current.state;\n\n    const inputHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && inputKeyDownHandlers[key]) {\n        inputKeyDownHandlers[key](event);\n      }\n    };\n\n    const inputHandleChange = event => {\n      dispatch({\n        type: InputChange,\n        inputValue: event.target.value\n      });\n    };\n\n    const inputHandleBlur = () => {\n      /* istanbul ignore else */\n      if (latestState.isOpen && !mouseAndTouchTrackersRef.current.isMouseDown) {\n        dispatch({\n          type: InputBlur,\n          selectItem: true\n        });\n      }\n    };\n    /* istanbul ignore next (preact) */\n\n\n    const onChangeKey = 'onChange';\n    let eventHandlers = {};\n\n    if (!rest.disabled) {\n      eventHandlers = {\n        [onChangeKey]: callAllEventHandlers(onChange, onInput, inputHandleChange),\n        onKeyDown: callAllEventHandlers(onKeyDown, inputHandleKeyDown),\n        onBlur: callAllEventHandlers(onBlur, inputHandleBlur)\n      };\n    }\n\n    return {\n      [refKey]: handleRefs(ref, inputNode => {\n        inputRef.current = inputNode;\n      }),\n      id: elementIds.inputId,\n      'aria-autocomplete': 'list',\n      'aria-controls': elementIds.menuId,\n      ...(latestState.isOpen && latestState.highlightedIndex > -1 && {\n        'aria-activedescendant': elementIds.getItemId(latestState.highlightedIndex)\n      }),\n      'aria-labelledby': elementIds.labelId,\n      // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion\n      // revert back since autocomplete=\"nope\" is ignored on latest Chrome and Opera\n      autoComplete: 'off',\n      value: latestState.inputValue,\n      ...eventHandlers,\n      ...rest\n    };\n  }, [dispatch, inputKeyDownHandlers, latest, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds]);\n  const getComboboxProps = useCallback(function (_temp7, _temp8) {\n    let {\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp7 === void 0 ? {} : _temp7;\n    let {\n      suppressRefError = false\n    } = _temp8 === void 0 ? {} : _temp8;\n    setGetterPropCallInfo('getComboboxProps', suppressRefError, refKey, comboboxRef);\n    return {\n      [refKey]: handleRefs(ref, comboboxNode => {\n        comboboxRef.current = comboboxNode;\n      }),\n      role: 'combobox',\n      'aria-haspopup': 'listbox',\n      'aria-owns': elementIds.menuId,\n      'aria-expanded': latest.current.state.isOpen,\n      ...rest\n    };\n  }, [latest, setGetterPropCallInfo, elementIds]); // returns\n\n  const toggleMenu = useCallback(() => {\n    dispatch({\n      type: FunctionToggleMenu\n    });\n  }, [dispatch]);\n  const closeMenu = useCallback(() => {\n    dispatch({\n      type: FunctionCloseMenu\n    });\n  }, [dispatch]);\n  const openMenu = useCallback(() => {\n    dispatch({\n      type: FunctionOpenMenu\n    });\n  }, [dispatch]);\n  const setHighlightedIndex = useCallback(newHighlightedIndex => {\n    dispatch({\n      type: FunctionSetHighlightedIndex,\n      highlightedIndex: newHighlightedIndex\n    });\n  }, [dispatch]);\n  const selectItem = useCallback(newSelectedItem => {\n    dispatch({\n      type: FunctionSelectItem,\n      selectedItem: newSelectedItem\n    });\n  }, [dispatch]);\n  const setInputValue = useCallback(newInputValue => {\n    dispatch({\n      type: FunctionSetInputValue,\n      inputValue: newInputValue\n    });\n  }, [dispatch]);\n  const reset = useCallback(() => {\n    dispatch({\n      type: FunctionReset$1\n    });\n  }, [dispatch]);\n  return {\n    // prop getters.\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    getInputProps,\n    getComboboxProps,\n    getToggleButtonProps,\n    // actions.\n    toggleMenu,\n    openMenu,\n    closeMenu,\n    setHighlightedIndex,\n    setInputValue,\n    selectItem,\n    reset,\n    // state.\n    highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\n\nconst defaultStateValues = {\n  activeIndex: -1,\n  selectedItems: []\n};\n/**\n * Returns the initial value for a state key in the following order:\n * 1. controlled prop, 2. initial prop, 3. default prop, 4. default\n * value from Downshift.\n *\n * @param {Object} props Props passed to the hook.\n * @param {string} propKey Props key to generate the value for.\n * @returns {any} The initial value for that prop.\n */\n\nfunction getInitialValue(props, propKey) {\n  return getInitialValue$1(props, propKey, defaultStateValues);\n}\n/**\n * Returns the default value for a state key in the following order:\n * 1. controlled prop, 2. default prop, 3. default value from Downshift.\n *\n * @param {Object} props Props passed to the hook.\n * @param {string} propKey Props key to generate the value for.\n * @returns {any} The initial value for that prop.\n */\n\n\nfunction getDefaultValue(props, propKey) {\n  return getDefaultValue$1(props, propKey, defaultStateValues);\n}\n/**\n * Gets the initial state based on the provided props. It uses initial, default\n * and controlled props related to state in order to compute the initial value.\n *\n * @param {Object} props Props passed to the hook.\n * @returns {Object} The initial state.\n */\n\n\nfunction getInitialState(props) {\n  const activeIndex = getInitialValue(props, 'activeIndex');\n  const selectedItems = getInitialValue(props, 'selectedItems');\n  return {\n    activeIndex,\n    selectedItems\n  };\n}\n/**\n * Returns true if dropdown keydown operation is permitted. Should not be\n * allowed on keydown with modifier keys (ctrl, alt, shift, meta), on\n * input element with text content that is either highlighted or selection\n * cursor is not at the starting position.\n *\n * @param {KeyboardEvent} event The event from keydown.\n * @returns {boolean} Whether the operation is allowed.\n */\n\n\nfunction isKeyDownOperationPermitted(event) {\n  if (event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {\n    return false;\n  }\n\n  const element = event.target;\n\n  if (element instanceof HTMLInputElement && // if element is a text input\n  element.value !== '' && ( // and we have text in it\n  // and cursor is either not at the start or is currently highlighting text.\n  element.selectionStart !== 0 || element.selectionEnd !== 0)) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Returns a message to be added to aria-live region when item is removed.\n *\n * @param {Object} selectionParameters Parameters required to build the message.\n * @returns {string} The a11y message.\n */\n\n\nfunction getA11yRemovalMessage(selectionParameters) {\n  const {\n    removedSelectedItem,\n    itemToString: itemToStringLocal\n  } = selectionParameters;\n  return `${itemToStringLocal(removedSelectedItem)} has been removed.`;\n}\n\nconst propTypes = {\n  selectedItems: PropTypes.array,\n  initialSelectedItems: PropTypes.array,\n  defaultSelectedItems: PropTypes.array,\n  itemToString: PropTypes.func,\n  getA11yRemovalMessage: PropTypes.func,\n  stateReducer: PropTypes.func,\n  activeIndex: PropTypes.number,\n  initialActiveIndex: PropTypes.number,\n  defaultActiveIndex: PropTypes.number,\n  onActiveIndexChange: PropTypes.func,\n  onSelectedItemsChange: PropTypes.func,\n  keyNavigationNext: PropTypes.string,\n  keyNavigationPrevious: PropTypes.string,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  })\n};\nconst defaultProps = {\n  itemToString: defaultProps$3.itemToString,\n  stateReducer: defaultProps$3.stateReducer,\n  environment: defaultProps$3.environment,\n  getA11yRemovalMessage,\n  keyNavigationNext: 'ArrowRight',\n  keyNavigationPrevious: 'ArrowLeft'\n}; // eslint-disable-next-line import/no-mutable-exports\n\nlet validatePropTypes = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validatePropTypes = (options, caller) => {\n    PropTypes.checkPropTypes(propTypes, options, 'prop', caller.name);\n  };\n}\n\nconst SelectedItemClick = process.env.NODE_ENV !== \"production\" ? '__selected_item_click__' : 0;\nconst SelectedItemKeyDownDelete = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_delete__' : 1;\nconst SelectedItemKeyDownBackspace = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_backspace__' : 2;\nconst SelectedItemKeyDownNavigationNext = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_navigation_next__' : 3;\nconst SelectedItemKeyDownNavigationPrevious = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_navigation_previous__' : 4;\nconst DropdownKeyDownNavigationPrevious = process.env.NODE_ENV !== \"production\" ? '__dropdown_keydown_navigation_previous__' : 5;\nconst DropdownKeyDownBackspace = process.env.NODE_ENV !== \"production\" ? '__dropdown_keydown_backspace__' : 6;\nconst DropdownClick = process.env.NODE_ENV !== \"production\" ? '__dropdown_click__' : 7;\nconst FunctionAddSelectedItem = process.env.NODE_ENV !== \"production\" ? '__function_add_selected_item__' : 8;\nconst FunctionRemoveSelectedItem = process.env.NODE_ENV !== \"production\" ? '__function_remove_selected_item__' : 9;\nconst FunctionSetSelectedItems = process.env.NODE_ENV !== \"production\" ? '__function_set_selected_items__' : 10;\nconst FunctionSetActiveIndex = process.env.NODE_ENV !== \"production\" ? '__function_set_active_index__' : 11;\nconst FunctionReset = process.env.NODE_ENV !== \"production\" ? '__function_reset__' : 12;\n\nvar stateChangeTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  SelectedItemClick: SelectedItemClick,\n  SelectedItemKeyDownDelete: SelectedItemKeyDownDelete,\n  SelectedItemKeyDownBackspace: SelectedItemKeyDownBackspace,\n  SelectedItemKeyDownNavigationNext: SelectedItemKeyDownNavigationNext,\n  SelectedItemKeyDownNavigationPrevious: SelectedItemKeyDownNavigationPrevious,\n  DropdownKeyDownNavigationPrevious: DropdownKeyDownNavigationPrevious,\n  DropdownKeyDownBackspace: DropdownKeyDownBackspace,\n  DropdownClick: DropdownClick,\n  FunctionAddSelectedItem: FunctionAddSelectedItem,\n  FunctionRemoveSelectedItem: FunctionRemoveSelectedItem,\n  FunctionSetSelectedItems: FunctionSetSelectedItems,\n  FunctionSetActiveIndex: FunctionSetActiveIndex,\n  FunctionReset: FunctionReset\n});\n\n/* eslint-disable complexity */\n\nfunction downshiftMultipleSelectionReducer(state, action) {\n  const {\n    type,\n    index,\n    props,\n    selectedItem\n  } = action;\n  const {\n    activeIndex,\n    selectedItems\n  } = state;\n  let changes;\n\n  switch (type) {\n    case SelectedItemClick:\n      changes = {\n        activeIndex: index\n      };\n      break;\n\n    case SelectedItemKeyDownNavigationPrevious:\n      changes = {\n        activeIndex: activeIndex - 1 < 0 ? 0 : activeIndex - 1\n      };\n      break;\n\n    case SelectedItemKeyDownNavigationNext:\n      changes = {\n        activeIndex: activeIndex + 1 >= selectedItems.length ? -1 : activeIndex + 1\n      };\n      break;\n\n    case SelectedItemKeyDownBackspace:\n    case SelectedItemKeyDownDelete:\n      {\n        let newActiveIndex = activeIndex;\n\n        if (selectedItems.length === 1) {\n          newActiveIndex = -1;\n        } else if (activeIndex === selectedItems.length - 1) {\n          newActiveIndex = selectedItems.length - 2;\n        }\n\n        changes = {\n          selectedItems: [...selectedItems.slice(0, activeIndex), ...selectedItems.slice(activeIndex + 1)],\n          ...{\n            activeIndex: newActiveIndex\n          }\n        };\n        break;\n      }\n\n    case DropdownKeyDownNavigationPrevious:\n      changes = {\n        activeIndex: selectedItems.length - 1\n      };\n      break;\n\n    case DropdownKeyDownBackspace:\n      changes = {\n        selectedItems: selectedItems.slice(0, selectedItems.length - 1)\n      };\n      break;\n\n    case FunctionAddSelectedItem:\n      changes = {\n        selectedItems: [...selectedItems, selectedItem]\n      };\n      break;\n\n    case DropdownClick:\n      changes = {\n        activeIndex: -1\n      };\n      break;\n\n    case FunctionRemoveSelectedItem:\n      {\n        let newActiveIndex = activeIndex;\n        const selectedItemIndex = selectedItems.indexOf(selectedItem);\n\n        if (selectedItemIndex >= 0) {\n          if (selectedItems.length === 1) {\n            newActiveIndex = -1;\n          } else if (selectedItemIndex === selectedItems.length - 1) {\n            newActiveIndex = selectedItems.length - 2;\n          }\n\n          changes = {\n            selectedItems: [...selectedItems.slice(0, selectedItemIndex), ...selectedItems.slice(selectedItemIndex + 1)],\n            activeIndex: newActiveIndex\n          };\n        }\n\n        break;\n      }\n\n    case FunctionSetSelectedItems:\n      {\n        const {\n          selectedItems: newSelectedItems\n        } = action;\n        changes = {\n          selectedItems: newSelectedItems\n        };\n        break;\n      }\n\n    case FunctionSetActiveIndex:\n      {\n        const {\n          activeIndex: newActiveIndex\n        } = action;\n        changes = {\n          activeIndex: newActiveIndex\n        };\n        break;\n      }\n\n    case FunctionReset:\n      changes = {\n        activeIndex: getDefaultValue(props, 'activeIndex'),\n        selectedItems: getDefaultValue(props, 'selectedItems')\n      };\n      break;\n\n    default:\n      throw new Error('Reducer called without proper action type.');\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n\nuseMultipleSelection.stateChangeTypes = stateChangeTypes;\n\nfunction useMultipleSelection(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n\n  validatePropTypes(userProps, useMultipleSelection); // Props defaults and destructuring.\n\n  const props = { ...defaultProps,\n    ...userProps\n  };\n  const {\n    getA11yRemovalMessage,\n    itemToString,\n    environment,\n    keyNavigationNext,\n    keyNavigationPrevious\n  } = props; // Reducer init.\n\n  const [state, dispatch] = useControlledReducer$1(downshiftMultipleSelectionReducer, getInitialState(props), props);\n  const {\n    activeIndex,\n    selectedItems\n  } = state; // Refs.\n\n  const isInitialMountRef = useRef(true);\n  const dropdownRef = useRef(null);\n  const previousSelectedItemsRef = useRef(selectedItems);\n  const selectedItemRefs = useRef();\n  selectedItemRefs.current = [];\n  const latest = useLatestRef({\n    state,\n    props\n  }); // Effects.\n\n  /* Sets a11y status message on changes in selectedItem. */\n\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    if (selectedItems.length < previousSelectedItemsRef.current.length) {\n      const removedSelectedItem = previousSelectedItemsRef.current.find(item => selectedItems.indexOf(item) < 0);\n      setStatus(getA11yRemovalMessage({\n        itemToString,\n        resultCount: selectedItems.length,\n        removedSelectedItem,\n        activeIndex,\n        activeSelectedItem: selectedItems[activeIndex]\n      }), environment.document);\n    }\n\n    previousSelectedItemsRef.current = selectedItems; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [selectedItems.length]); // Sets focus on active item.\n\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    if (activeIndex === -1 && dropdownRef.current) {\n      dropdownRef.current.focus();\n    } else if (selectedItemRefs.current[activeIndex]) {\n      selectedItemRefs.current[activeIndex].focus();\n    }\n  }, [activeIndex]);\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker('getDropdownProps'); // Make initial ref false.\n\n  useEffect(() => {\n    isInitialMountRef.current = false;\n  }, []); // Event handler functions.\n\n  const selectedItemKeyDownHandlers = useMemo(() => ({\n    [keyNavigationPrevious]() {\n      dispatch({\n        type: SelectedItemKeyDownNavigationPrevious\n      });\n    },\n\n    [keyNavigationNext]() {\n      dispatch({\n        type: SelectedItemKeyDownNavigationNext\n      });\n    },\n\n    Delete() {\n      dispatch({\n        type: SelectedItemKeyDownDelete\n      });\n    },\n\n    Backspace() {\n      dispatch({\n        type: SelectedItemKeyDownBackspace\n      });\n    }\n\n  }), [dispatch, keyNavigationNext, keyNavigationPrevious]);\n  const dropdownKeyDownHandlers = useMemo(() => ({\n    [keyNavigationPrevious](event) {\n      if (isKeyDownOperationPermitted(event)) {\n        dispatch({\n          type: DropdownKeyDownNavigationPrevious\n        });\n      }\n    },\n\n    Backspace(event) {\n      if (isKeyDownOperationPermitted(event)) {\n        dispatch({\n          type: DropdownKeyDownBackspace\n        });\n      }\n    }\n\n  }), [dispatch, keyNavigationPrevious]); // Getter props.\n\n  const getSelectedItemProps = useCallback(function (_temp) {\n    let {\n      refKey = 'ref',\n      ref,\n      onClick,\n      onKeyDown,\n      selectedItem,\n      index,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    const {\n      state: latestState\n    } = latest.current;\n    const itemIndex = getItemIndex(index, selectedItem, latestState.selectedItems);\n\n    if (itemIndex < 0) {\n      throw new Error('Pass either selectedItem or index in getSelectedItemProps!');\n    }\n\n    const selectedItemHandleClick = () => {\n      dispatch({\n        type: SelectedItemClick,\n        index\n      });\n    };\n\n    const selectedItemHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && selectedItemKeyDownHandlers[key]) {\n        selectedItemKeyDownHandlers[key](event);\n      }\n    };\n\n    return {\n      [refKey]: handleRefs(ref, selectedItemNode => {\n        if (selectedItemNode) {\n          selectedItemRefs.current.push(selectedItemNode);\n        }\n      }),\n      tabIndex: index === latestState.activeIndex ? 0 : -1,\n      onClick: callAllEventHandlers(onClick, selectedItemHandleClick),\n      onKeyDown: callAllEventHandlers(onKeyDown, selectedItemHandleKeyDown),\n      ...rest\n    };\n  }, [dispatch, latest, selectedItemKeyDownHandlers]);\n  const getDropdownProps = useCallback(function (_temp2, _temp3) {\n    let {\n      refKey = 'ref',\n      ref,\n      onKeyDown,\n      onClick,\n      preventKeyAction = false,\n      ...rest\n    } = _temp2 === void 0 ? {} : _temp2;\n    let {\n      suppressRefError = false\n    } = _temp3 === void 0 ? {} : _temp3;\n    setGetterPropCallInfo('getDropdownProps', suppressRefError, refKey, dropdownRef);\n\n    const dropdownHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && dropdownKeyDownHandlers[key]) {\n        dropdownKeyDownHandlers[key](event);\n      }\n    };\n\n    const dropdownHandleClick = () => {\n      dispatch({\n        type: DropdownClick\n      });\n    };\n\n    return {\n      [refKey]: handleRefs(ref, dropdownNode => {\n        if (dropdownNode) {\n          dropdownRef.current = dropdownNode;\n        }\n      }),\n      ...(!preventKeyAction && {\n        onKeyDown: callAllEventHandlers(onKeyDown, dropdownHandleKeyDown),\n        onClick: callAllEventHandlers(onClick, dropdownHandleClick)\n      }),\n      ...rest\n    };\n  }, [dispatch, dropdownKeyDownHandlers, setGetterPropCallInfo]); // returns\n\n  const addSelectedItem = useCallback(selectedItem => {\n    dispatch({\n      type: FunctionAddSelectedItem,\n      selectedItem\n    });\n  }, [dispatch]);\n  const removeSelectedItem = useCallback(selectedItem => {\n    dispatch({\n      type: FunctionRemoveSelectedItem,\n      selectedItem\n    });\n  }, [dispatch]);\n  const setSelectedItems = useCallback(newSelectedItems => {\n    dispatch({\n      type: FunctionSetSelectedItems,\n      selectedItems: newSelectedItems\n    });\n  }, [dispatch]);\n  const setActiveIndex = useCallback(newActiveIndex => {\n    dispatch({\n      type: FunctionSetActiveIndex,\n      activeIndex: newActiveIndex\n    });\n  }, [dispatch]);\n  const reset = useCallback(() => {\n    dispatch({\n      type: FunctionReset\n    });\n  }, [dispatch]);\n  return {\n    getSelectedItemProps,\n    getDropdownProps,\n    addSelectedItem,\n    removeSelectedItem,\n    setSelectedItems,\n    setActiveIndex,\n    reset,\n    selectedItems,\n    activeIndex\n  };\n}\n\nexport { Downshift$1 as default, resetIdCounter, useCombobox, useMultipleSelection, useSelect };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}