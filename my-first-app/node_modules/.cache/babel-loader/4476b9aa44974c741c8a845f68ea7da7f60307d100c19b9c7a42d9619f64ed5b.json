{"ast":null,"code":"import e, { useState, useRef, useCallback, useMemo } from 'react';\nimport { Checkbox, TextInput } from '@contentful/f36-forms';\nimport { Text, Subheading } from '@contentful/f36-typography';\nimport { cx, css } from 'emotion';\nimport r from '@contentful/f36-tokens';\nimport { getStringMatch } from '@contentful/f36-utils';\nimport { mergeRefs } from '@contentful/f36-core';\nimport { Button, IconButton } from '@contentful/f36-button';\nimport { ChevronDownIcon, CloseIcon, SearchIcon } from '@contentful/f36-icons';\nimport { SkeletonContainer, SkeletonBodyText } from '@contentful/f36-skeleton';\nimport { Popover } from '@contentful/f36-popover';\nvar ce = Object.defineProperty,\n  pe = Object.defineProperties;\nvar ue = Object.getOwnPropertyDescriptors;\nvar C = Object.getOwnPropertySymbols;\nvar W = Object.prototype.hasOwnProperty,\n  j = Object.prototype.propertyIsEnumerable;\nvar F = (t, l, o) => l in t ? ce(t, l, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: o\n  }) : t[l] = o,\n  h = (t, l) => {\n    for (var o in l || (l = {})) W.call(l, o) && F(t, o, l[o]);\n    if (C) for (var o of C(l)) j.call(l, o) && F(t, o, l[o]);\n    return t;\n  },\n  U = (t, l) => pe(t, ue(l));\nvar P = (t, l) => {\n  var o = {};\n  for (var n in t) W.call(t, n) && l.indexOf(n) < 0 && (o[n] = t[n]);\n  if (t != null && C) for (var n of C(t)) l.indexOf(n) < 0 && j.call(t, n) && (o[n] = t[n]);\n  return o;\n};\nvar M = () => ({\n  multiselect: css({\n    position: \"relative\",\n    width: \"100%\"\n  }),\n  triggerButton: css({\n    justifyContent: \"space-between\"\n  }),\n  currentSelection: css({\n    width: \"50%\",\n    whiteSpace: \"nowrap\",\n    textOverflow: \"ellipsis\",\n    overflow: \"hidden\",\n    verticalAlign: \"bottom\",\n    marginRight: r.spacing2Xs\n  }),\n  currentSelectionAddition: css({\n    color: r.gray600\n  }),\n  inputField: css({\n    paddingRight: r.spacingXl,\n    textOverflow: \"ellipsis\",\n    whiteSpace: \"nowrap\",\n    border: \"none\",\n    borderRadius: \"0px\",\n    borderBottom: `1px solid ${r.gray200}`\n  }),\n  toggleButton: css({\n    position: \"absolute\",\n    top: \"1px\",\n    right: \"1px\",\n    zIndex: r.zIndexDefault,\n    padding: r.spacing2Xs,\n    height: r.spacingXl\n  }),\n  content: t => css({\n    overflow: \"auto\",\n    maxHeight: `${t}px`\n  }),\n  list: css({\n    listStyle: \"none\",\n    padding: `${r.spacingXs} 0`,\n    margin: 0\n  }),\n  groupTitle: css({\n    padding: `${r.spacingXs} ${r.spacingM}`,\n    lineHeight: r.lineHeightM\n  }),\n  noMatchesTitle: css({\n    color: r.gray500,\n    margin: r.spacingM\n  }),\n  selectAll: css({\n    \"label > *\": {\n      fontWeight: \"bold\"\n    }\n  }),\n  item: css({\n    label: {\n      padding: `${r.spacingXs} ${r.spacingM}`,\n      wordBreak: \"break-word\",\n      whiteSpace: \"break-spaces\",\n      hyphens: \"auto\",\n      display: \"flex\",\n      flexDirection: \"row\",\n      alignItems: \"center\",\n      cursor: \"pointer\",\n      \"&:focus, &:hover\": {\n        backgroundColor: r.gray100\n      },\n      \"&:active\": {\n        backgroundColor: r.gray200\n      },\n      \"&:focus\": {\n        boxShadow: r.glowPrimary\n      },\n      \"&:focus:not(:focus-visible)\": {\n        boxShadow: \"unset\"\n      },\n      \"&:focus-visible\": {\n        boxShadow: r.glowPrimary\n      }\n    }\n  }),\n  disabled: css({\n    opacity: .5,\n    cursor: \"not-allowed\"\n  })\n});\nvar d = H => {\n  var x = H,\n    {\n      label: t,\n      value: l,\n      itemId: o,\n      onSelectItem: n,\n      searchValue: p,\n      isChecked: u = !1,\n      isDisabled: c = !1,\n      className: S\n    } = x,\n    v = P(x, [\"label\", \"value\", \"itemId\", \"onSelectItem\", \"searchValue\", \"isChecked\", \"isDisabled\", \"className\"]);\n  let y = M();\n  return e.createElement(\"li\", h({\n    className: S\n  }, v), e.createElement(Checkbox, {\n    id: o,\n    value: l,\n    onChange: b => n(b),\n    isChecked: u,\n    isDisabled: c,\n    className: cx(y.item, c && y.disabled)\n  }, e.createElement(Text, {\n    \"data-test-id\": `cf-multiselect-list-item-${o}`\n  }, e.createElement(_, {\n    item: t,\n    inputValue: p\n  }))));\n};\nfunction _(_ref) {\n  let {\n    item: t,\n    inputValue: l = \"\"\n  } = _ref;\n  let {\n    before: o,\n    match: n,\n    after: p\n  } = getStringMatch(t, l);\n  return e.createElement(e.Fragment, null, o, e.createElement(\"b\", {\n    \"data-test-id\": \"cf-multiselect-item-match\"\n  }, n), p);\n}\n_.displayName = \"HighlightedItem\";\nvar Q = (t, l, o) => e.Children.map(t, n => {\n    if (!e.isValidElement(n)) return n;\n    if (l(n)) return o(n);\n    let p = Q(n.props.children, l, o);\n    return e.cloneElement(n, {\n      children: p\n    });\n  }),\n  Y = (t, l) => {\n    let o = 0;\n    return e.Children.forEach(t, n => {\n      !e.isValidElement(n) || (l(n) ? o += 1 : o += Y(n.props.children, l));\n    }), o;\n  };\nfunction Pe(t, l) {\n  let {\n      className: o,\n      startIcon: n,\n      placeholder: p = \"Select one or more Items\",\n      currentSelection: u = [],\n      onSearchValueChange: c,\n      searchPlaceholder: S = \"Search\",\n      searchInputRef: v,\n      searchInputName: H,\n      noMatchesMessage: x = \"No matches found\",\n      toggleRef: y,\n      isLoading: b = !1,\n      testId: ee = \"cf-multiselect\",\n      popoverProps: N = {},\n      children: I,\n      onBlur: E\n    } = t,\n    {\n      listMaxHeight: te = 180,\n      listRef: oe\n    } = N,\n    a = M(),\n    [m, R] = useState(\"\"),\n    [B, V] = useState(!1),\n    L = useRef(null),\n    D = useRef(null),\n    $ = typeof c == \"function\",\n    O = useCallback(() => {\n      var i;\n      (i = D.current) == null || i.focus();\n    }, []),\n    le = useCallback(i => {\n      R(i.target.value), c == null || c(i);\n    }, [c, R]),\n    ne = useCallback(() => {\n      if (!m) return;\n      O(), Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, \"value\").set.call(L.current, \"\");\n      let f = new Event(\"change\", {\n        bubbles: !0\n      });\n      L.current.dispatchEvent(f);\n    }, [m, O]),\n    re = useCallback(() => {\n      if (u.length === 0) return e.createElement(e.Fragment, null, p);\n      let i = u.length - 1;\n      return i === 0 ? e.createElement(\"span\", {\n        \"data-test-id\": \"cf-multiselect-current-selection\",\n        className: a.currentSelection\n      }, u[0]) : e.createElement(\"span\", {\n        \"data-test-id\": \"cf-multiselect-current-selection\",\n        className: a.currentSelection\n      }, u[0], \" \", e.createElement(\"span\", {\n        className: a.currentSelectionAddition\n      }, \"and \", i, \" more\"));\n    }, [u, p, a.currentSelection, a.currentSelectionAddition]),\n    X = useMemo(() => Y(I, i => i.type === d), [I]),\n    ie = e.useCallback(i => Q(i, f => f.type === d, f => {\n      let se = ae => {\n        var z;\n        O(), (z = f.props) == null || z.onSelectItem(ae);\n      };\n      return e.cloneElement(f, {\n        searchValue: m,\n        onSelectItem: se\n      });\n    }), [m, O]);\n  return e.createElement(\"div\", {\n    \"data-test-id\": ee,\n    className: cx(a.multiselect, o),\n    ref: l\n  }, e.createElement(Popover, U(h({\n    renderOnlyWhenOpen: !1,\n    isFullWidth: !0\n  }, N), {\n    isOpen: B,\n    onClose: () => V(!1)\n  }), e.createElement(Popover.Trigger, null, e.createElement(Button, {\n    \"aria-label\": \"Toggle Multiselect\",\n    ref: y,\n    onClick: () => V(!B),\n    startIcon: n,\n    endIcon: e.createElement(ChevronDownIcon, null),\n    isFullWidth: !0,\n    className: a.triggerButton\n  }, re())), e.createElement(Popover.Content, {\n    ref: mergeRefs(oe, D),\n    className: cx(a.content(te), N.className),\n    testId: \"cf-multiselect-container\",\n    onBlur: () => E == null ? void 0 : E()\n  }, e.createElement(e.Fragment, null, $ && e.createElement(e.Fragment, null, e.createElement(TextInput, {\n    \"aria-label\": \"Search\",\n    type: \"text\",\n    value: m,\n    className: a.inputField,\n    testId: \"cf-multiselect-search\",\n    placeholder: S,\n    onChange: le,\n    ref: mergeRefs(v, L),\n    name: H,\n    size: \"small\"\n  }), e.createElement(IconButton, {\n    \"aria-label\": m ? \"Clear search\" : \"Search\",\n    className: a.toggleButton,\n    variant: \"transparent\",\n    icon: m ? e.createElement(CloseIcon, {\n      variant: \"muted\"\n    }) : e.createElement(SearchIcon, {\n      variant: \"muted\"\n    }),\n    onClick: ne,\n    isDisabled: !m,\n    size: \"small\"\n  })), b && e.createElement(we, null), !b && X > 0 && e.createElement(\"ul\", {\n    className: a.list,\n    \"data-test-id\": \"cf-multiselect-items\"\n  }, $ ? ie(I) : I), !b && X === 0 && e.createElement(Subheading, {\n    className: a.noMatchesTitle\n  }, x)))));\n}\nvar we = () => e.createElement(SkeletonContainer, {\n    svgHeight: 16\n  }, e.createElement(SkeletonBodyText, {\n    numberOfLines: 1\n  })),\n  Z = e.forwardRef(Pe);\nvar k = u => {\n  var c = u,\n    {\n      label: t,\n      onSelectItem: l,\n      isChecked: o = !1,\n      className: n\n    } = c,\n    p = P(c, [\"label\", \"onSelectItem\", \"isChecked\", \"className\"]);\n  let S = M();\n  return e.createElement(d, h({\n    value: \"all\",\n    label: t || o ? \"Deselect all\" : \"Select all\",\n    itemId: \"SelectAll\",\n    onSelectItem: l,\n    isChecked: o,\n    className: cx(S.selectAll, n)\n  }, p));\n};\nvar A = Z;\nA.Option = d;\nA.SelectAll = k;\nexport { A as Multiselect, d as MultiselectOption, k as SelectAllOption };","map":{"version":3,"names":[],"sources":["/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-multiselect/src/MultiselectOption.tsx","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-multiselect/src/Multiselect.styles.ts","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-multiselect/src/Multiselect.tsx","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-multiselect/src/SelectAllOption.tsx","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-multiselect/src/CompoundMultiselect.tsx"],"sourcesContent":["import React from 'react';\nimport { Checkbox } from '@contentful/f36-forms';\nimport { Text } from '@contentful/f36-typography';\nimport { getMultiselectStyles } from './Multiselect.styles';\nimport { getStringMatch } from '@contentful/f36-utils';\nimport { cx } from 'emotion';\n\nexport interface MultiselectOptionProps {\n  label: string;\n  value: string;\n  itemId: string;\n  searchValue?: string;\n  className?: string;\n  onSelectItem: (event: React.ChangeEvent<HTMLInputElement>) => void;\n  isChecked?: boolean;\n  isDisabled?: boolean;\n}\n\nexport const MultiselectOption = ({\n  label,\n  value,\n  itemId,\n  onSelectItem,\n  searchValue,\n  isChecked = false,\n  isDisabled = false,\n  className,\n  ...rest\n}: MultiselectOptionProps) => {\n  const styles = getMultiselectStyles();\n\n  return (\n    <li className={className} {...rest}>\n      <Checkbox\n        id={itemId}\n        value={value}\n        onChange={(event) => onSelectItem(event)}\n        isChecked={isChecked}\n        isDisabled={isDisabled}\n        className={cx(styles.item, isDisabled && styles.disabled)}\n      >\n        <Text data-test-id={`cf-multiselect-list-item-${itemId}`}>\n          <HighlightedItem item={label} inputValue={searchValue} />\n        </Text>\n      </Checkbox>\n    </li>\n  );\n};\n\nfunction HighlightedItem({\n  item,\n  inputValue = '',\n}: {\n  item: string;\n  inputValue?: string;\n}) {\n  const { before, match, after } = getStringMatch(item, inputValue);\n  return (\n    <>\n      {before}\n      <b data-test-id=\"cf-multiselect-item-match\">{match}</b>\n      {after}\n    </>\n  );\n}\n\nHighlightedItem.displayName = 'HighlightedItem';\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\n\nexport const getMultiselectStyles = () => ({\n  multiselect: css({\n    position: 'relative',\n    width: '100%',\n  }),\n  triggerButton: css({\n    justifyContent: 'space-between',\n  }),\n  currentSelection: css({\n    width: '50%',\n    whiteSpace: 'nowrap',\n    textOverflow: 'ellipsis',\n    overflow: 'hidden',\n    verticalAlign: 'bottom',\n    marginRight: tokens.spacing2Xs,\n  }),\n  currentSelectionAddition: css({\n    color: tokens.gray600,\n  }),\n  inputField: css({\n    paddingRight: tokens.spacingXl,\n    textOverflow: 'ellipsis',\n    whiteSpace: 'nowrap',\n    border: 'none',\n    borderRadius: '0px',\n    borderBottom: `1px solid ${tokens.gray200}`,\n  }),\n  toggleButton: css({\n    position: 'absolute',\n    top: '1px',\n    right: '1px',\n    zIndex: tokens.zIndexDefault,\n    padding: tokens.spacing2Xs,\n    height: tokens.spacingXl,\n  }),\n  content: (listMaxHeight: number) =>\n    css({\n      overflow: 'auto',\n      maxHeight: `${listMaxHeight}px`,\n    }),\n  list: css({\n    listStyle: 'none',\n    padding: `${tokens.spacingXs} 0`,\n    margin: 0,\n  }),\n  groupTitle: css({\n    padding: `${tokens.spacingXs} ${tokens.spacingM}`,\n    lineHeight: tokens.lineHeightM,\n  }),\n  noMatchesTitle: css({\n    color: tokens.gray500,\n    margin: tokens.spacingM,\n  }),\n  selectAll: css({\n    'label > *': {\n      fontWeight: 'bold',\n    },\n  }),\n  item: css({\n    label: {\n      padding: `${tokens.spacingXs} ${tokens.spacingM}`,\n      wordBreak: 'break-word',\n      whiteSpace: 'break-spaces',\n      hyphens: 'auto',\n      display: 'flex',\n      flexDirection: 'row',\n      alignItems: 'center',\n      cursor: 'pointer',\n      '&:focus, &:hover': {\n        backgroundColor: tokens.gray100,\n      },\n      '&:active': {\n        backgroundColor: tokens.gray200,\n      },\n      '&:focus': {\n        boxShadow: tokens.glowPrimary,\n      },\n      '&:focus:not(:focus-visible)': {\n        boxShadow: 'unset',\n      },\n      '&:focus-visible': {\n        boxShadow: tokens.glowPrimary,\n      },\n    },\n  }),\n  disabled: css({\n    opacity: 0.5,\n    cursor: 'not-allowed',\n  }),\n});\n","import React, { useRef, useState, useCallback, useMemo } from 'react';\nimport { cx } from 'emotion';\n\nimport { mergeRefs, type CommonProps } from '@contentful/f36-core';\nimport { Button, IconButton } from '@contentful/f36-button';\nimport { TextInput } from '@contentful/f36-forms';\nimport { CloseIcon, ChevronDownIcon, SearchIcon } from '@contentful/f36-icons';\nimport { SkeletonContainer, SkeletonBodyText } from '@contentful/f36-skeleton';\nimport { Popover, type PopoverProps } from '@contentful/f36-popover';\nimport { Subheading } from '@contentful/f36-typography';\n\nimport { getMultiselectStyles } from './Multiselect.styles';\nimport { MultiselectOption, MultiselectOptionProps } from './MultiselectOption';\n\nexport interface MultiselectProps extends CommonProps {\n  /** Select Options */\n  children?: React.ReactNode;\n\n  /**\n   * Set a custom icon for the text input\n   */\n  startIcon?: React.ReactElement;\n\n  /**\n   * Placeholder shown before selecting any elements. Defaults to 'Select one or more items'\n   */\n  placeholder?: string;\n\n  /**\n   * current Selected items, to be shown on the trigger button\n   */\n  currentSelection?: Array<string>;\n\n  /**\n   * Function called whenever the search input value changes\n   */\n  onSearchValueChange?: (\n    event: React.ChangeEvent<HTMLInputElement>,\n  ) => void | undefined;\n\n  /**\n   * This is the value will be passed to the `placeholder` prop of the input.\n   * @default \"Search\"\n   */\n  searchPlaceholder?: string;\n\n  /**\n   * A message that will be shown when it is not possible to find any option that matches the input value\n   * @default \"No matches\"\n   */\n  noMatchesMessage?: string;\n\n  /**\n   * Use this prop to get a ref to the input element of the component\n   */\n  searchInputRef?: React.Ref<HTMLInputElement>;\n\n  /**\n   * Pass a form name to the search text input\n   */\n  searchInputName?: string;\n\n  /**\n   * Sets the list to show its loading state\n   * @default false\n   */\n  isLoading?: boolean;\n\n  /**\n   * Use this prop to get a ref to the toggle button of the component\n   */\n  toggleRef?: React.Ref<HTMLButtonElement>;\n\n  /**\n   * Props to pass to the Popover (Dropdown) component\n   */\n  popoverProps?: Partial<PopoverProps> & {\n    /**\n     * It sets the max-height, in pixels, of the list\n     * The default value is the height of 5 single line items\n     * @default 180\n     */\n    listMaxHeight?: number;\n\n    /**\n     * Use this prop to get a ref to the list of items of the component\n     */\n    listRef?: React.Ref<HTMLUListElement>;\n  } & Pick<CommonProps, 'className'>;\n\n  /**\n   * Function called when the popover loses its focus.\n   */\n  onBlur?: () => void;\n}\n\n// Scan through the whole hierachy until `filter` returns true and apply `transform`\n// Inspired from https://stackoverflow.com/a/70676868/17269164\nconst iterateOverChildren = (\n  children: React.ReactNode,\n  filter: (child: React.ReactElement) => boolean,\n  callback: (child: React.ReactElement) => React.ReactElement | void,\n): React.ReactNode => {\n  return React.Children.map(children, (child) => {\n    // equal to (if (child == null || typeof child == 'string'))\n    if (!React.isValidElement(child)) return child;\n    if (filter(child)) {\n      return callback(child);\n    }\n    const childChildren = iterateOverChildren(\n      child.props.children,\n      filter,\n      callback,\n    );\n    return React.cloneElement(child, { children: childChildren } as unknown);\n  });\n};\n\n// Scan through the whole hierachy to count the number of children where `filter` returns true\nconst countMatchingChildren = (\n  children: React.ReactNode,\n  filter: (child: React.ReactElement) => boolean,\n): number => {\n  let counter = 0;\n  React.Children.forEach(children, (child) => {\n    // equal to (if (child == null || typeof child == 'string'))\n    if (!React.isValidElement(child)) return;\n    if (!filter(child)) {\n      counter += countMatchingChildren(child.props.children, filter);\n    } else {\n      counter += 1;\n    }\n  });\n  return counter;\n};\n\nfunction _Multiselect(props: MultiselectProps, ref: React.Ref<HTMLDivElement>) {\n  const {\n    className,\n    startIcon,\n    placeholder = 'Select one or more Items',\n    currentSelection = [],\n    onSearchValueChange,\n    searchPlaceholder = 'Search',\n    searchInputRef,\n    searchInputName,\n    noMatchesMessage = 'No matches found',\n    toggleRef,\n    isLoading = false,\n    testId = 'cf-multiselect',\n    popoverProps = {},\n    children,\n    onBlur,\n  } = props;\n\n  const { listMaxHeight = 180, listRef } = popoverProps;\n\n  const styles = getMultiselectStyles();\n\n  const [searchValue, setSearchValue] = useState('');\n  const [isOpen, setIsOpen] = useState(false);\n\n  const internalSearchInputRef = useRef<HTMLInputElement>(null);\n  const internalListRef = useRef<HTMLUListElement>(null);\n\n  const hasSearch = typeof onSearchValueChange === 'function';\n\n  const focusList = useCallback(() => {\n    // Clearing the search input or selecting an item triggers a rerendering and\n    // thereby the client loses the focus on the clicked element. To avoid having\n    // the focus on the document body (which breaks `closeOnBlur`), we force it\n    // back to the list in the popup.\n    internalListRef.current?.focus();\n  }, []);\n\n  const handleSearchChange = useCallback(\n    (event) => {\n      setSearchValue(event.target.value);\n      onSearchValueChange?.(event);\n    },\n    [onSearchValueChange, setSearchValue],\n  );\n\n  const resetSearchInput = useCallback(() => {\n    if (!searchValue) return;\n    focusList();\n    // this looks a bit hacky, but is the official way of externally triggering the onChange handler for an input\n    // https://stackoverflow.com/a/46012210/17269164\n    const nativeInputValueSetter = Object.getOwnPropertyDescriptor(\n      window.HTMLInputElement.prototype,\n      'value',\n    ).set;\n    nativeInputValueSetter.call(internalSearchInputRef.current, '');\n    const forcedEvent = new Event('change', { bubbles: true });\n    internalSearchInputRef.current.dispatchEvent(forcedEvent);\n  }, [searchValue, focusList]);\n\n  const renderMultiselectLabel = useCallback(() => {\n    if (currentSelection.length === 0) {\n      return <>{placeholder}</>;\n    }\n    const leftoverCount = currentSelection.length - 1;\n    if (leftoverCount === 0) {\n      return (\n        <span\n          data-test-id=\"cf-multiselect-current-selection\"\n          className={styles.currentSelection}\n        >\n          {currentSelection[0]}\n        </span>\n      );\n    }\n    return (\n      <span\n        data-test-id=\"cf-multiselect-current-selection\"\n        className={styles.currentSelection}\n      >\n        {currentSelection[0]}{' '}\n        <span className={styles.currentSelectionAddition}>\n          and {leftoverCount} more\n        </span>\n      </span>\n    );\n  }, [\n    currentSelection,\n    placeholder,\n    styles.currentSelection,\n    styles.currentSelectionAddition,\n  ]);\n\n  const optionsLength = useMemo(\n    () =>\n      countMatchingChildren(\n        children,\n        (child) => child.type === MultiselectOption,\n      ),\n    [children],\n  );\n\n  // clones and enriches the multiselect options\n  const enrichOptions = React.useCallback(\n    (children: React.ReactNode): React.ReactNode => {\n      return iterateOverChildren(\n        children,\n        (child) => child.type === MultiselectOption,\n        (child) => {\n          const onSelectItem = (event: React.ChangeEvent<HTMLInputElement>) => {\n            focusList();\n            child.props?.onSelectItem(event);\n          };\n          return React.cloneElement(child, {\n            searchValue,\n            onSelectItem,\n          } as Partial<MultiselectOptionProps>);\n        },\n      );\n    },\n    [searchValue, focusList],\n  );\n\n  return (\n    <div\n      data-test-id={testId}\n      className={cx(styles.multiselect, className)}\n      ref={ref}\n    >\n      <Popover\n        renderOnlyWhenOpen={false}\n        isFullWidth\n        {...popoverProps}\n        // popoverProps should never overwrite the internal opening logic\n        isOpen={isOpen}\n        onClose={() => setIsOpen(false)}\n      >\n        <Popover.Trigger>\n          <Button\n            aria-label=\"Toggle Multiselect\"\n            ref={toggleRef}\n            onClick={() => setIsOpen(!isOpen)}\n            startIcon={startIcon}\n            endIcon={<ChevronDownIcon />}\n            isFullWidth\n            className={styles.triggerButton}\n          >\n            {renderMultiselectLabel()}\n          </Button>\n        </Popover.Trigger>\n        <Popover.Content\n          ref={mergeRefs(listRef, internalListRef)}\n          className={cx(styles.content(listMaxHeight), popoverProps.className)}\n          testId=\"cf-multiselect-container\"\n          onBlur={() => onBlur?.()}\n        >\n          <>\n            {hasSearch && (\n              <>\n                <TextInput\n                  aria-label=\"Search\"\n                  type=\"text\"\n                  value={searchValue}\n                  className={styles.inputField}\n                  testId=\"cf-multiselect-search\"\n                  placeholder={searchPlaceholder}\n                  onChange={handleSearchChange}\n                  ref={mergeRefs(searchInputRef, internalSearchInputRef)}\n                  name={searchInputName}\n                  size=\"small\"\n                />\n                <IconButton\n                  aria-label={searchValue ? 'Clear search' : 'Search'}\n                  className={styles.toggleButton}\n                  variant=\"transparent\"\n                  icon={\n                    searchValue ? (\n                      <CloseIcon variant=\"muted\" />\n                    ) : (\n                      <SearchIcon variant=\"muted\" />\n                    )\n                  }\n                  onClick={resetSearchInput}\n                  isDisabled={!searchValue}\n                  size=\"small\"\n                />\n              </>\n            )}\n            {isLoading && <ListItemLoadingState />}\n\n            {!isLoading && optionsLength > 0 && (\n              <ul className={styles.list} data-test-id=\"cf-multiselect-items\">\n                {hasSearch ? enrichOptions(children) : children}\n              </ul>\n            )}\n\n            {!isLoading && optionsLength === 0 && (\n              <Subheading className={styles.noMatchesTitle}>\n                {noMatchesMessage}\n              </Subheading>\n            )}\n          </>\n        </Popover.Content>\n      </Popover>\n    </div>\n  );\n}\n\nconst ListItemLoadingState = () => {\n  return (\n    <SkeletonContainer svgHeight={16}>\n      <SkeletonBodyText numberOfLines={1} />\n    </SkeletonContainer>\n  );\n};\n\n/**\n * The Multiselect is a component that will allow a user to select multiple items.\n * It has an optional\n */\nexport const Multiselect = React.forwardRef(_Multiselect);\n","import React from 'react';\nimport { MultiselectOption, MultiselectOptionProps } from './MultiselectOption';\nimport { getMultiselectStyles } from './Multiselect.styles';\nimport { cx } from 'emotion';\n\nexport interface SelectAllOptionProps\n  extends Omit<MultiselectOptionProps, 'value' | 'itemId' | 'label'> {\n  label?: string;\n}\n\nexport const SelectAllOption = ({\n  label,\n  onSelectItem,\n  isChecked = false,\n  className,\n  ...otherProps\n}: SelectAllOptionProps) => {\n  const styles = getMultiselectStyles();\n  const displayLabel = label || isChecked ? 'Deselect all' : 'Select all';\n  return (\n    <MultiselectOption\n      value=\"all\"\n      label={displayLabel}\n      itemId=\"SelectAll\"\n      onSelectItem={onSelectItem}\n      isChecked={isChecked}\n      className={cx(styles.selectAll, className)}\n      {...otherProps}\n    />\n  );\n};\n","import { Multiselect as OriginalMultiSelect } from './Multiselect';\nimport { MultiselectOption } from './MultiselectOption';\nimport { SelectAllOption } from './SelectAllOption';\n\ntype CompoundMultiselect = typeof OriginalMultiSelect & {\n  Option: typeof MultiselectOption;\n  SelectAll: typeof SelectAllOption;\n};\n\nexport const Multiselect = OriginalMultiSelect as CompoundMultiselect;\nMultiselect.Option = MultiselectOption;\nMultiselect.SelectAll = SelectAllOption;\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}