{"ast":null,"code":"import H, { useState, useEffect, useCallback, useRef, useMemo } from 'react';\nimport { useId, mergeRefs } from '@contentful/f36-core';\nimport { usePopper } from 'react-popper';\nimport { cx, css } from 'emotion';\nimport { Portal } from '@contentful/f36-utils';\nimport x from '@contentful/f36-tokens';\nvar oe = Object.defineProperty,\n  te = Object.defineProperties;\nvar re = Object.getOwnPropertyDescriptors;\nvar b = Object.getOwnPropertySymbols;\nvar F = Object.prototype.hasOwnProperty,\n  N = Object.prototype.propertyIsEnumerable;\nvar B = (e, t, o) => t in e ? oe(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: o\n  }) : e[t] = o,\n  l = (e, t) => {\n    for (var o in t || (t = {})) F.call(t, o) && B(e, o, t[o]);\n    if (b) for (var o of b(t)) N.call(t, o) && B(e, o, t[o]);\n    return e;\n  },\n  f = (e, t) => te(e, re(t));\nvar k = (e, t) => {\n  var o = {};\n  for (var r in e) F.call(e, r) && t.indexOf(r) < 0 && (o[r] = e[r]);\n  if (e != null && b) for (var r of b(e)) t.indexOf(r) < 0 && N.call(e, r) && (o[r] = e[r]);\n  return o;\n};\nvar A = (e, t, o) => new Promise((r, m) => {\n  var v = s => {\n      try {\n        c(o.next(s));\n      } catch (n) {\n        m(n);\n      }\n    },\n    d = s => {\n      try {\n        c(o.throw(s));\n      } catch (n) {\n        m(n);\n      }\n    },\n    c = s => s.done ? r(s.value) : Promise.resolve(s.value).then(v, d);\n  c((o = o.apply(e, t)).next());\n});\nvar z = H.createContext(void 0),\n  y = () => {\n    let e = H.useContext(z);\n    if (e === void 0) throw new Error(\"usePopoverContext must be used within a PopoverContextProvider\");\n    return e;\n  },\n  U = z.Provider;\nfunction G(e) {\n  let {\n      children: t,\n      isOpen: o,\n      placement: r = \"bottom-start\",\n      isFullWidth: m = !1,\n      isAutoalignmentEnabled: v = !0,\n      usePortal: d = !0,\n      closeOnBlur: c = !0,\n      closeOnEsc: s = !0,\n      onClose: n,\n      autoFocus: h = !0,\n      id: C,\n      offset: T = [1, 4],\n      renderOnlyWhenOpen: g = !0\n    } = e,\n    [i, Q] = useState(null),\n    [u, X] = useState(null),\n    {\n      attributes: W,\n      update: M,\n      styles: S\n    } = usePopper(i, u, {\n      placement: r,\n      modifiers: [{\n        name: \"offset\",\n        options: {\n          offset: T\n        }\n      }, f(l({}, ce), {\n        enabled: m\n      }), {\n        name: \"preventOverflow\",\n        enabled: v,\n        options: {\n          mainAxis: !0\n        }\n      }, {\n        name: \"flip\",\n        enabled: v\n      }]\n    });\n  useEffect(() => {\n    o && h && u && u.focus({\n      preventScroll: !0\n    });\n  }, [o, u]), useEffect(() => {\n    (() => A(this, null, function* () {\n      o && M && (yield M());\n    }))();\n  }, [o, M]);\n  let Y = useId(void 0, \"popover-content\"),\n    E = C || Y,\n    I = useCallback(() => {\n      n == null || n(), setTimeout(() => i == null ? void 0 : i.focus({\n        preventScroll: !0\n      }), 0);\n    }, [n, i]),\n    w = useRef(!1),\n    Z = useMemo(() => ({\n      isOpen: Boolean(o),\n      usePortal: d,\n      renderOnlyWhenOpen: g,\n      getTriggerProps: function () {\n        let p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let O = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        return {\n          onMouseDown: P => {\n            var a;\n            w.current = !0, (a = p.onMouseDown) == null || a.call(p, P);\n          },\n          onMouseUp: P => {\n            var a;\n            w.current = !1, (a = p.onMouseUp) == null || a.call(p, P);\n          },\n          ref: mergeRefs(Q, O),\n          [\"aria-expanded\"]: Boolean(o),\n          [\"aria-controls\"]: E\n        };\n      },\n      getPopoverProps: function () {\n        let p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let O = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        return f(l({}, W.popper), {\n          style: l(l({}, p.style || {}), S.popper),\n          ref: mergeRefs(X, O),\n          id: E,\n          onBlur: P => {\n            if (p.onBlur && p.onBlur(P), !c) return;\n            let a = P.relatedTarget,\n              _ = u === a || (u == null ? void 0 : u.contains(a)),\n              ee = i === a || (i == null ? void 0 : i.contains(a)) || w.current;\n            _ || ee || n == null || n();\n          },\n          onKeyDown: P => {\n            p.onKeyDown && p.onKeyDown(P), s && P.key === \"Escape\" && I();\n          }\n        });\n      }\n    }), [o, g, W, S, d, E, s, c, u, i, I, n]);\n  return H.createElement(U, {\n    value: Z\n  }, t);\n}\nvar ce = {\n  name: \"sameWidth\",\n  enabled: !0,\n  phase: \"beforeWrite\",\n  requires: [\"computeStyles\"],\n  fn: _ref => {\n    let {\n      state: e\n    } = _ref;\n    e.styles.popper.width = `${e.rects.reference.width}px`;\n  },\n  effect: _ref2 => {\n    let {\n      state: e\n    } = _ref2;\n    return () => {\n      let t = e.elements.reference;\n      e.elements.popper.style.width = `${t.offsetWidth}px`;\n    };\n  }\n};\nvar V = e => ({\n  container: css({\n    display: e ? \"initial\" : \"none\",\n    background: x.colorWhite,\n    border: 0,\n    borderRadius: x.borderRadiusMedium,\n    boxShadow: x.boxShadowDefault,\n    zIndex: x.zIndexDropdown,\n    \"&:focus\": {\n      boxShadow: x.glowPrimary,\n      outline: \"none\"\n    },\n    \"&:focus:not(:focus-visible)\": {\n      boxShadow: x.boxShadowDefault\n    }\n  })\n});\nvar fe = (e, t) => {\n    let g = e,\n      {\n        children: o,\n        className: r,\n        testId: m = \"cf-ui-popover-content\",\n        role: v = \"dialog\"\n      } = g,\n      d = k(g, [\"children\", \"className\", \"testId\", \"role\"]),\n      {\n        isOpen: c,\n        renderOnlyWhenOpen: s,\n        getPopoverProps: n,\n        usePortal: h\n      } = y(),\n      C = V(c),\n      T = H.createElement(\"div\", f(l(l({}, d), n(d, t)), {\n        className: cx(C.container, r),\n        \"data-test-id\": m,\n        tabIndex: -1,\n        role: v,\n        \"data-position-absolute\": !0\n      }), o);\n    return s && !c ? null : h ? H.createElement(Portal, null, T) : T;\n  },\n  L = H.forwardRef(fe);\nvar R = e => {\n  var r;\n  let t = H.Children.only(e.children),\n    {\n      getTriggerProps: o\n    } = y();\n  return H.cloneElement(t, f(l({}, o(t.props, t.ref)), {\n    \"aria-haspopup\": (r = t.props[\"aria-haspopup\"]) != null ? r : \"dialog\"\n  }));\n};\nvar D = G;\nD.Content = L;\nD.Trigger = R;\nexport { D as Popover, L as PopoverContent, R as PopoverTrigger };","map":{"version":3,"names":[],"sources":["/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-popover/src/Popover.tsx","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-popover/src/PopoverContext.ts","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-popover/src/PopoverContent/PopoverContent.tsx","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-popover/src/PopoverContent/PopoverContent.styles.ts","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-popover/src/PopoverTrigger/PopoverTrigger.tsx","/Users/tsharliz/Documents/contentful/my-first-app/node_modules/@contentful/f36-popover/src/CompoundPopover.tsx"],"sourcesContent":["import React, {\n  useMemo,\n  useState,\n  useEffect,\n  useCallback,\n  useRef,\n} from 'react';\nimport { useId, mergeRefs, type ExpandProps } from '@contentful/f36-core';\nimport type { Placement, Modifier } from '@popperjs/core';\nimport { PopoverContextProvider, PopoverContextType } from './PopoverContext';\nimport { usePopper } from 'react-popper';\n\nexport interface PopoverProps {\n  children: React.ReactNode;\n\n  /**\n   * Boolean to determine if the Popover should be the same width as\n   * the trigger element\n   *\n   * @default false\n   */\n  isFullWidth?: boolean;\n\n  /**\n   * Boolean to control whether or not the Popover is open\n   *\n   * @default false\n   */\n  isOpen?: boolean;\n\n  /**\n   * Callback fired when the popover closes\n   */\n  onClose?: () => void;\n\n  /**\n   * Determines the preferred position of the Popover. This position is not\n   * guaranteed, as the Popover might be moved to fit the viewport\n   *\n   * @default bottom-start\n   */\n  placement?: Placement;\n\n  /**\n   * Boolean to control if popover is allowed to change its placement automatically\n   * based on available space in the viewport.\n   *\n   * For example:\n   * If you set placement prop to bottom, but there isn't enough space to position the popover in that direction,\n   * it will change the popper placement to top. As soon as enough space is detected, the placement will be reverted to the defined one.\n   *\n   * If you want the popover to strictly follow the placement prop you should set this prop to false.\n   *\n   * @default true\n   */\n  isAutoalignmentEnabled?: boolean;\n\n  /**\n   * Boolean to control whether or not to render the Popover in a React Portal.\n   * Rendering content inside a Portal allows the Popover to escape the bounds\n   * of its parent while still being positioned correctly. Using a Portal is\n   * necessary if an ancestor of the Popover hides overflow.\n   *\n   * @default true\n   */\n  usePortal?: boolean;\n\n  /**\n   * If true, the popover will close when you blur out it by clicking outside or tabbing out\n   *\n   * @default true\n   */\n  closeOnBlur?: boolean;\n\n  /**\n   * If true, the popover will close when you hit the Esc key\n   *\n   * @default true\n   */\n  closeOnEsc?: boolean;\n\n  /**\n   * If true, the popover will be focused after opening\n   *\n   * @default true\n   */\n  autoFocus?: boolean;\n\n  /**\n   * Popover id. Will be used as an `id` attribute on popover\n   * and as `aria-controls` attribute on trigger\n   *\n   * @default true\n   */\n  id?: string;\n\n  /**\n   * The `X-axis` and `Y-axis` offset to position popper element\n   * from its trigger element. `[X, Y]`\n   *\n   * @default [1, 4]\n   */\n  offset?: [number, number];\n\n  /**\n   * Defines if popover should be rendered in the DOM only when it's open\n   * or all the time (after the component has been mounted)\n   *\n   * @default true\n   */\n  renderOnlyWhenOpen?: boolean;\n}\n\nexport function Popover(props: ExpandProps<PopoverProps>) {\n  const {\n    children,\n    isOpen,\n    placement = 'bottom-start',\n    isFullWidth = false,\n    isAutoalignmentEnabled = true,\n    usePortal = true,\n    closeOnBlur = true,\n    closeOnEsc = true,\n    onClose,\n    autoFocus = true,\n    id,\n    offset = [1, 4],\n    renderOnlyWhenOpen = true,\n  } = props;\n\n  const [triggerElement, setTriggerElement] = useState<HTMLElement | null>(\n    null,\n  );\n  const [popoverElement, setPopoverElement] = useState<HTMLElement | null>(\n    null,\n  );\n\n  const {\n    attributes: popperAttributes,\n    update,\n    styles: popperStyles,\n  } = usePopper(triggerElement, popoverElement, {\n    placement,\n    modifiers: [\n      {\n        name: 'offset',\n        options: {\n          offset,\n        },\n      },\n      {\n        ...sameWidth,\n        enabled: isFullWidth,\n      },\n      {\n        name: 'preventOverflow',\n        enabled: isAutoalignmentEnabled,\n        options: {\n          mainAxis: true,\n        },\n      },\n      {\n        name: 'flip',\n        enabled: isAutoalignmentEnabled,\n      },\n    ],\n  });\n\n  useEffect(() => {\n    if (isOpen && autoFocus && popoverElement) {\n      popoverElement.focus({ preventScroll: true });\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isOpen, popoverElement]);\n\n  useEffect(() => {\n    const updatePosition = async () => {\n      if (isOpen && update) {\n        await update();\n      }\n    };\n    updatePosition();\n  }, [isOpen, update]);\n\n  const popoverGeneratedId = useId(undefined, 'popover-content');\n  const popoverId = id || popoverGeneratedId;\n\n  const closeAndFocusTrigger = useCallback(() => {\n    onClose?.();\n\n    // setTimeout trick to make it work with focus-lock\n    setTimeout(() => triggerElement?.focus({ preventScroll: true }), 0);\n  }, [onClose, triggerElement]);\n\n  // Safari has an issue with the relatedTarget that we use on the onBlur for getPopoverProps,\n  // which was causing the popover to close and reopen when clicking on the trigger.\n  // We will use the isMouseDown to prevent triggering blur in the cases where the user clicks on the trigger.\n  const isMouseDown = useRef<Boolean>(false);\n\n  const contextValue: PopoverContextType = useMemo(\n    () => ({\n      isOpen: Boolean(isOpen),\n      usePortal,\n      renderOnlyWhenOpen,\n      getTriggerProps: (_props = {}, _ref = null) => ({\n        onMouseDown: (event) => {\n          isMouseDown.current = true;\n          _props.onMouseDown?.(event);\n        },\n        onMouseUp: (event) => {\n          isMouseDown.current = false;\n          _props.onMouseUp?.(event);\n        },\n        ref: mergeRefs(setTriggerElement, _ref),\n        ['aria-expanded']: Boolean(isOpen),\n        ['aria-controls']: popoverId,\n      }),\n      getPopoverProps: (_props = {}, _ref = null) => ({\n        ...popperAttributes.popper,\n        style: {\n          ...(_props.style || {}),\n          ...popperStyles.popper,\n        },\n        ref: mergeRefs(setPopoverElement, _ref),\n        id: popoverId,\n        onBlur: (event: React.FocusEvent<HTMLDivElement>) => {\n          if (_props.onBlur) {\n            _props.onBlur(event);\n          }\n\n          if (!closeOnBlur) {\n            return;\n          }\n\n          const relatedTarget = event.relatedTarget as Node;\n\n          const targetIsPopover =\n            popoverElement === relatedTarget ||\n            popoverElement?.contains(relatedTarget);\n          const targetIsTrigger =\n            triggerElement === relatedTarget ||\n            triggerElement?.contains(relatedTarget) ||\n            isMouseDown.current;\n\n          if (targetIsPopover || targetIsTrigger) {\n            return;\n          }\n\n          onClose?.();\n        },\n        onKeyDown: (event: React.KeyboardEvent<HTMLDivElement>) => {\n          if (_props.onKeyDown) {\n            _props.onKeyDown(event);\n          }\n\n          if (closeOnEsc && event.key === 'Escape') {\n            closeAndFocusTrigger();\n          }\n        },\n      }),\n    }),\n    [\n      isOpen,\n      renderOnlyWhenOpen,\n      popperAttributes,\n      popperStyles,\n      usePortal,\n      popoverId,\n      closeOnEsc,\n      closeOnBlur,\n      popoverElement,\n      triggerElement,\n      closeAndFocusTrigger,\n      onClose,\n    ],\n  );\n\n  return (\n    <PopoverContextProvider value={contextValue}>\n      {children}\n    </PopoverContextProvider>\n  );\n}\n\n/**\n * Sets the popover width to the size of the trigger element.\n */\nconst sameWidth: Modifier<'sameWidth', any> = {\n  name: 'sameWidth',\n  enabled: true,\n  phase: 'beforeWrite',\n  requires: ['computeStyles'],\n  fn: ({ state }) => {\n    state.styles.popper.width = `${state.rects.reference.width}px`;\n  },\n  effect:\n    ({ state }) =>\n    () => {\n      const reference = state.elements.reference as HTMLElement;\n      state.elements.popper.style.width = `${reference.offsetWidth}px`;\n    },\n};\n","import React, { HTMLProps } from 'react';\n\nexport type PopoverContextType = {\n  isOpen: boolean;\n  usePortal: boolean;\n  renderOnlyWhenOpen: boolean;\n  getPopoverProps: (\n    _props: HTMLProps<HTMLDivElement>,\n    _ref: React.Ref<HTMLDivElement>,\n  ) => HTMLProps<HTMLDivElement>;\n  getTriggerProps: (\n    _props: HTMLProps<HTMLElement>,\n    _ref: React.Ref<HTMLElement>,\n  ) => HTMLProps<HTMLElement>;\n};\n\nconst PopoverContext = React.createContext<PopoverContextType | undefined>(\n  undefined,\n);\n\nexport const usePopoverContext = () => {\n  const context = React.useContext(PopoverContext);\n\n  if (context === undefined) {\n    throw new Error(\n      'usePopoverContext must be used within a PopoverContextProvider',\n    );\n  }\n\n  return context;\n};\n\nexport const PopoverContextProvider = PopoverContext.Provider;\n","import React from 'react';\nimport { cx } from 'emotion';\nimport type {\n  CommonProps,\n  PropsWithHTMLElement,\n  ExpandProps,\n} from '@contentful/f36-core';\nimport { usePopoverContext } from '../PopoverContext';\nimport { Portal } from '@contentful/f36-utils';\nimport { getPopoverContentStyles } from './PopoverContent.styles';\n\ninterface PopoverContentInternalProps extends CommonProps {\n  children?: React.ReactNode;\n}\n\nexport type PopoverContentProps = PropsWithHTMLElement<\n  PopoverContentInternalProps,\n  'div'\n>;\n\nconst _PopoverContent = (props: ExpandProps<PopoverContentProps>, ref) => {\n  const {\n    children,\n    className,\n    testId = 'cf-ui-popover-content',\n    role = 'dialog',\n    ...otherProps\n  } = props;\n  const { isOpen, renderOnlyWhenOpen, getPopoverProps, usePortal } =\n    usePopoverContext();\n\n  const styles = getPopoverContentStyles(isOpen);\n\n  const content = (\n    <div\n      {...otherProps}\n      {...getPopoverProps(otherProps, ref)}\n      className={cx(styles.container, className)}\n      data-test-id={testId}\n      tabIndex={-1}\n      role={role}\n      // specific attribute to mark that this element is absolute positioned\n      // for internal contentful apps usage\n      data-position-absolute\n    >\n      {children}\n    </div>\n  );\n\n  if (renderOnlyWhenOpen && !isOpen) {\n    return null;\n  }\n\n  return usePortal ? <Portal>{content}</Portal> : content;\n};\n\nexport const PopoverContent = React.forwardRef(_PopoverContent);\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\n\nexport const getPopoverContentStyles = (isOpen: boolean) => ({\n  container: css({\n    display: isOpen ? 'initial' : 'none',\n    background: tokens.colorWhite,\n    border: 0,\n    borderRadius: tokens.borderRadiusMedium,\n    boxShadow: tokens.boxShadowDefault,\n    zIndex: tokens.zIndexDropdown,\n    '&:focus': {\n      boxShadow: tokens.glowPrimary,\n      outline: 'none',\n    },\n    '&:focus:not(:focus-visible)': {\n      boxShadow: tokens.boxShadowDefault,\n    },\n  }),\n});\n","import React from 'react';\nimport { usePopoverContext } from '../PopoverContext';\n\nexport interface PopoverTriggerProps {\n  children: React.ReactNode;\n}\n\n/**\n * PopoverTrigger opens the popover. It must be an interactive element.\n */\nexport const PopoverTrigger = (props: PopoverTriggerProps) => {\n  const child = React.Children.only(props.children) as any;\n  const { getTriggerProps } = usePopoverContext();\n\n  return React.cloneElement(child, {\n    ...getTriggerProps(child.props, child.ref),\n    'aria-haspopup': child.props['aria-haspopup'] ?? 'dialog',\n  });\n};\n","import { Popover as OriginalPopover } from './Popover';\nimport { PopoverContent } from './PopoverContent/PopoverContent';\nimport { PopoverTrigger } from './PopoverTrigger/PopoverTrigger';\n\ntype CompoundPopover = typeof OriginalPopover & {\n  Content: typeof PopoverContent;\n  Trigger: typeof PopoverTrigger;\n};\n\nexport const Popover = OriginalPopover as CompoundPopover;\nPopover.Content = PopoverContent;\nPopover.Trigger = PopoverTrigger;\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}