{"version":3,"sources":["../src/Portal/Portal.tsx","../src/useKeyboard/useKeyboard.ts","../src/getStringMatch/getStringMatch.ts","../src/hexToRGBA/hexToRGBA.ts"],"names":["useEffect","useRef","createPortal","Portal","children","containerElement","container","portal","portalContainer","useCallback","useKeyboard","props","ref","keys","event","element","handleKeyEvent","e","getStringMatch","base","match","matchResult","escapedMatch","regex","matches","hexToRGBA","hex","alpha","r","g","b"],"mappings":"AAAA,OAAS,aAAAA,EAAW,UAAAC,MAAc,QAClC,OAAS,gBAAAC,MAAoB,YAUtB,SAASC,EAAO,CACrB,SAAAC,EACA,UAAWC,CACb,EAA0C,CACxC,IAAMC,EAAYL,EAChBI,CACF,EACME,EAASN,EAAuB,SAAS,cAAc,KAAK,CAAC,EAEnE,OAAAD,EAAU,IAAM,CACTM,EAAU,UACbA,EAAU,QAAU,SAAS,MAG/B,IAAME,EAAkBD,EAAO,QAC/B,OAAAC,EAAgB,aAAa,oBAAqB,EAAE,EACpDF,EAAU,QAAQ,YAAYE,CAAe,EAEtC,IAAM,CACPF,EAAU,SACZA,EAAU,QAAQ,YAAYE,CAAe,CAEjD,CACF,EAAG,CAAC,CAAC,EAEED,EAAO,QAAUL,EAAaE,EAAUG,EAAO,OAAO,EAAI,IACnE,CCrCA,OAAS,aAAAP,EAAW,eAAAS,MAAqC,QAmClD,IAAMC,EAAeC,GAA4B,CACtD,GAAM,CAAE,IAAAC,EAAK,KAAAC,EAAM,MAAAC,EAAQ,SAAU,EAAIH,EACrCI,EAAkC,SAEhCC,EAAiBP,EACpBQ,GAAM,CACS,OAAO,UAAU,eAAe,KAAKJ,EAAMI,EAAE,GAAG,GAE5DJ,EAAKI,EAAE,KAAKA,CAAC,CAEjB,EACA,CAACJ,CAAI,CACP,EAEAb,EAAU,KACJY,GAAOA,EAAI,UACbG,EAAUH,EAAI,SAGhBG,EAAQ,iBAAiBD,EAAOE,CAAc,EACvC,IAAM,CACXD,EAAQ,oBAAoBD,EAAOE,CAAc,CACnD,GACC,CAACF,EAAOE,CAAc,CAAC,CAC5B,EC3CO,SAASE,EAAeC,EAAcC,EAAyB,CACpE,IAAMC,EAAc,CAAE,OAAQ,GAAI,MAAO,GAAI,MAAO,EAAG,EACjDC,EAAeF,EAAM,QAAQ,sBAAuB,MAAM,EAE1DG,EAAQ,IAAI,OAChB,0BAA0BD,iBAC1B,GACF,EACME,EAAUL,EAAK,MAAMI,CAAK,EAEhC,OAAIC,IACFH,EAAY,OAASG,EAAQ,OAAO,OACpCH,EAAY,MAAQG,EAAQ,OAAO,MACnCH,EAAY,MAAQG,EAAQ,OAAO,OAG9BH,CACT,CCzBO,SAASI,EAAUC,EAAaC,EAAQ,EAAG,CAChD,IAAMC,EAAI,SAASF,EAAI,MAAM,EAAG,CAAC,EAAG,EAAE,EAChCG,EAAI,SAASH,EAAI,MAAM,EAAG,CAAC,EAAG,EAAE,EAChCI,EAAI,SAASJ,EAAI,MAAM,EAAG,CAAC,EAAG,EAAE,EAEtC,MAAO,QAAQE,MAAMC,MAAMC,MAAMH,IACnC","sourcesContent":["import { useEffect, useRef } from 'react';\nimport { createPortal } from 'react-dom';\n\nexport interface PortalProps {\n  children: React.ReactElement;\n  /**\n   * Container element for Portal\n   */\n  container?: Document | HTMLElement;\n}\n\nexport function Portal({\n  children,\n  container: containerElement,\n}: PortalProps): React.ReactPortal | null {\n  const container = useRef<Document | HTMLElement | undefined>(\n    containerElement,\n  );\n  const portal = useRef<HTMLDivElement>(document.createElement('div'));\n\n  useEffect(() => {\n    if (!container.current) {\n      container.current = document.body;\n    }\n\n    const portalContainer = portal.current;\n    portalContainer.setAttribute('data-cf-ui-portal', '');\n    container.current.appendChild(portalContainer);\n\n    return () => {\n      if (container.current) {\n        container.current.removeChild(portalContainer);\n      }\n    };\n  }, []);\n\n  return portal.current ? createPortal(children, portal.current) : null;\n}\n","import { useEffect, useCallback, MutableRefObject } from 'react';\n\nexport interface UseKeyboardProps {\n  /**\n   * Object of key names and handlers defines which key to look for i.e. `ArrowUp`, `Escape`, `Shift`\n   * value is a callback function to be called when key matches\n   */\n  keys: {\n    [key: string]: (e: KeyboardEvent) => void;\n  };\n  /**\n   * Defines the attached event type\n   * @default 'keydown'\n   */\n  event?: 'keyup' | 'keypress' | 'keydown';\n\n  /**\n   * React reference to attach the event to its current element\n   */\n  ref?: MutableRefObject<HTMLElement>;\n}\n\n/**\n *\n * @description hook to attach a handler keyboard event listener to `document` or `HTMLElements` with garbage collection\n * @example\n * useKeyboard({\n *  event: 'keydown', // Optional, default is `keydown`\n *  ref: yourReactRef, // Optional, by default event is attached to document\n *  keys: {\n *    ArrowUp: (e) => handleArrowUp(e),\n *    Tab: (e) => handleTab(e)\n *  }\n * })\n */\nexport const useKeyboard = (props: UseKeyboardProps) => {\n  const { ref, keys, event = 'keydown' } = props;\n  let element: HTMLElement | Document = document;\n\n  const handleKeyEvent = useCallback(\n    (e) => {\n      const isKey = Object.prototype.hasOwnProperty.call(keys, e.key);\n      if (isKey) {\n        keys[e.key](e);\n      }\n    },\n    [keys],\n  );\n\n  useEffect(() => {\n    if (ref && ref.current) {\n      element = ref.current;\n    }\n\n    element.addEventListener(event, handleKeyEvent);\n    return () => {\n      element.removeEventListener(event, handleKeyEvent);\n    };\n  }, [event, handleKeyEvent]);\n};\n","export interface MatchObj {\n  before: string;\n  match: string;\n  after: string;\n}\n\n/**\n * Function that can be used to find a substring inside another string.\n * It needs two strings, the second one will be used in a Regex expression\n * to be matched to the first one.\n * The function will return an object containing the match, what comes before the match,\n * and what comes after the match in the base string\n *\n * @param base\n * @param match\n */\nexport function getStringMatch(base: string, match: string): MatchObj {\n  const matchResult = { before: '', match: '', after: '' };\n  const escapedMatch = match.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n  const regex = new RegExp(\n    `(?<before>.*?)(?<match>${escapedMatch})(?<after>.*)`,\n    'i',\n  );\n  const matches = base.match(regex);\n\n  if (matches) {\n    matchResult.before = matches.groups.before;\n    matchResult.match = matches.groups.match;\n    matchResult.after = matches.groups.after;\n  }\n\n  return matchResult;\n}\n","/**\n * Converts a hex color to rgba\n * @param hex - Hex color\n * @param alpha - Alpha value @default 1\n * @returns rgba color\n * @example\n * hexToRGBA('#000000', 0.5)\n */\nexport function hexToRGBA(hex: string, alpha = 1) {\n  const r = parseInt(hex.slice(1, 3), 16);\n  const g = parseInt(hex.slice(3, 5), 16);\n  const b = parseInt(hex.slice(5, 7), 16);\n\n  return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n}\n"]}